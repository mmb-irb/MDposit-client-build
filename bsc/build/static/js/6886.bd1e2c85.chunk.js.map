{"version":3,"file":"static/js/6886.bd1e2c85.chunk.js","mappings":"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","sources":["webpack://mdposit/./src/components/loading/style.module.css?350d","components/loading/index.js","utils/project-manager/index.js","utils/topology-manager/index.js","hooks/use-toggle-state/index.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"loading\":\"style_loading__Vdgbc\",\"show\":\"style_show__wIdQ5\"};","import React, { useLayoutEffect } from 'react';\nimport cn from 'classnames';\n//import { sleep, frame } from 'timing-functions';\n\nimport { CircularProgress } from '@mui/material';\n\nimport useToggleState from '../../hooks/use-toggle-state';\n\nimport style from './style.module.css';\n\nconst WAIT_DELAY = 750; // 750ms\n\n// This component is used to hide the loading indicator for a bit (just in case\n// the next content is quick enough, because we don't want a flash with the\n// indicator), then slowly display it.\n// In the best of cases this component will *never* even have to be displayed\nconst Loading = ({ wait = WAIT_DELAY }) => {\n  const [flag, toggleFlag] = useToggleState(false);\n  // This is a hook\n  useLayoutEffect(() => {\n    const timer = setTimeout(() => {\n      toggleFlag();\n    }, wait);\n    return () => clearTimeout(timer);\n\n    /*\n    let mounted = true;\n    sleep(wait) // wait for a bit\n      // this might be useful if the page is not even visible\n      .then(() => frame()) // Wait for the next animation frame\n      // After waiting, check if mounted is still true\n      .then(() => {\n        // If mounted is false it means that the loading was over before the wait ended\n        if (mounted) toggleFlag(); // This toggleFlag changes the flag from false to true\n      });\n    // In a useEffect or similar hooks, \"return\" stands for an ending function\n    // The ending function is called when the components is no longer rendered\n    return () => (mounted = false); // When useLayoutEffect is over or cancelled, set mounted to false\n    */\n  }, [toggleFlag, wait]); // useLayoutEffect is only called when the toggleFlag is called (only once)\n  // Return an animated circle\n  return (\n    <div\n      title=\"loading...\" // This tag appears when the mouse remains over the circle\n      className={cn(style.loading, { [style.show]: flag })}\n    >\n      {flag && (\n        <CircularProgress\n          variant=\"indeterminate\"\n          color=\"primary\"\n          size={50}\n          thickness={5}\n        /> // Renders the circle\n      )}\n    </div>\n  );\n};\n\nexport default Loading;\n","// Get the use memo hook\nimport React, { useMemo } from 'react';\n// Function to request data through the API\nimport useAPI from '../../hooks/use-api';\n// Constants\nimport {\n    BASE_PATH_PROJECTS,\n    HOST_CONFIG,\n    REFERENCES_WITH_ENTROPIES,\n    REFERENCES_WITH_EPITOPES\n} from '../constants';\n// Load the topology manager class\nimport { Topology } from '../../utils/topology-manager';\n\n// Set the project class\nexport class Project {\n    constructor(projectPayload) {\n        // Replicate all payload values in the project object\n        // This includes values such as metadata, files index, accession, etc.\n        Object.entries(projectPayload).forEach(([key, value]) => {\n            this[key] = value;\n        });\n        // If the project is si wrong we do not even have metadata then stop here\n        if (!this.metadata) return;\n        // Calculate any additional metadata\n        if (!this.metadata.mdFrames) this.metadata.mdFrames = this.metadata.SNAPSHOTS;\n        this.metadata.timeLength = (this.metadata.FRAMESTEP && this.metadata.mdFrames &&\n            this.metadata.FRAMESTEP * this.metadata.mdFrames) || null;\n        // Set the count of MDs by excluding those MDs flagged as 'removed'\n        this.mdCount = this.mds ? this.mds.filter(md => md.slice(-9) !== '(removed)').length : 0;\n        // Calculate a few internal things\n        // Get the accession and the MD number in a single string which is useful to make API requests\n        // If project is in the old format then do not add the point and the MD number\n        const accessionOrId = this.accession || this.identifier;\n        this.accessionAndMdNumber = this.mds ? `${accessionOrId}.${this.mdNumber}` : accessionOrId;\n        // Check if there are interactions\n        this.hasInteractions = this.analyses.includes('interactions');\n        // Check if the populations file is found in the files index\n        this.isPopulated = Boolean(\n            this.files && this.files.find(filename => filename === 'populations.json'),\n        );\n        // Set the available directions in the client according to project data and host configuration\n        // IMPORTANT: Note that for every direction there must be a directory with equal name under src/pages/accession/\n        // Start with the directions which are to be always available\n        this.directions = {\n            overview: true,\n            trajectory: true,\n            files: true\n        }\n        // Set available analyses\n        // Start with the generic analyses\n        // These analyses are always visible but not clickable when data is missing\n        const genericAnalyses = [ 'rmsds', 'rgyr', 'fluctuation', 'pca', 'rmsd-perres',\n            'rmsd-pairwise', 'dist-perres', 'hbonds', 'energies', 'pockets', 'sasa', 'clusters', 'density' ];\n        for (const analysis of genericAnalyses) {\n            this.directions[analysis] = this.analyses.includes(analysis);\n        }\n        // Add the electrostatic direction whenever there are interactions\n        this.directions['electrostatic'] = this.analyses.includes('interactions');\n        // Add reference specific directions\n        this.directions['ligand-descriptors'] = Boolean(this.metadata && this.metadata.LIGANDS && this.metadata.LIGANDS.length > 0);\n        // Now set some specialized analyses\n        // These analyses are hidden when the project is out of context\n        // Their availability may be also more complicated than the generic ones\n        // Set covid-19 specific analyses\n        if (HOST_CONFIG.options.includes('covid')) {\n            const anyReferenceWithEntropies = this.metadata && this.metadata.REFERENCES &&\n                this.metadata.REFERENCES.find(ref => REFERENCES_WITH_ENTROPIES.includes(ref));\n            this.directions['mutations'] = Boolean(anyReferenceWithEntropies);\n            const anyReferenceWithEpitopes = this.metadata && this.metadata.REFERENCES &&\n                this.metadata.REFERENCES.find(ref => REFERENCES_WITH_EPITOPES.includes(ref));\n            this.directions['epitopes'] = Boolean(anyReferenceWithEpitopes);\n        }\n        // Set MSM specific analyses\n        if (this.metadata && this.metadata.METHOD === 'Markov state model (MSM)') {\n            this.directions['populations'] = this.files && this.files.find(file => file === 'populations.json');\n            this.directions['markov'] = this.analyses.includes('markov');\n        }\n        // Set an internal object to save data requested through the API\n        this._apiResponses = {\n            topology: undefined,\n            interactions: undefined,\n            references: undefined,\n            fileDescriptors: undefined,\n            populations: undefined\n        };\n        // Save the topology manager apart so we do not have to re-instantiate the class every time\n        this._topologyManager = null;\n        // Set the project base URL to request the API\n        this._apiBaseUrl = `${BASE_PATH_PROJECTS}/${this.accessionAndMdNumber}`;\n    }\n    // Declare the different field endpoints to request the API\n    _apiEndpoints = {\n        topology: `/topology`,\n        interactions: `/analyses/interactions`,\n        references: `/references`,\n        fileDescriptors: `/filenotes`,\n        populations: `/files/populations.json`,\n    }\n    // Set a function to query the API and store the response for internal variables\n    _apiQuery = (fieldname, available = true) => {\n        // Set the request URL\n        let url = this._apiBaseUrl + this._apiEndpoints[fieldname];\n        // Request the value if it is available only\n        if (!available) url = null;\n        // If data for the requested fieldname is already saved then set the url as null\n        // This makes the useAPI hook not to repeat the query\n        if (this._apiResponses[fieldname] && this._apiResponses[fieldname].payload) url = null;\n        // Do the API query but save the result only if the url is not null\n        // Note that if url is null from the first render (i.e. there is not value at all) then its value will be null\n        const query = useAPI(url);\n        if (url !== null) this._apiResponses[fieldname] = query;\n        // If we are still loading then\n        return this._apiResponses[fieldname];\n    };\n\n    // Interactions getter\n    get interactions () {\n        const response = this._apiQuery('interactions', this.hasInteractions);\n        if (response === undefined) return undefined;\n        if (response.loading) return undefined;\n        if (response.error) throw new Error('Error when downloading project interactions: ' + response.error.message);\n        if (!response.payload) throw new Error('Something went wrong with project interactions');\n        return response.payload;\n    }\n\n    // References getter\n    get references () {\n        const response = this._apiQuery('references');\n        if (response.loading) return undefined;\n        if (response.error) throw new Error('Error when downloading project references: ' + response.error.message);\n        if (!response.payload) throw new Error('Something went wrong with project references');\n        return response.payload;\n    }\n    // Specific references getters\n    get proteinReferences () {\n        const references = this.references;\n        return useMemo(() => references && references.filter(ref => ref.ref_type === 'proteins'), [references]);\n    }\n    get ligandReferences () {\n        const references = this.references;\n        return useMemo(() => references && references.filter(ref => ref.ref_type === 'ligands'), [references]);\n    }\n    get pdbReferences () {\n        const references = this.references;\n        return useMemo(() => references && references.filter(ref => ref.ref_type === 'pdbs'), [references]);\n    }\n    get chainReferences () {\n        const references = this.references;\n        return useMemo(() => references && references.filter(ref => ref.ref_type === 'chains'), [references]);\n    }\n\n    // Topology getter\n    get topology () {\n        // Get references to further load them to the topology manager\n        // Note that this must be done here to respect hooks\n        const references = this.references;\n        // Set an object with references used by the topology manager already classified\n        const topologyManagerReferences = {\n            proteins: this.proteinReferences,\n            ligands: this.ligandReferences,\n            chains: this.chainReferences\n        };\n        // Request topology data\n        const response = this._apiQuery('topology');\n        // Make sure data is available\n        if (response.loading) return undefined;\n        if (response.error) throw new Error('Error when downloading project topology: ' + response.error.message);\n        if (!response.payload) throw new Error('Something went wrong with project topology');\n        // Return the stored value in case we already have it\n        if (this._topologyManager) return this._topologyManager;\n        // Make sure references are available\n        if (references === undefined) return undefined;\n        this._topologyManager = new Topology(response.payload, this.metadata, topologyManagerReferences);\n        return this._topologyManager;\n    }\n\n    // File descriptors getter\n    get fileDescriptors () {\n        return this._apiQuery('fileDescriptors');\n    }\n    // Populations getter (populated ensembles only)\n    // Populations are requested only when this variable is read for the first time\n    // Then populations are stored so there is no need to repeat the query again\n    get populations () {\n        return this._apiQuery('populations', this.isPopulated);\n    }\n\n    // Get the reference frame\n    // Coordinates from this frame are to be used when representing the structure\n    // It is a frame which has been selected for distance between atoms to be coherent with atom bonds\n    // i.e. there are not bonded atoms to far or non-bonded atoms to close\n    // If bonds were to be guessed by atom distance they would be guess right\n    get referenceFrame () {\n        // If there is no reference frame then we use the first frame by default\n        // Note that old outdated projects may not have reference frame\n        if (this.refframe === undefined) return 0;\n        return this.refframe;\n    }\n}\n  ","import { range } from 'lodash-es';\nconst ngl = require('ngl');\n\n// Topology manager\n// Many functions to handle atom/residue/chain numeration conversions and more\n// All these functions which need the topology are able to read the context topology\n// However, it may be better to pass them the topology as an argument since the context may be null\n\n// There are 4 different residue numeration types in the client:\n// - Residue indices: From 0 to 'n'\n//   Used in some internal managments\n// - Residue numbers: Source numbers in the original topology file\n//   Residue numbers may be repeated, have gaps or do not start at 0 or 1. May include icodes.\n// - Residue reference numbers (protein residues only): The number according to uniprot reference sequence\n//   Reference numbers are displayed in the viewer or analysis results when available\n\n// This function transforms a range selection string into a numeric array\n// It handles abbreviated selection syntax to literal selection syntax\n// e.g. \"1, 3, 5-8\" => [1, 3, 5, 6, 7, 8]\nconst rangedSyntax = /^([0-9]*)-([0-9]*)$/;\nexport const rangedSelectionParser = selection => {\n  // Filter data\n  const units = selection.split(', ');\n  const parsedSelection = [];\n  for (const u of units) {\n    // If the ranged syntax is found, get all numbers in between\n    if (u.match(rangedSyntax)) {\n      const matches = rangedSyntax.exec(u);\n      const rangedUnits = range(+matches[1], +matches[2] + 1);\n      parsedSelection.push(...rangedUnits);\n    } else parsedSelection.push(+u);\n  }\n  return parsedSelection;\n};\n\n// Do the opposite that the previous function\n// e.g. [1, 3, 5, 6, 7, 8] => \"1, 3, 5-8\"\n// In addition track the minimum serie length\n// Return 'small' = true when there are series of 3 residues or less\n// These small residue selections will be not represented in cartoon due to an NGL bug\n// https://github.com/nglviewer/ngl/issues/223\nexport const parsedSelectionRanger = (selection, addWhiteSpaces = true) => {\n  const separator = addWhiteSpaces ? ', ' : ',';\n  let rangedSelection = '';\n  let minimumSerieLength = Number.POSITIVE_INFINITY;\n  selection.sort((a, b) => a - b); // Sort numbers numerically\n  const selectionLength = selection.length;\n  // When the selection is a single value\n  if (selectionLength === 1) {\n    return { rangedSelection: selection[0].toString(), small: true };\n  }\n  for (let i = 0; i < selectionLength; i++) {\n    const num = selection[i];\n    rangedSelection += separator + num;\n    for (let j = i + 1; j < selectionLength; j++) {\n      const nextNum = selection[j];\n      let length = j - i; // The serie length\n      if (nextNum - num !== length) {\n        // End of the serie\n        // The length here is the length which broke the serie\n        // i.e. if the length here is 2 the actual serie length is 1\n        length -= 1;\n        minimumSerieLength = Math.min(length, minimumSerieLength);\n        // If the length of the serie is <= 1 then no worth making a range here\n        if (length > 1) {\n          const prevNum = selection[j - 1];\n          rangedSelection += '-' + prevNum;\n          i = j - 1;\n        }\n        break;\n      }\n      if (j === selectionLength - 1) {\n        // End of the selection\n        minimumSerieLength = Math.min(length, minimumSerieLength);\n        if (length > 1) {\n          rangedSelection += '-' + nextNum;\n          i = j;\n        }\n      }\n    }\n  }\n  const small = minimumSerieLength <= 3;\n  rangedSelection = rangedSelection.substring(separator.length); // Remove the first separator\n  return { rangedSelection, small };\n};\n\n// Harvest from a '[residue_type]residue:chain' string the chain letter and the residue number values\nconst nglFormat = /^\\[[0-9a-zA-Z_]*\\]([0-9]*)([A-Z]?):([A-Z])$/;\nexport const nglNumerationParser = numeration => {\n  const result = nglFormat.exec(numeration);\n  if (!result)\n    throw new Error('No matched NGL numeration value: ' + numeration);\n  const chain = result[3];\n  const residue = result[1];\n  const icode = result[2] || ''; // DANI: El icode es de mi huerto. Falta chequear\n  // Formated selection to select this specific residue in NGL\n  const nglSelection = ':' + chain + ' and ' + residue;\n  // Complex numeration\n  const complex = chain + ':' + residue + icode;\n  return { chain, residue: +residue, icode, nglSelection, complex };\n};\n\n// Define the residue type letters\nconst residueLetters = {\n  ALA: 'A',\n  ALAN: 'A',\n  ALAC: 'A',\n  ARG: 'R',\n  ARGN: 'R',\n  ARGC: 'R',\n  ASN: 'N',\n  ASNN: 'N',\n  ASNC: 'N',\n  ASP: 'D',\n  ASPN: 'D',\n  ASPC: 'D',\n  CYS: 'C',\n  CYSN: 'C',\n  CYSC: 'C',\n  CYH: 'C',\n  CSH: 'C',\n  CSS: 'C',\n  CYX: 'C',\n  CYP: 'C',\n  GLN: 'Q',\n  GLNN: 'Q',\n  GLNC: 'Q',\n  GLU: 'E',\n  GLUN: 'E',\n  GLUC: 'E',\n  GLY: 'G',\n  GLYN: 'G',\n  GLYC: 'G',\n  HIS: 'H',\n  HISN: 'H',\n  HISC: 'H',\n  HID: 'H',\n  HIE: 'H',\n  HIP: 'H',\n  HSD: 'H',\n  HSE: 'H',\n  ILE: 'I',\n  ILEN: 'I',\n  ILEC: 'I',\n  ILU: 'I',\n  LEU: 'L',\n  LEUN: 'L',\n  LEUC: 'L',\n  LYS: 'K',\n  LYSN: 'K',\n  LYSC: 'K',\n  MET: 'M',\n  METN: 'M',\n  METC: 'M',\n  PHE: 'F',\n  PHEN: 'F',\n  PHEC: 'F',\n  PRO: 'P',\n  PRON: 'P',\n  PROC: 'P',\n  PRØ: 'P',\n  PR0: 'P',\n  PRZ: 'P',\n  SER: 'S',\n  SERN: 'S',\n  SERC: 'S',\n  THR: 'T',\n  THRN: 'T',\n  THRC: 'R',\n  TRP: 'W',\n  TRPN: 'W',\n  TRPC: 'W',\n  TRY: 'W',\n  TYR: 'Y',\n  TYRN: 'Y',\n  TYRC: 'Y',\n  VAL: 'V',\n  VALN: 'V',\n  VALC: 'V',\n  // Nucleotides\n  A: 'A',\n  A3: 'A',\n  A5: 'A',\n  C: 'C',\n  C3: 'C',\n  C5: 'C',\n  T: 'T',\n  T3: 'T',\n  T5: 'T',\n  G: 'G',\n  G3: 'G',\n  G5: 'G',\n  U: 'U',\n  U3: 'U',\n  U5: 'U',\n  DA: 'A',\n  DT: 'T',\n  DC: 'C',\n  DG: 'G',\n};\n\nexport const getResidueTypeLetter = residueType => {\n  if (!residueType) return;\n  const letter = residueLetters[residueType];\n  if (letter) return letter;\n  return 'X';\n};\n\n// Check if an NGL residues is cartoon supported or not\n// e.g. check if it is recognized by NGL as a protein, RNA or DNA residue\nexport const isCartoonSupported = nglResidue => {\n  return nglResidue.isProtein() || nglResidue.isRna() || nglResidue.isDna();\n};\n\n// Convert a ngl selection string into an array of residue indices\n// If the 'onlyCartoonSupported' parameter is passed then it will return only cartoon supported residues\nexport const nglSelection2residueIndices = (\n  nglSelection,\n  onlyCartoonSupported = false,\n  viewerTopology,\n) => {\n  const residueIndices = [];\n  // Save the selection in ngl format (structureComponent)\n  const selection = new ngl.Selection(nglSelection);\n  // Save the data from structure which corresponds to the selection atoms\n  const view = viewerTopology.getView(selection);\n  if (onlyCartoonSupported) {\n    view.eachResidue(residue => {\n      if (isCartoonSupported(residue)) residueIndices.push(residue.index);\n    });\n  } else {\n    view.eachResidue(residue => {\n      residueIndices.push(residue.index);\n    });\n  }\n  return residueIndices;\n};\n\n// Check if a NGL selection contains any atom\nexport const nglSelectionExists = (\n  nglSelection,\n  viewerTopology,\n) => {\n  // Save the selection in ngl format (structureComponent)\n  const selection = new ngl.Selection(nglSelection);\n  // Save the data from structure which corresponds to the selection atoms\n  const view = viewerTopology.getView(selection);\n  if (view.atomCount === 0) return false;\n  return true;\n};\n\n// Set the element colors for displaying\nconst elementColors = {\n  H: 'white',\n  C: 'grey',\n  N: 'blue',\n  O: 'red',\n  S: 'yellow',\n  P: 'orange',\n};\n\n// Set an atom handler\nclass Atom {\n  // Constructor expects the topology this atom belongs to and the atom index\n  constructor (topology, atomIndex) {\n    this.topology = topology;\n    this.index = atomIndex;\n  }\n  // Atom name\n  get name () {\n    return this.topology.atomNames[this.index];\n  }\n  // Index of the residue this atom belongs to\n  get residueIndex () {\n    return this.topology.atomResidueIndices[this.index];\n  }\n  // Residue this atom belongs to\n  get residue () {\n    return this.topology.getResidueByIndex(this.residueIndex);\n  }\n  // Atom element\n  get element () {\n    return this.topology.atomElements[this.index];\n  }\n  // Viewer color representations for this atom according to tis element\n  get elementColor () {\n    const color = elementColors[this.element];\n    if (!color) return 'black';\n    return color;\n  }\n}\n\n// Set a residue handler\nclass Residue {\n  // Constructor expects the topology this residue belongs to and the residue index\n  constructor(topology, residueIndex) {\n    this.topology = topology;\n    this.index = residueIndex;\n  }\n  // Original residue number (source numeration)\n  get number () {\n    return this.topology.residueNumbers[this.index];\n  }\n  // Chain index\n  get chainIndex () {\n    return this.topology.residueChainIndices[this.index];\n  }\n  // Chain name\n  get chainName () {\n    return this.topology.chainNames[this.chainIndex];\n  }\n  // Chain handler\n  get chain () {\n    return this.topology.getChainByIndex(this.chainIndex);\n  }\n  // Insertion code\n  get icode () {\n    if (!this.topology.residueIcodes) return null;\n    return this.topology.residueIcodes[this.index];\n  }\n  // NGL selection of this specific residue\n  get nglSelection () {\n    let selection = `:${this.chainName} and ${this.number}`\n    if (this.icode) selection += ` ^${this.icode}`\n    return selection;\n  }\n  // Residue name\n  get type () {\n    return this.topology.residueNames[this.index];\n  }\n  get name () {\n    return this.type;\n  }\n  // Residue standard letter (e.g. ARG -> R)\n  get letter () {\n    return getResidueTypeLetter(this.type);\n  }\n  // Reference index in the topology\n  get referenceIndex () {\n    if (!this.topology.residueReferenceIndices) return null;\n    return this.topology.residueReferenceIndices[this.index];\n  }\n  // Reference id\n  get referenceId () {\n    const referenceIndex = this.referenceIndex;\n    if (referenceIndex === null) return null;\n    return this.topology.references[referenceIndex];\n  }\n  // Reference type\n  get referenceType () {\n    const referenceIndex = this.referenceIndex;\n    if (referenceIndex === null) return null;\n    return this.topology.referenceTypes[referenceIndex];\n  }\n  // Reference residue number (reference numeration)\n  get referenceNumber () {\n    if (!this.topology.residueReferenceNumbers) return null;\n    return this.topology.residueReferenceNumbers[this.index];\n  }\n  // Reference data\n  get referenceData () {\n    // If this residue has reference id then it belongs to no reference at all\n    if (this.referenceId === null) return null;\n    // Otherwise get the corresponding reference data\n    if (this.referenceType === 'protein') {\n      const reference = this.topology.proteinReferences.find(ref => ref.uniprot === this.referenceId);\n      if (!reference) throw new Error(`Reference id ${this.referenceId} is not found among protein references`);\n      return reference;\n    }\n    if (this.referenceType === 'ligand') {\n      const reference = this.topology.ligandReferences.find(ref => ref.pubchem === this.referenceId);\n      if (!reference) throw new Error(`Reference id ${this.referenceId} is not found among ligand references`);\n      return reference;\n    }\n    throw new Error(`Not supported reference type ${this.referenceType}`);\n  }\n  // Reference name\n  get referenceName () {\n    // If this is a ligand we may have a forced name in metadata\n    const forcedLigandName = this.topology.metadataLigandNames && this.topology.metadataLigandNames[this.referenceId];\n    if (forcedLigandName) return forcedLigandName;\n    // Get reference data\n    const referenceData = this.referenceData;\n    if (!referenceData) return null;\n    // Now return its name\n    return referenceData.name;\n  }\n  // Check if the resiude is in periodic boundary conditions\n  get isPbc () {\n    return this.topology.pbcResidues.has(this.index);\n  }\n  // Standard label for display\n  get standardLabel () {\n    // Add the chain to the label only if there is more than ona chain\n    let labelChain = '';\n    if (this.topology.chainNames.length > 1 ) labelChain = `${this.chainName}:`;\n    // Use the reference numeration if possible\n    // Use the source numeration otherwise\n    const referenceNumber = this.referenceNumber;\n    let labelNumber;\n    if (referenceNumber !== null) labelNumber = `${referenceNumber}`;\n    else labelNumber = `${this.number}*`;\n    // Get the insertion code\n    let labelIcode = this.icode;\n    if (!labelIcode) labelIcode = '';\n    // Get the residue name\n    const labelType = `(${this.type})`;\n    // Finally return the label\n    return labelChain + labelNumber + labelIcode + labelType;\n  }\n  // Atom indices for atoms which belong to this residue\n  get atomIndices () {\n    return this.topology.residueAtomIndices[this.index];\n  }\n  // Number of atoms which belong to this residue\n  get atomCount () {\n    return this.atomIndices.length;\n  }\n  // Check if the residue has an alpha carbon\n  get hasCAlpha () {\n    for (const atom of this.iteratoms())\n      if (atom.name === 'CA') return true;\n    return false;\n  }\n  // Iterate residue atoms\n  * iteratoms () {\n    for (const atomIndex of this.atomIndices) \n      yield this.topology.getAtomByIndex(atomIndex);\n  }\n\n};\n\n// Set a chain handler\nclass Chain {\n  // Constructor expects the chain index\n  constructor(topology, chainIndex) {\n    this.topology = topology;\n    this.index = chainIndex;\n  }\n  // Get the chain name\n  get name () {\n    return this.topology.chainNames[this.index];\n  }\n  get letter () {\n    return this.name;\n  }\n  // Get the metadata chain name\n  get metadataChainName () {\n    const metadataChainNames = this.topology.metadataChainNames;\n    if (!metadataChainNames) return '';\n    // OBSOLETE: Chains were stored as an array of names long time ago\n    if (Array.isArray(metadataChainNames)) return metadataChainNames[this.index] || '';\n    // Chains are stored as and object (e.g. { 'A': 'ACE2', 'B': 'RBD' })\n    else return metadataChainNames[this.name] || '';\n  }\n  // Get residue indcies\n  get residueIndices () {\n    return this.topology.chainResidueIndices[this.index];\n  }\n  // Get residue numbers\n  get residueNumbers () {\n    return this.topology.chainResidueNumbers[this.index];\n  }\n  // Get residue handlers\n  get residues () {\n    return this.residueIndices.map(residueIndex => new Residue(residueIndex));\n  }\n  // Get the residue sequence\n  get sequence () {\n    return this.sequences[this.index];\n  }\n}\n\nexport class Topology {\n  constructor(topology, metadata, references) {\n    // Save the topology data as it comes\n    this.atomNames = topology.atom_names;\n    this.atomElements = topology.atom_elements;\n    this.atomCharges = topology.atom_charges;\n    this.atomResidueIndices = topology.atom_residue_indices;\n    this.residueNames = topology.residue_names;\n    this.residueNumbers = topology.residue_numbers;\n    // Residue icodes have a different structure, since usually there are only a few icodes and not 1 per residue\n    // It is an object where keys are residue indices\n    // It is null when there are not icodes at all in the topology\n    // In order to convert it to the other values format we transform the object into an array\n    // Non assigned indices will become empty strings\n    const icodes = topology.residue_icodes;\n    // In case we have no icodes at all we set the icodes list as an empty string\n    // This is usefull for icode getters that do 'icodes && ...'\n    if (!icodes) this.residueIcodes = '';\n    else {\n      this.residueIcodes = Array(this.residueNames.length).fill('');\n      Object.entries(icodes).forEach(([residueIndex, icode]) => {\n        this.residueIcodes[+residueIndex] = icode;\n      });\n    }\n    this.residueChainIndices = topology.residue_chain_indices;\n    this.chainNames = topology.chain_names;\n    this.references = topology.references;\n    this.referenceTypes = topology.reference_types;\n    // DANI: Esta linea es para mantener las topologías viejas que solo tienen referencias de proteínas\n    if (!this.referenceTypes && this.references) this.referenceTypes = this.references.map(r => 'protein');\n    this.residueReferenceIndices = topology.residue_reference_indices;\n    this.residueReferenceNumbers = topology.residue_reference_numbers;\n    // Save the PBC (Priodic Boundary Conditions) residues\n    this.pbcResidues = topology.pbc_residues && new Set(topology.pbc_residues);\n    // Data is stored in a down-top structure according to atom-residue-chain indices\n    // i.e. atoms know which residue they belong to and residues know which chain they belong to\n    // Now set the top-down structure values\n    // i.e. set which atoms are contained on every residue and which residues are contained on every chain\n    // WARNING: Note that arrays of empty arrays can not be filled as when filled with nulls or empty strings\n    // WARNING: We must fill them with this complicated method or all empty arrays would be the same array\n    this.residueAtomIndices = Array.from(Array(this.residueNames.length), () => []);\n    for (const [atomIndex, residueIndex] of this.atomResidueIndices.entries()) {\n      this.residueAtomIndices[residueIndex].push(atomIndex);\n    }\n    this.chainResidueIndices = Array.from(Array(this.chainNames.length), () => []);\n    for (const [ residueIndex, chainIndex ] of this.residueChainIndices.entries()) {\n      this.chainResidueIndices[chainIndex].push(residueIndex);\n    }\n    this.chainResidueNumbers = this.chainResidueIndices.map(\n      residueIndices => residueIndices.map(residueIndex => this.residueNumbers[residueIndex])\n    );\n    // Get chain sequences by adding all residue letters together for each chain\n    this.sequences = this.chainResidueIndices.map(residueIndices => \n      residueIndices.map(residueIndex => getResidueTypeLetter(this.residueNames[residueIndex])).join('')\n    );\n    // Save metadata chain names\n    // They are not letters ('A', 'B', etc.) but actual names ('Spike', 'Glycans', etc.)\n    this.metadataChainNames = metadata.CHAINNAMES;\n    // Save metadata forced ligand names\n    this.metadataLigandNames = metadata.LIGANDNAMES;\n    // Save the references so we can further return reference data from here\n    this.proteinReferences = references.proteins;\n    this.ligandReferences = references.ligands;\n    this.chainReferences = references.chains;\n    // Assign the chain name and index to every chain reference\n    // Match every chain reference with its chain relying on sequence\n    for (const chainReference of this.chainReferences) {\n      chainReference.chains = [];\n      chainReference.chain_indices = [];\n      for (const [chainIndex, chainName] of Object.entries(this.chainNames)) {\n        // Match sequence\n        const chainSequence = this.sequences[chainIndex];\n        if (chainSequence !== chainReference.sequence) continue;\n        // Once we have a match assign the corresponding name and index\n        chainReference.chains.push(chainName);\n        chainReference.chain_indices.push(+chainIndex);\n      }\n      // If we did not manage to match this chain then log an error\n      if (chainReference.chain_indices.length === 0)\n        console.error('Unmatched chain reference ' + chainReference.sequence);\n    }\n  }\n\n  // --------------------------------------------------------------------\n  // BASICS\n  // --------------------------------------------------------------------\n\n  get atomCount () {\n    return this.atomNames.length;\n  }\n\n  get residueCount () {\n    return this.residueNumbers.length;\n  }\n\n  // --------------------------------------------------------------------\n  // Atom getters\n  // --------------------------------------------------------------------\n\n  getAtomByIndex = atomIndex => {\n    const count = this.atomCount;\n    if (atomIndex >= count) throw new Error(\n      `The atom index ${atomIndex} is out of range. There are ${count} atoms in the topology`,\n    );\n    return new Atom(this, atomIndex);\n  };\n\n  // --------------------------------------------------------------------\n  // Residue getters\n  // --------------------------------------------------------------------\n\n  // Given a residue index, return its handler\n  getResidueByIndex = residueIndex => {\n    const count = this.residueCount;\n    if (residueIndex >= count) throw new Error(\n      `The residue index ${residueIndex} is out of range. There are ${count} residues in the topology`,\n    );\n    return new Residue(this, residueIndex);\n  };\n\n  // Given a residue parameters, find the residue and then return its handler\n  getResidueByParameters = (chainName, number, icode = null) => {\n    // Get the residue chain\n    const chain = this.getChainByName(chainName);\n    // Now iterate residues starting at this index\n    for (const residueIndex of chain.residueIndices) {\n      const residue = new Residue(this, residueIndex);\n      // Check if the residue number matches\n      if (residue.number !== number) continue;\n      // Check if the insertion code matches\n      if (residue.icode !== icode) continue;\n      // If everything matches then return this residue\n      return residue;\n    }\n    // There should always be a match\n    const icode_message = icode ? `icode ${icode}` : `no icode`\n    throw new Error(\n      `Residue with chain ${chainName}, number ${number} and ${icode_message} does not exist`,\n    );\n  };\n\n  // --------------------------------------------------------------------\n  // Chain getters\n  // --------------------------------------------------------------------\n\n  // Given a chain index, return its handler\n  getChainByIndex = chainIndex => {\n    const count = this.chainNames.length;\n    if (chainIndex >= count) throw new Error(\n      `The chain index ${chainIndex} is out of range. There are ${count} chains in the topology`,\n    );\n    return new Chain(this, chainIndex);\n  }\n\n  // Given a chain name, find the chain and return its handler\n  getChainByName = chainName => {\n    const chainIndex = this.chainNames.indexOf(chainName);\n    if (chainIndex === -1)\n      throw new Error(`Chain ${chainName} is not found in the topology`);\n    return new Chain(this, chainIndex);\n  }\n\n  // --------------------------------------------------------------------\n  // OTHER\n  // --------------------------------------------------------------------\n\n  // This function returns residue indices for every residue which belongs to a reference\n  // The reference must be specified with the topology reference id (i.e. uniprot id)\n  // Optionally, you may request only specific residue numbers according to reference numeration\n  // Note that one residue in the reference may be more than once or not be at all in the topology\n  getReferenceResidueIndices = (reference, residueNumbers = null) => {\n    if (!this.references) return;\n    // Get the requested reference index\n    const referenceIndex = this.references.indexOf(reference);\n    if (referenceIndex === -1) return;\n    const residueIndices = [];\n    this.residueReferenceIndices.forEach((refIndex, residueIndex) => {\n      if (refIndex !== referenceIndex) return;\n      // If no residue number were specified then simply return all residue indcies\n      if (residueNumbers === null) return residueIndices.push(residueIndex);\n      // Otherwise we must check\n      const residueNumber = this.residueReferenceNumbers[residueIndex];\n      if (residueNumbers.includes(residueNumber)) residueIndices.push(residueIndex);\n    });\n    return residueIndices;\n  };\n\n  // Set an NGL selection from a list of residue indices\n  // e.g. [0, 1, 2, 3, ...] => nglSelection = \"(A: and 1, 3-5) or (B: and 1)\"\n  // In addition track if there is any small serie (i.e. 3 residues or less)\n  // DANI: Esta función no sería necesaria si se pudiesen hacer selecciones en NGL con índices de residuos\n  // DANI: De hecho no haría falta eliminar residuos duplicados si se pudiesen hacer selecciones en NGL con índices de residuos\n  residueIndices2Ngl = residueIndices => {\n    const rangedSelections = [];\n    let small = false;\n    // Parse each residue in complex notation\n    const parsedResidues = residueIndices.map(residueIndex => this.getResidueByIndex(residueIndex));\n    // Get unique chains\n    const chains = parsedResidues.map(r => r.chainName).filter((v, i, a) => a.indexOf(v) === i);\n    // For each chain, get all residues and \"range\" them\n    chains.forEach(chain => {\n      const chainResidues = parsedResidues.filter(v => v.chainName === chain).map(r => r.number);\n      const { rangedSelection: ranged, small: smallChain } = parsedSelectionRanger(chainResidues);\n      rangedSelections.push(`(:${chain} and (${ranged}))`); // Al parenthesis are mandatory\n      if (smallChain) small = true; // If any chain small is true then the overall small is true\n    });\n    // Join all ranged selections\n    const rangedSelection = rangedSelections.join(' or ');\n    return { rangedSelection, small };\n  };\n\n  // Given a list of residues indices, separate them by chain and return an object where keys are chain names\n  // e.g. [ 1, 2, 3, 17 ] -> { 'A': [1,2,3], 'B': [17] }\n  byChains = residuesIndices => {\n    const chained = {};\n    residuesIndices.forEach(residueIndex => {\n      const chainName = this.getResidueByIndex(residueIndex).chainName;\n      const current = chained[chainName];\n      if (current) current.push(residueIndex);\n      else chained[chainName] = [residueIndex];\n    });\n    return chained;\n  };\n\n  // Get all atom colors according to their elements\n  getAtomElementColors = () => {\n    return this.atomElements.map(element => {\n      const color = elementColors[element];\n      if (!color) return 'black';\n      return color;\n    });\n  };\n}\n","import { useState, useCallback } from 'react';\n\n// useToggleState is a custom hook which returns a state and a custom function to calculate the new state\nconst useToggleState = initialState => {\n  // useState is a React hook which returns a state and a function to change this state respectively\n  // The state is the initialState at the moment it is called\n  const [state, setState] = useState(!!initialState);\n  // useCallback is a React hook which returns a memoize callback\n  const toggleState = useCallback(valueOrSetter => {\n    // Set the state according to the input type\n    switch (typeof valueOrSetter) {\n      // Funtions are accepted and set as state\n      case 'function':\n        setState(valueOrSetter);\n        break;\n      // In case of booleans, numers and strings, a function that returns the opposite in boolean format is returned\n      case 'boolean':\n      case 'number':\n      case 'string':\n        setState(Boolean(valueOrSetter));\n        break;\n      // In other cases, returns a function which just change the state to the opposite of the previours state in boolean format\n      default:\n        setState(state => !state);\n    }\n  }, []);\n\n  return [state, toggleState];\n};\n\nexport default useToggleState;\n"],"names":["WAIT_DELAY","_ref","wait","flag","toggleFlag","useToggleState","useLayoutEffect","timer","setTimeout","clearTimeout","_jsx","title","className","cn","style","children","CircularProgress","variant","color","size","thickness","Project","constructor","projectPayload","_this","_apiEndpoints","topology","interactions","references","fileDescriptors","populations","_apiQuery","fieldname","available","arguments","length","undefined","url","_apiBaseUrl","_apiResponses","payload","query","useAPI","Object","entries","forEach","key","value","this","metadata","mdFrames","SNAPSHOTS","timeLength","FRAMESTEP","mdCount","mds","filter","md","slice","accessionOrId","accession","identifier","accessionAndMdNumber","mdNumber","hasInteractions","analyses","includes","isPopulated","Boolean","files","find","filename","directions","overview","trajectory","genericAnalyses","analysis","LIGANDS","HOST_CONFIG","options","anyReferenceWithEntropies","REFERENCES","ref","REFERENCES_WITH_ENTROPIES","anyReferenceWithEpitopes","REFERENCES_WITH_EPITOPES","METHOD","file","_topologyManager","BASE_PATH_PROJECTS","response","loading","error","Error","message","proteinReferences","useMemo","ref_type","ligandReferences","pdbReferences","chainReferences","topologyManagerReferences","proteins","ligands","chains","Topology","referenceFrame","refframe","ngl","require","rangedSyntax","rangedSelectionParser","selection","units","split","parsedSelection","u","match","matches","exec","rangedUnits","range","push","residueLetters","ALA","ALAN","ALAC","ARG","ARGN","ARGC","ASN","ASNN","ASNC","ASP","ASPN","ASPC","CYS","CYSN","CYSC","CYH","CSH","CSS","CYX","CYP","GLN","GLNN","GLNC","GLU","GLUN","GLUC","GLY","GLYN","GLYC","HIS","HISN","HISC","HID","HIE","HIP","HSD","HSE","ILE","ILEN","ILEC","ILU","LEU","LEUN","LEUC","LYS","LYSN","LYSC","MET","METN","METC","PHE","PHEN","PHEC","PRO","PRON","PROC","PRØ","PR0","PRZ","SER","SERN","SERC","THR","THRN","THRC","TRP","TRPN","TRPC","TRY","TYR","TYRN","TYRC","VAL","VALN","VALC","A","A3","A5","C","C3","C5","T","T3","T5","G","G3","G5","U","U3","U5","DA","DT","DC","DG","getResidueTypeLetter","residueType","letter","nglSelection2residueIndices","nglSelection","onlyCartoonSupported","viewerTopology","residueIndices","Selection","view","getView","eachResidue","residue","nglResidue","isProtein","isRna","isDna","index","nglSelectionExists","atomCount","elementColors","H","N","O","S","P","Atom","atomIndex","name","atomNames","residueIndex","atomResidueIndices","getResidueByIndex","element","atomElements","elementColor","Residue","number","residueNumbers","chainIndex","residueChainIndices","chainName","chainNames","chain","getChainByIndex","icode","residueIcodes","type","residueNames","referenceIndex","residueReferenceIndices","referenceId","referenceType","referenceTypes","referenceNumber","residueReferenceNumbers","referenceData","reference","uniprot","pubchem","referenceName","forcedLigandName","metadataLigandNames","isPbc","pbcResidues","has","standardLabel","labelChain","labelNumber","labelIcode","atomIndices","residueAtomIndices","hasCAlpha","atom","iteratoms","getAtomByIndex","Chain","metadataChainName","metadataChainNames","Array","isArray","chainResidueIndices","chainResidueNumbers","residues","map","sequence","sequences","count","residueCount","getResidueByParameters","getChainByName","indexOf","getReferenceResidueIndices","refIndex","residueNumber","residueIndices2Ngl","rangedSelections","small","parsedResidues","r","v","i","a","chainResidues","rangedSelection","ranged","smallChain","separator","minimumSerieLength","Number","POSITIVE_INFINITY","sort","b","selectionLength","toString","num","j","nextNum","Math","min","substring","parsedSelectionRanger","join","byChains","residuesIndices","chained","current","getAtomElementColors","atom_names","atom_elements","atomCharges","atom_charges","atom_residue_indices","residue_names","residue_numbers","icodes","residue_icodes","fill","residue_chain_indices","chain_names","reference_types","residue_reference_indices","residue_reference_numbers","pbc_residues","Set","from","CHAINNAMES","LIGANDNAMES","chainReference","chain_indices","console","initialState","state","setState","useState","toggleState","useCallback","valueOrSetter"],"sourceRoot":""}