{"version":3,"file":"static/js/126.1e60fc63.chunk.js","mappings":"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","sources":["pages/accession/clusters/index.js","webpack://mdposit/./src/components/animated-card/style.module.css?d4d9","components/animated-card/index.js","webpack://mdposit/./src/components/viewer-spawner/style.module.css?df6e","components/viewer-spawner/index.js","webpack://mdposit/./src/components/selector/style.module.css?71ed","components/selector/index.js","webpack://mdposit/./src/pages/accession/clusters/style.module.css?66ae","utils/version/index.js"],"sourcesContent":["import React, { lazy, useContext, useState, useMemo, useCallback, useRef, useEffect } from 'react';\n// CSS style\nimport style from './style.module.css';\n// Hooks to request the API\nimport useAPI from '../../../hooks/use-api';\nimport useBatchAPI from '../../../hooks/use-batch-api';\n// Project context\nimport { ProjectCtx } from '../../../contexts';\n// Constants\nimport { BASE_PATH_PROJECTS } from '../../../utils/constants';\n// Visual assets\nimport { CardContent, Slider, Typography } from '@mui/material';\nimport Card from '../../../components/animated-card';\nimport Loading from '../../../components/loading';\n// Analysis selector\nimport Selector from '../../../components/selector';\n// Viewer pop-up windows\nimport ViewerSpawner from '../../../components/viewer-spawner';\nimport Version from 'src/utils/version';\n\nconst MarkovGraph = lazy(() =>\n  import(/* webpackChunkName: 'graph-msm' */ '../../../components/graph-msm'),\n);\n\n// Set the maximum number of nodes\n// Note that the hard limit of nodes is the number of values in data (now 20)\nconst defaultNodeNumber = 14;\n// Set the maximum number of nodes\n// Note that the hard limit of links is the possible combinations of pairs of nodes\nconst defaultLinksNumber = 20;\n\n// Set the maximum node area in the graph, which is the area of the node with the highest population\n// Note that the rest of node areas are proportional, so there is no need to set the minimum node area\nconst maxNodeArea = 10000;\n// Set the maximum and minimum link widths in the graph\n// Note that both are to be defined since width values are interpolated\nconst maxLinkWidth = 10;\nconst minLinkWidth = 1;\n\nconst Clusters = () => {\n\n  // Get the current project metadata\n  const { accessionAndMdNumber, files } = useContext(ProjectCtx);\n\n  // Set when one point in the graph is selected\n  const [selectedFrame, setSelectedFrame] = useState(null);\n\n  // Set the number of nodes to be displayed\n  const [nodesLimit, setNodesLimit] = useState(defaultNodeNumber);\n\n  // Set the number of nodes to be displayed\n  const [linksLimit, setLinksLimit] = useState(defaultLinksNumber);\n\n  // Set the selected clusters analysis\n  // By default we will set the overall structure, which should be always found\n  const [selectedAnalysis, setSelectedAnalysis] = useState('Overall');\n\n  // Request a summary of the available clusters analyses to the API\n  const clustersSummary = useAPI(`${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/analyses/clusters`);\n  // Memoize the available analyses for the selector\n  const availableAnalyses = useMemo(() => clustersSummary && clustersSummary.payload &&\n    clustersSummary.payload.map(analysis => analysis.name), [clustersSummary]);\n\n  // Find the selected analysis name\n  const selectedAnalysisName = useMemo(() => {\n    // Wait until we have the clusters summary available\n    if (!clustersSummary.payload) return;\n    // Find the name of the selected analysis according to the summary\n    const analysis = clustersSummary.payload.find(analysis => analysis.name === selectedAnalysis);\n    if (!analysis) throw new Error(`Analysis ${selectedAnalysis} is not found in the summary`);\n    // Finally return the analysis name\n    return analysis.analysis;\n  }, [selectedAnalysis, clustersSummary.payload]);\n\n  // Request the selected analysis data to the API\n  const selectedAnalysisURL = selectedAnalysisName\n  ? `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/analyses/${selectedAnalysisName}`\n  : null;\n  const clustersAnalysis = useAPI(selectedAnalysisURL);\n\n  // Conserve a backed up cluster data\n  // If the current analysis is changed keep the old results as we wait for the new payload\n  // Thus all already rendered elements can use old data and the rerender is way more smooth\n  // IMPORTANT: Payload values are used widely among rendered components\n  // IMPORTANT: For this reason there is no render if there is no payload\n  // IMPORTANT: If this is not done there is a brief render which displays nothing\n  // IMPORTANT: Then the data update looks almost like a refresh\n  const clustersDataRef = useRef(clustersAnalysis.payload);\n  // Save cluster data only when the payload available\n  useMemo(() => {\n    // If the payload is ready then set it as the reference\n    if (!clustersAnalysis.payload) return;\n    clustersDataRef.current = clustersAnalysis.payload;\n  }, [clustersAnalysis.payload]);\n  // Get the current reference value\n  const clustersData = clustersDataRef.current;\n\n  // Download all cluster screenshots\n  // First set the URLs for the API\n  const screenshotsUrls = useMemo(() => {\n    // Wait until we know the selected analysis name\n    if (!selectedAnalysisName) return [];\n    // Find screenshot filenamese\n    const selectedAnalysisFilename = selectedAnalysisName.replace('-', '_');\n    const screenshotHeaderNames = `${selectedAnalysisFilename}_screenshot_`;\n    // WARNING: The sort may seem redundant, but if there was any reupload then images may be disordered\n    const screenshotFilenames = files.filter(filename => filename.includes(screenshotHeaderNames)).sort();\n    // Sort them according to their numeration so they match\n    return screenshotFilenames.map(\n      filename => `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/files/${filename}`\n    );\n  }, [files, selectedAnalysisName]);\n\n  // Now perform the API calls\n  const screenshotsResponses = useBatchAPI(screenshotsUrls);\n  const screenshotLoading = screenshotsResponses.some(response => response.loading);\n\n  // Conserve backed up screenshots\n  // Same reason as explained above in clustersDataRef\n  const screenshotsRef = useRef(null);\n  // Parse and save the screenshot images\n  useMemo(() => {\n    if (screenshotLoading) return;\n    screenshotsRef.current = screenshotsResponses.map(response => {\n      if (!response) return null;\n      if (!response.payload) return null;\n      return 'data:image/png;base64,' + Buffer.from(response.payload, 'binary').toString('base64');\n    });\n  }, [screenshotsResponses, screenshotLoading]);\n  // Get the current reference screenshots\n  const screenshots = screenshotsRef.current;\n\n  // Set the nodes and links to be represented in the Markov graph\n  // For every node, set its area according to its population value and then calculate its radius\n  // For every link, set is thickness according to the RMSD between the two frames it is connecting\n  const { graphData, availableLinks, clusterIndices, version, step } = useMemo(() => {\n    if (!clustersData) return {};\n    // Add the index to every cluster in the original data\n    // This allos us to sorth them without loosing track of cluster indices, which are used in transitions\n    clustersData.clusters.forEach((cluster, i) => { cluster.index = i });\n    // Sort clusters by number of frames\n    // Set a new list to avoid mutating the original\n    const nodeSortingFunction = (clusterA, clusterB) => clusterB.frames.length - clusterA.frames.length;\n    const sortedClusters = [ ...clustersData.clusters ].sort(nodeSortingFunction);\n    // Get as many clusters as the nodes limit starting by the most populated\n    const filteredClusters = sortedClusters.slice(0, nodesLimit);\n    // Mine data from the sorted clusters\n    const mainFrames = filteredClusters.map(cluster => cluster.main)\n    const totalFrames = filteredClusters.reduce((acc, curr) => acc + curr.frames.length, 0);\n    const populations = filteredClusters.map(cluster => cluster.frames.length / totalFrames);\n    const clusterIndices = filteredClusters.map(cluster => cluster.index);\n    // Set the populations cutoff according to the maximum populations value to remove nodes\n    const maximumPopulation = populations[0];\n    // Set nodes: objects containing both the frame and the population\n    const nodes = [];\n    populations.forEach((population, i) => {\n      // Set the area of the current node\n      const area = population * maxNodeArea / maximumPopulation;\n      // Calculate the radius from the area\n      const radius = Math.sqrt(area / Math.PI);\n      // Set the node and add it to the list\n      const node = {\n        id: i,\n        radius: radius,\n        value: mainFrames[i],\n        // Set the text to be displayed as a tooltip when the node is hovered\n        // Populations is a percent in a 0 to 1 format, so we multipley by an extra 100 to get the actual percent\n        text: `Population: ${Math.round(population * 10000) / 100} %\\nFrame: ${mainFrames[i]}`,\n      };\n      nodes.push(node);\n    });\n    // Set the transitions between clusters as the links\n    const links = [];\n    // Find transitions between available nodes\n    const availableTransitions = clustersData.transitions.filter(\n      transition => clusterIndices.includes(transition.from) && clusterIndices.includes(transition.to));\n    // Save the number of available links with the given available nodes\n    const availableLinks = availableTransitions.length;\n    // Sort transitions depending on their counts\n    const transitionSortingFunction = (transitionA, transitionB) => transitionB.count - transitionA.count;\n    const sortedTransitions = availableTransitions.sort(transitionSortingFunction);\n    // Find the maximum and minimum transition counts\n    const allCounts = sortedTransitions.map(transition => transition.count);\n    const maxCount = allCounts[0];\n    const minCount = allCounts[allCounts.length - 1];\n    // Calculate the normalizer for the interpolation process\n    const normalizer = maxCount === minCount\n      ? 1 // If there is only one possible width then set it to the maximum width\n      : (maxLinkWidth - minLinkWidth) / (minCount - maxCount);\n    // Process as many links as requested by the user\n    // Note that, with the current implementation, transitions between  pairs of nodes are merged\n    // So we may have less links than transitions\n    sortedTransitions.forEach((transition, i) => {\n      if (i >= linksLimit) return;\n      // Translate cluster indices to node indices\n      const source = clusterIndices.indexOf(transition.from);\n      if (source === -1) throw new Error('Not found source cluster index');\n      const target = clusterIndices.indexOf(transition.to);\n      if (target === -1) throw new Error('Not found target cluster index');\n      // Set the width from the number of transitions count\n      // Interpolate the current transitions count to obtain the corresponding width\n      const width = maxLinkWidth - (transition.count - maxCount) * normalizer;\n      // Check if we already have the opposite link\n      const oppositeLink = links.find(link => link.source === target && link.target === source);\n      // If so, merge their width\n      if (oppositeLink) {\n        // DANI: Esto es muy cutre y rompe incluso la interpolación, pero al ser temporal no merece la pena hacerlo mejor\n        oppositeLink.width += width;\n      }\n      // Otherwise create new link\n      else {\n        const link = { source: source, target: target, width: width };\n        links.push(link);\n      }\n    });\n    // Mine also the step and analysis version from the cluster data\n    const version = new Version(clustersData.version);\n    const step = clustersData.step;\n    // Return both nodes and links inside an object\n    const graphData = { nodes: nodes, links: links };\n    return { graphData, availableLinks, clusterIndices, version, step };\n  }, [clustersData, nodesLimit, linksLimit]);\n\n  // Set the displayed screenshots in the right order\n  const displayedScreenshots = useMemo(() => {\n    if (!clusterIndices || !screenshots) return;\n    return clusterIndices.map(index => screenshots[index]);\n  }, [clusterIndices, screenshots]);\n\n  const handleNodeSelect = useCallback(node => {\n    // DANI: En las primeras versiones de este análisis la frame de los nodos están mal\n    // DANI: Es la frame de la trayectoria reducida, no de la completa\n    // DANI: De manera que se arregla multiplicandola por el step\n    const newFrame = version.equals('0.0') ? node.value * step : node.value;\n    setSelectedFrame(newFrame);\n  }, [setSelectedFrame, version, step]);\n\n  // Render loading or error messages according with the API response as we wait for data\n  if (!clustersData) {\n    if (clustersAnalysis.loading) return <Loading />;\n    if (clustersAnalysis.error) return clustersAnalysis.error.toString();\n    return 'Something bad happened';\n  }\n\n  // Render loading message according to screenshot downloads\n  if (!displayedScreenshots) return <Loading />;\n\n  return (\n    <>\n      <Card className={style['vertical-margin']}>\n        <Selector\n          label={'Clusters analysis'}\n          options={availableAnalyses}\n          selection={selectedAnalysis}\n          setter={setSelectedAnalysis}\n        />\n      </Card>\n      <Card>\n        <div className={clustersAnalysis.loading ? style.disabled : style.enabled}>\n          <MarkovGraph\n            data={graphData}\n            images={displayedScreenshots}\n            selectedNodeValue={selectedFrame}\n            onSelectNode={handleNodeSelect}\n            className={style.graph}\n          />\n          <CardContent>\n            <div className={style.horizontal}>\n              <Typography variant=\"h7\" className={style.wide25}>{'Number of nodes: '}</Typography>\n              <Slider\n                title=\"Change number of nodes\"\n                value={nodesLimit}\n                aria-labelledby=\"continuous-slider\"\n                onChange={(_, value) => { setNodesLimit(value) }}\n                min={2}\n                max={clustersData.clusters.length}\n                valueLabelDisplay=\"auto\"\n                className={style.wide75}\n              />\n            </div>\n            <div className={style.horizontal}>\n              <Typography variant=\"h7\" className={style.wide25}>{'Number of links: '}</Typography>\n              <Slider\n                title=\"Change the RMSD cutoff\"\n                value={linksLimit}\n                aria-labelledby=\"continuous-slider\"\n                onChange={(_, value) => { setLinksLimit(value) }}\n                min={0}\n                max={availableLinks}\n                valueLabelDisplay=\"auto\"\n                className={style.wide75}\n              />\n            </div>\n          </CardContent>\n        </div>\n      </Card>\n      <ViewerSpawner\n        // Set the new viewer or null if there is not a proper \"selected\" value\n        newViewer={selectedFrame\n          ? { requestedFrame: selectedFrame }\n          : null\n        }\n        // If the nailed/closed viewer is the current viewer then reset the 'selected'\n        onNail={viewer =>\n          setSelectedFrame(previous => {\n            if (viewer.requestedFrame === previous) return null;\n            else return previous;\n          })\n        }\n        onClose={viewer =>\n          setSelectedFrame(previous => {\n            if (viewer.requestedFrame === previous) return null;\n            else return previous;\n          })\n        }\n      />\n    </>\n  );\n};\n\nexport default Clusters;\n","// extracted by mini-css-extract-plugin\nexport default {\"container\":\"style_container__M9GCG\"};","import React, { useLayoutEffect, useRef, forwardRef } from 'react';\nimport { Card } from '@mui/material';\n\nimport reducedMotion from '../../utils/reduced-motion';\n\nimport style from './style.module.css';\n\nconst KEYFRAMES = { opacity: [0, 1] };\n\nif (!reducedMotion()) {\n  KEYFRAMES.transform = ['translateY(50px)', 'translateY(0)'];\n}\n\nconst ANIMATION_OPTIONS = {\n  fill: 'both',\n  easing: 'cubic-bezier(0, .99, .56, 1.1)',\n  duration: 500,\n};\n\n// Make the card appear and slide softly from down to up when the page is loaded\nconst AnimatedCard = forwardRef(({ overrideComponent, ...props }, ref) => {\n  const containerRef = useRef(null);\n\n  useLayoutEffect(() => {\n    const node = containerRef.current && containerRef.current.firstElementChild;\n    if (!(node && node.animate)) return;\n\n    const index = Array.from(\n      document.querySelectorAll('main section'),\n    ).findIndex(section => node === section);\n\n    const animation = node.animate(KEYFRAMES, {\n      ...ANIMATION_OPTIONS,\n      delay: index * 150,\n    });\n\n    return () => animation.cancel();\n  }, []);\n\n  const Component = overrideComponent ? 'section' : Card;\n\n  return (\n    <div ref={containerRef} className={style.container}>\n      <Component component=\"section\" {...props} ref={ref} />\n    </div>\n  );\n});\n\nexport default AnimatedCard;\n","// extracted by mini-css-extract-plugin\nexport default {\"rnd\":\"style_rnd__Txifm\",\"floating-card\":\"style_floating-card__HHpby\"};","import React, { lazy, Suspense, useRef, useState } from 'react';\n\n// Rnd is the resizable and draggable system where the ngl viewer is placed\nimport { Rnd } from 'react-rnd';\n\nimport Card from '../animated-card';\n\nimport style from './style.module.css';\n\nconst ViewerWithControls = lazy(() =>\n  import(\n    /* webpackChunkName: 'viewer-with-controls' */ '../viewer-with-controls'\n  ),\n);\n\n// Minimal ngl window height\nconst MIN_NGL_DIMENSION = 150;\n\n// Counter to get always the maximum zIndex\n// This is useful to set a new or currently dragged/resized ngl window over the others\nlet maxZ = 0;\nconst nextZ = () => {\n  maxZ += 1;\n  return maxZ;\n};\n\n// This function spawns all the NGL viewers needed\n// i.e. one viewer with the requested 'props' and all previous viewers which have been nailed\nconst ViewerSpawner = ({ newViewer, nailing = true, onNail, onClose }) => {\n  // Store here all nailed NGL viewers\n  const [nailedViewers, setNailedViewers] = useState([]);\n\n  // Set the viewers as the nailed viewers and the new viewer\n  const viewers = [...nailedViewers];\n\n  // Keep listed all arrays which have been used (i.e. ngl viewers which have been nailed or closed)\n  const usedIds = useRef([]);\n\n  if (newViewer) {\n    // Find a new suitable Id that meet 2 conditions:\n    // - There is never 2 viewers with the same id, so we avoid errors\n    // - If we pick diferent frames in the graph without nailing anything, the current viewer has always the same id\n    // (This way the current viewer does not appear in the origin position every time)\n    const getNewId = () => {\n      let id = 0;\n      while (id < 999) {\n        if (usedIds.current.indexOf(id) === -1) return id;\n        id += 1;\n      }\n      console.error('Maximum number of viewers reached');\n    };\n\n    // Set a unique id for this props based in the last nailed viewer\n    newViewer.id = getNewId();\n    newViewer.close = () => {\n      if (nailing) {\n        setNailedViewers(nailed => {\n          const newNailed = [...nailed];\n          const index = nailed.indexOf(newViewer);\n          if (index !== -1) newNailed.splice(index, 1);\n          return newNailed;\n        });\n      }\n      if (onClose) onClose(newViewer);\n      usedIds.current.push(newViewer.id);\n    };\n    // If the nailer function is passed, add the logic for the viewer to be nailed further\n    if (nailing)\n      newViewer.nail = () => {\n        setNailedViewers(nailed => [...nailed, newViewer]);\n        if (onNail) onNail(newViewer);\n        usedIds.current.push(newViewer.id);\n      };\n    // Add the current viewer to the viewers list\n    viewers.push(newViewer);\n  }\n\n  // Render a viewer for each prop. Use the 'selected' parameter as unique id\n  return viewers.map(viewer => <NGLViewerInDND key={viewer.id} {...viewer} />);\n};\n\n// This component render a small NGL viewer\n// It is called when user clicks in a point in the projections component\n// Also it is called by the generic analysis page\nconst NGLViewerInDND = props => {\n  // Set a reference for the viewer\n  // If a reference is passed among the viewer arguments then use it instead\n  const viewerRef = props.viewerRef || useRef(null);\n\n  // Set the default position and size\n  const [place, setPlace] = useState(() => {\n    // Set an extra margin\n    const MARGIN = 20;\n    // Get the screen pixel sizes and vertical scroll position\n    const { innerWidth, innerHeight, scrollY } = window;\n    // The spawned elements are parented to the 'main' element, not to the 'body'\n    // We have to take this in count, since the header adds an extra offset in vertical position\n    const offsetHeight = document.querySelector('main').offsetTop;\n    // Set a reasonable dimension for the ngl window\n    const dimension = Math.max(\n      Math.min(innerWidth / 4, innerHeight / 4),\n      MIN_NGL_DIMENSION,\n    );\n    const reasonableHeight = 1.5 * dimension;\n    const reasonableWidth = 2 * dimension;\n    return {\n      // WARNING: If you set the width as 'auto' the window stays very wide when exiting fullscreen\n      width: reasonableWidth, // Let the Rnd logic set the width automatically\n      height: reasonableHeight, // Reasonable height\n      x: 0, // Left border\n      y: innerHeight - offsetHeight - reasonableHeight - MARGIN + scrollY, // Bottom border\n    };\n  });\n\n  return (\n    // Rnd is the draggable and resizable system where the ngl viewer is placed\n    <Rnd\n      position={{ x: place.x, y: place.y }}\n      size={{ width: place.width, height: place.height }}\n      // Update the zIndex to make this window the first visible\n      style={{ zIndex: nextZ() }}\n      className={style.rnd}\n      data-rnd\n      // Limits where the window can be dragged/resized to\n      // WARNING: bounds=\"main\" is problematic since the window may appear out of bounds\n      // WARNING: Then when it is moved for the first time it jumps inside the bonds, not elegant\n      bounds=\"window\"\n      // Prevent the mouse to drag/resize the window when it is over specific elements\n      cancel=\"canvas, [data-popover], #preventDragSize, .prevent-drag\"\n      // On drag/resize starts we do not change anything, but use the hook to re-render this component\n      // The Z Index is updated and the selected window becomes the first in the z axis automatically\n      // WARNING: Drag functions are also called when you just click (e.g. clicking buttons)\n      onDragStart={() => {\n        setPlace({ ...place });\n      }}\n      onResizeStart={() => {\n        setPlace({ ...place });\n      }}\n      onDragStop={(e, d) => {\n        // Use this to reject some bugged event calls: e.g. the frames number selector\n        if (e.layerX === 0 && e.layerY === 0) return;\n        // We re-render only if the new position does not equal the old position\n        if (place.x !== d.x || place.y !== d.y)\n          setPlace({\n            ...place,\n            x: d.x,\n            y: d.y,\n          });\n      }}\n      // Re-adapt the viewer and update the position/size when the window is resized\n      onResize={() => viewerRef.current && viewerRef.current.autoResize()}\n      onResizeStop={(e, direction, ref, delta, position) => {\n        setPlace({\n          width: ref.style.width,\n          height: ref.style.height,\n          ...position,\n        });\n        // if (!viewerRef.current) return;\n        // viewerRef.current.autoResize();\n        // viewerRef.current.autoResize.flush();\n      }}\n    >\n      <Card className={style['floating-card']} elevation={4}>\n        <Suspense fallback={null}>\n          <ViewerWithControls\n            className={style['floating-card']}\n            ref={viewerRef}\n            startsPlaying={false}\n            {...props}\n          />\n        </Suspense>\n      </Card>\n    </Rnd>\n  );\n};\n\nexport default ViewerSpawner;\n","// extracted by mini-css-extract-plugin\nexport default {\"content\":\"style_content__eXhNP\",\"horizontal-margined\":\"style_horizontal-margined__w4tJp\"};","import React from 'react';\n\nimport { Card, CardContent, MenuItem, Select, Typography } from '@mui/material';\n\nimport style from './style.module.css';\n\nconst Selector = ({ label, options, selection, setter, disabled }) => {\n  // Make sure we have the mandatory parameters\n  if (!options) return 'Missing options argument';\n  if (!selection) return 'Missing selection argument';\n  if (!setter) return 'Missing setter argument';\n  // Handle when interactions change\n  const changeSelection = event => { setter(event.target.value) };\n  // Render the component\n  return (\n    <CardContent className={style.content}>\n      {label && (\n        <Typography variant=\"h5\">\n          {label}\n        </Typography>\n      )}\n      <Select\n        value={selection}\n        onChange={changeSelection}\n        className={style['horizontal-margined']}\n        disabled={disabled}\n      >\n        {options.map((option, i) => (\n          <MenuItem key={i} value={option}>\n            {option}\n          </MenuItem>\n        ))}\n      </Select>\n    </CardContent>\n  );\n};\n\nexport default Selector;\n","// extracted by mini-css-extract-plugin\nexport default {\"graph\":\"style_graph__Q1ja5\",\"horizontal\":\"style_horizontal__makgF\",\"wide25\":\"style_wide25__KqdCT\",\"wide75\":\"style_wide75__p0NKz\",\"enabled\":\"style_enabled__ndc27\",\"disabled\":\"style_disabled__s5ohr\",\"vertical-margin\":\"style_vertical-margin__5aQXR\"};","// Set a class to handle version comparisions\nclass Version {\n    constructor (versionString) {\n        // If there is no version then consider it the 0.0.0\n        if (versionString === undefined) versionString = '0.0.0';\n        // Get the major, minor and patch versions\n        const splits = versionString.split('.');\n        this.major = splits[0] && +splits[0];\n        if (this.major > 999)\n            throw new Error('Major version is greater than 999 and this is not allowed');\n        this.minor = splits[1] && +splits[1];\n        if (this.minor > 999)\n            throw new Error('Minor version is greater than 999 and this is not allowed');\n        this.patch = splits[2] && +splits[2];\n        if (this.patch > 999)\n            throw new Error('Patch version is greater than 999 and this is not allowed');\n    }\n\n    // Get the version back in string format\n    // This has also an effect in the console-log display\n    toString () {\n        let string = this.major.toString();\n        if (this.minor === undefined) return string;\n        string += '.' + this.minor.toString();\n        if (this.patch === undefined) return string;\n        string += '.' + this.patch.toString();\n        return string;\n    }\n\n    // Check if two versions are equal\n    equals (other) {\n        // If this is a string instead of a version the parse it\n        if (typeof other === 'string') return this.equals(new Version(other));\n        // Check if versions are equal for all major, minor and patch versions\n        // If other version has not explicit patch or minor version then they are not compared\n        if (other.major !== this.major) return false;\n        if (other.minor !== undefined && other.minor !== this.minor) return false;\n        if (other.patch !== undefined && other.patch !== this.patch) return false;\n        return true;\n    }\n}\n\n// This allows version comparision in the classic JS notation\n// e.g. version1 >= version2\nVersion.prototype.valueOf = function() {\n    // Make sure the value will make version values coherent\n    // Note that the every version value is limited to 999 to make this function safe\n    return this.major * 1000000 + (this.minor || 0) * 1000 + (this.patch || 0);\n};\n\nexport default Version;"],"names":["MarkovGraph","lazy","Clusters","accessionAndMdNumber","files","useContext","ProjectCtx","selectedFrame","setSelectedFrame","useState","nodesLimit","setNodesLimit","linksLimit","setLinksLimit","selectedAnalysis","setSelectedAnalysis","clustersSummary","useAPI","concat","BASE_PATH_PROJECTS","availableAnalyses","useMemo","payload","map","analysis","name","selectedAnalysisName","find","Error","selectedAnalysisURL","clustersAnalysis","clustersDataRef","useRef","current","clustersData","screenshotsUrls","selectedAnalysisFilename","replace","screenshotHeaderNames","filter","filename","includes","sort","screenshotsResponses","useBatchAPI","screenshotLoading","some","response","loading","screenshotsRef","Buffer","from","toString","screenshots","graphData","availableLinks","clusterIndices","version","step","clusters","forEach","cluster","i","index","filteredClusters","nodeSortingFunction","clusterA","clusterB","frames","length","slice","mainFrames","main","totalFrames","reduce","acc","curr","populations","maximumPopulation","nodes","population","area","node","id","radius","Math","sqrt","PI","value","text","round","push","links","availableTransitions","transitions","transition","to","sortedTransitions","transitionSortingFunction","transitionA","transitionB","count","allCounts","maxCount","minCount","normalizer","source","indexOf","target","width","oppositeLink","link","Version","displayedScreenshots","handleNodeSelect","useCallback","newFrame","equals","_jsxs","_Fragment","children","_jsx","Card","className","style","Selector","label","options","selection","setter","disabled","enabled","data","images","selectedNodeValue","onSelectNode","graph","CardContent","horizontal","Typography","variant","wide25","Slider","title","onChange","_","min","max","valueLabelDisplay","wide75","ViewerSpawner","newViewer","requestedFrame","onNail","viewer","previous","onClose","Loading","error","KEYFRAMES","opacity","reducedMotion","transform","ANIMATION_OPTIONS","fill","easing","duration","forwardRef","_ref","ref","overrideComponent","props","_objectWithoutProperties","_excluded","containerRef","useLayoutEffect","firstElementChild","animate","Array","document","querySelectorAll","findIndex","section","animation","_objectSpread","delay","cancel","Component","component","ViewerWithControls","maxZ","NGLViewerInDND","viewerRef","place","setPlace","innerWidth","innerHeight","scrollY","window","offsetHeight","querySelector","offsetTop","dimension","reasonableHeight","height","x","y","Rnd","position","size","zIndex","bounds","onDragStart","onResizeStart","onDragStop","e","d","layerX","layerY","onResize","autoResize","onResizeStop","direction","delta","elevation","Suspense","fallback","startsPlaying","nailing","nailedViewers","setNailedViewers","viewers","usedIds","getNewId","console","close","nailed","newNailed","splice","nail","Select","event","option","MenuItem","constructor","versionString","undefined","splits","split","this","major","minor","patch","string","other","prototype","valueOf"],"sourceRoot":""}