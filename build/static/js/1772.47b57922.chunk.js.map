{"version":3,"file":"static/js/1772.47b57922.chunk.js","mappings":"yJACA,QAA4B,yB,eCM5B,MAAMA,EAAY,CAAEC,QAAS,CAAC,EAAG,KAE5BC,EAAAA,EAAAA,OACHF,EAAUG,UAAY,CAAC,mBAAoB,kBAG7C,MAAMC,EAAoB,CACxBC,KAAM,OACNC,OAAQ,iCACRC,SAAU,KAgCZ,GA5BqBC,EAAAA,EAAAA,aAAW,CAAAC,EAAkCC,KAAS,IAA1C,kBAAEC,KAAsBC,GAAOH,EAC9D,MAAMI,GAAeC,EAAAA,EAAAA,QAAO,OAE5BC,EAAAA,EAAAA,kBAAgB,KACd,MAAMC,EAAOH,EAAaI,SAAWJ,EAAaI,QAAQC,kBAC1D,IAAMF,IAAQA,EAAKG,QAAU,OAE7B,MAAMC,EAAQC,MAAMC,KAClBC,SAASC,iBAAiB,iBAC1BC,WAAUC,GAAWV,IAASU,IAE1BC,EAAYX,EAAKG,QAAQnB,EAAW,IACrCI,EACHwB,MAAe,IAARR,IAGT,MAAO,IAAMO,EAAUE,QAAQ,GAC9B,IAEH,MAAMC,EAAYnB,EAAoB,UAAYoB,EAAAA,EAElD,OACEC,EAAAA,EAAAA,KAAA,OAAKtB,IAAKG,EAAcoB,UAAWC,EAAgBC,UACjDH,EAAAA,EAAAA,KAACF,EAAS,CAACM,UAAU,aAAcxB,EAAOF,IAAKA,KAC3C,G,6DC3CV,QAA6B,0BAA7B,EAAkE,wBAAlE,EAA+G,kCAA/G,EAAoK,gC,0BCQpK,MAgEA,EAhEoBD,IAcb,IAdc,MAEnB4B,EAAQ,GAAE,SAEVC,EAAW,EAAC,SACZC,EAAW,EAAC,UAEZC,EAAS,OAETC,EAAS,GAAE,SAEXC,GAAW,EAAK,UAEhBT,GACDxB,EAEC,MAAM,WAAEkC,EAAU,aAAEC,IAAiBC,EAAAA,EAAAA,UAAQ,KAG3C,MAAMC,EAAS,GAEf,GAAIP,IAAaD,EAAUQ,EAAOC,KAAKR,QAGlC,IAAK,IAAIS,EAAIT,EAAUS,GAAKV,EAAUU,IAAMV,EAAWC,GAAYE,EACtEK,EAAOC,KAAKC,GAGd,IAAIJ,EAAeE,EAAOG,KAAIC,GAAOC,KAAKC,MAAMF,KAGhD,GAAIN,EAAaS,OAAS,EAExB,IAAK,IAAIC,EAAU,EAAG,IAAIC,IAAIX,GAAcY,KAAOZ,EAAaS,OAAQC,IACtEV,EAAeE,EAAOG,KAAIC,GAAOC,KAAKC,MAAMF,EAAM,IAAMI,GAAW,IAAMA,IAK7E,MAAO,CAAEX,WADUD,EAAWI,EAAOG,KAAIQ,GAAK,CAACA,KAAM,CAACX,GACjCF,eAAc,GAClC,CAACN,EAAUC,EAAUE,EAAQC,IAGhC,OACEgB,EAAAA,EAAAA,MAACC,EAAAA,EAAW,CACV1B,UACEA,IAAwBS,EAAWR,EAAiBA,GACrDC,SAAA,CAEAE,GACDL,EAAAA,EAAAA,KAAC4B,EAAAA,EAAa,CACZC,KAAMlB,EACNmB,YAAapB,EAAW,CAAC,IAAME,EAC/BmB,YAAarB,EAAWE,EAAe,CAAC,IACxCJ,UAAWA,EACXwB,oBAAoB,EACpB/B,UACES,EAAWR,EAA4BA,MAG/B,C,8FC5DlB,MAAM+B,EAAgB,yBAEhBC,EAAe,yBAwYrB,GAjYsBC,EAAAA,EAAAA,OACpB1D,IAcO,IAdN,KACCoD,EAAI,YACJC,EAAc,GAAE,YAChBC,EAAc,GAAE,WAChBK,EAAU,WACVC,EAAU,gBACVC,EAAkB,EAAC,UACnB9B,EAAY,CAAC,MAAO,QAAS,QAAO,WACpC+B,EAAU,UACVC,EAAS,QACTC,EAAO,mBACPT,GAAqB,EAAI,OACzBU,EAAS,CAAEC,IAAK,GAAIC,MAAO,GAAIC,OAAQ,GAAIC,KAAM,IAAI,UACrD7C,GACDxB,EACC,IAAKoD,EACH,MAAM,IAAIkB,MAAM,qEAKlB,GAAIjB,EAAYT,SAAW,IAAIE,IAAIO,GAAaN,KAE9C,MADAwB,QAAQC,IAAInB,GACN,IAAIiB,MAAM,qDAElB,GAAIhB,EAAYV,SAAW,IAAIE,IAAIQ,GAAaP,KAE9C,MADAwB,QAAQC,IAAIlB,GACN,IAAIgB,MAAM,qDAIS,IAAvBjB,EAAYT,SACdS,EAAczC,MAAMC,KAAKD,MAAMwC,EAAK,GAAGR,QAAQ6B,SACtB,IAAvBnB,EAAYV,SACdU,EAAc1C,MAAMC,KAAKD,MAAMwC,EAAK,GAAGR,QAAQ6B,SAKjD,MAAMpC,EAAS,GAAGqC,UAAUtB,GAEtBuB,EAAOjC,KAAKkC,OAAOvC,GACnBwC,EAAOnC,KAAKoC,OAAOzC,GAEnB0C,EAAQ,GAAGL,UAAU9D,MAAMwC,EAAKR,QAAQhD,KAAKyD,IAE7C2B,EAAQ,GACd,IAAK,MAAMC,KAAO3B,EAChB0B,EAAM1C,QAAQ1B,MAAMyC,EAAYT,QAAQhD,KAAKqF,IAE/C,MAAMC,EAAQ,GACd,IAAK,MAAM3C,KAAKF,EACd6C,EAAM5C,KAAK,CAAEU,EAAGX,EAAOE,GAAI4C,EAAGJ,EAAMxC,GAAI6C,EAAGJ,EAAMzC,KAInD,MAAMnC,GAAeC,EAAAA,EAAAA,QAAO,MAEtBgF,GAAiBhF,EAAAA,EAAAA,QAAO,OAGvB,CAAEiF,IAAoBC,EAAAA,EAAAA,UAAS,MAgBhCC,GAAaC,EAAAA,EAAAA,IAAe,IAAKjC,GAAekC,OAChDC,GACJF,EAAAA,EAAAA,IAAe,IAAKhC,GAAciC,OALX,EAUnBE,EACJlD,KAAKkC,OACAvB,EAAYb,KAAIqD,IAASC,EAAAA,EAAAA,IAAaD,EAAOrC,MAhBzB,EAmBrBuC,EAAgBrD,KAAKkC,OACtBtB,EAAYd,KAAIqD,IAASC,EAAAA,EAAAA,IAAaD,EAAOrC,MAK5CwC,EAAmBrC,EAAagC,EAAe,EAC/CM,EAAmBrC,EAAa+B,EA1BX,EA0B+C,EAGpEO,EAAkB3C,EACpBqC,EAAgBI,EAChBR,EAAaQ,EACXG,EACmB,IAAvB7C,EAAYV,OACRF,KAAKkC,IAAImB,GAAeD,EAAAA,EAAAA,IAAalC,EAAYH,IACjDsC,EAAgBE,EAGhBG,EAAS,CACblC,IAAKD,EAAOC,IACZC,MAAOF,EAAOE,MACdC,OAAQ8B,EAAkBjC,EAAOG,OACjCC,KAAM8B,EAAkBlC,EAAOI,MA8PjC,OAvPAgC,EAAAA,EAAAA,YAAU,KAIJhB,EAAe7E,SACjB6E,EAAe7E,QAAQ8F,SAAQC,GAASA,EAAMC,WAGhD,MAAMC,EAAYrG,EAAaI,SAG7BkG,YAAaC,EACbC,aAAclB,GACZe,EAAUI,cAGRC,EAAYH,EAAQP,EAAO/B,KAAO+B,EAAOjC,MACzC4C,EAAarB,EAASU,EAAOlC,IAAMkC,EAAOhC,OAK1C4C,EACJF,GAAiE,MAAnDvD,EAAqBiC,EAAaI,IAC5CqB,EAASF,GAA2B,KAAbvB,GAGvB0B,EAAQxE,KAAKyE,KAAK9D,EAAYT,OAASoE,GACvCI,EAAQ1E,KAAKyE,KAAK7D,EAAYV,OAASqE,GAMvCI,EAAgBvG,SAASwG,cAAc,WAC7CC,EAAAA,EAAAA,KAAOd,GACJlG,OACAiH,YAAYH,GACf,MAAMI,GAASF,EAAAA,EAAAA,KAAOF,GACnBK,KAAK,KAAM,UACXA,KAAK,QAASZ,GACdY,KAAK,SAAUX,GACftF,MAAM,WAAY,YAClBA,MAAM,MAAO2E,EAAOlC,IAAM,MAC1BzC,MAAM,OAAQ2E,EAAO/B,KAAO,MAC5B5C,MAAM,SAAUuC,EAAU,eAAY2D,GACnCC,EAAgBH,EACnBlH,OACAsH,WAAW,MAGRC,GAAMP,EAAAA,EAAAA,KAAOd,GAChBsB,OAAO,OACPL,KAAK,KAAM,OACXA,KAAK,UAAW,CAAC,EAAG,EAAGf,EAAOjB,IAG3BP,GAAI6C,EAAAA,EAAAA,MACPC,MAAM,CAAC7B,EAAO/B,KAAMyC,EAAYV,EAAO/B,OACvC6D,OAAO7E,GACP8E,aAAa,GAEVC,EAAQN,EACXC,OAAO,KACPL,KAAK,YAAa,gBAAkBX,EAAaX,EAAOlC,KAAO,KAC/DmE,MACCC,EAAAA,EAAAA,KAAWnD,GAAGoD,YAAW,CAACC,EAAGjG,IACvBA,EAAI2E,IAAU,EAAUsB,EAChB,MAGfC,UAAU,QAETlF,GACF6E,EACG3G,MAAM,cAAe,OACrBiG,KAAK,KAAM,QACXA,KAAK,KAAM,QACXA,KAAK,YAAa,eAIvBI,EACGC,OAAO,QACPL,KAAK,QAAS,WACdA,KAAK,cAAe,UACpBA,KAAK,IAAKtB,EAAO/B,KAAOyC,EAAY,GACpCY,KAAK,IAAKtB,EAAOlC,IAAM6C,EAAab,GACpCwC,KAAK/E,GAGR,MAAMyB,GAAI4C,EAAAA,EAAAA,MACPE,OAAO5E,GACP2E,MAAM,CAAC7B,EAAOlC,IAAK6C,EAAaX,EAAOlC,MACvCyE,QAAQ9E,GAEXiE,EACGC,OAAO,KACPL,KAAK,YAAa,aAAetB,EAAO/B,KAAO,QAC/CgE,MACCO,EAAAA,EAAAA,KAASxD,GAAGmD,YAAW,CAACC,EAAGjG,IACrBA,EAAI6E,IAAU,EAAUoB,EAChB,MAKS,IAAvBlF,EAAYV,OACdkF,EACGC,OAAO,QACPL,KAAK,QAAS,WACdA,KAAK,cAAe,SACpBA,KAAK,IAAK,GACVA,KAAK,IAAKzD,EAAOC,IAAM6C,GACvB2B,KAAK9E,GAERkE,EACGC,OAAO,QACPL,KAAK,QAAS,WACdA,KAAK,cAAe,UACpBA,KAAK,MAAOtB,EAAOlC,IAAM6C,EAAa,IACtCW,KACC,IACAzD,EAAOI,KACL4B,EA7KiB,EAIF,GA6KlByB,KAAK,YAAa,eAClBgB,KAAK9E,GAIV,MAAMiF,EAAU/E,IAEZgF,EAAAA,EAAAA,OACGb,MAAMlG,GACNmG,OAAO,CAACrD,GAAOA,EAAOF,GAAQ,EAAGA,IAGlCoE,EAAY5D,EAAE6D,YACdC,EAAa7D,EAAE4D,YAGrB5F,EAAKkD,SAAQ,CAAC4C,EAAKC,KACjB,MAAMC,EAAYhE,EAAE9B,EAAY6F,IAAO/C,EAAOlC,IAC9CgF,EAAI5C,SAAQ,CAAC+C,EAAOC,KAClB,MAAMC,EAAYpE,EAAE9B,EAAYiG,IAAOlD,EAAO/B,KAC9CuD,EAAc4B,UAAYX,EAAQQ,GAClCzB,EAAc6B,SAASF,EAAWH,EAAWL,EAAWE,EAAW,GACnE,IAIJ,MAAMS,EAAmBC,IAGvB,MAAMC,EAAavC,EAAcwC,wBAE3BN,EAAYI,EAAEG,QAAUF,EAAWvF,KACnC+E,EAAYO,EAAEI,QAAUH,EAAW1F,IAEzC,IAAI8F,EAAStH,KAAKuH,MAAMV,EAAYpE,EAAE+E,QAClCC,EAASzH,KAAKuH,MAAMb,EAAYhE,EAAE8E,QAEtC,MAAME,EAAShH,EAAK,GAAGR,OAAS,EAC5BoH,EAAS,IAAGA,EAAS,GACrBA,EAASI,IAAQJ,EAASI,GAC9B,MAAMC,EAASjH,EAAKR,OAAS,EACzBuH,EAAS,IAAGA,EAAS,GACrBA,EAASE,IAAQF,EAASE,GAE9B,MAAMC,EAAajH,EAAY2G,GACzBO,EAAajH,EAAY6G,GAE/B,MAAO,CAAEH,SAAQG,SAAQd,MADXjG,EAAK+G,GAAQH,GACKM,aAAYC,aAAY,EAI1D,IAAIC,EACAzG,IAEFyG,EAAU1J,SAASwG,cAAc,OACjCmD,OAAOC,OAAOF,EAAQ/I,MAAO,CAC3BkJ,QAAS,OACTC,SAAU,WACVC,cAAe,OACfC,gBAAiB,uBACjBC,MAAO,YACPpC,QAAS,MACTqC,WAAY,eAEdvE,EAAUe,YAAYgD,GAEtBnD,EAAc4D,YAActB,IAE1B,MAAMuB,EAAgBxB,EAAiBC,GAEvCa,EAAQW,UAAYpH,EAAUmH,GAG9BV,EAAQ/I,MAAMkJ,QAAU,eACxB,MACExF,EAAGiG,EACHhG,EAAGiG,IACDC,EAAAA,EAAAA,GACF7E,EACA+D,EACA,CAAErF,EAAGwE,EAAEG,QAAS1E,EAAGuE,EAAEI,SACrB,GAEFS,EAAQ/I,MAAM4C,KAAO+G,EAAmB,KACxCZ,EAAQ/I,MAAMyC,IAAMmH,EAAmB,IAAI,EAE7ChE,EAAckE,aAAe,KAC3Bf,EAAQ/I,MAAMkJ,QAAU,MAAM,GAK9B3G,IACFqD,EAAcmE,YAAc7B,IAE1B,MAAMuB,EAAgBxB,EAAiBC,GAEvC3F,EAAQkH,EAAc,GAK1B7F,EAAe7E,QAAUgK,EAAU,CAAC1C,EAAKL,EAAQ+C,GAAW,CAAC1C,EAAKL,GAElE,MAAMgE,EAAeA,KACnBnG,EAAiB,CACfoG,WAAYC,OAAOD,WACnBE,YAAaD,OAAOC,aACpB,EAKJ,OAHAD,OAAOE,iBAAiB,SAAUJ,GAG3B,KACLE,OAAOG,oBAAoB,SAAUL,EAAa,CACnD,KAODlK,EAAAA,EAAAA,KAAA,OACEC,UAAWA,EACXC,MAAOD,OAAYmG,EAAY,CAAEjC,OAAQ,QAASiB,MAAO,SAAUjF,UAEnEH,EAAAA,EAAAA,KAAA,OACEtB,IAAKG,EACL2L,GAAI,YAEJtK,MAAO,CAAEmJ,SAAU,WAAYjE,MAAO,OAAQjB,OAAQ,WAEpD,G,kDC7YZ,QAA0B,uBAA1B,EAA8D,0BAA9D,EAA+F,oBAA/F,EAA4H,sBAA5H,EAA6J,wBAA7J,EAA8L,sBAA9L,EAA6N,sBAA7N,EAA8P,wBAA9P,EAA8U,kCAA9U,EAAkY,+BAAlY,EAAya,qBAAza,EAAwc,uBAAxc,EAAwe,sB,uGCgBxe,MAIMsG,EAAaC,IACjB,MAAMC,EAAQpL,SAASwG,cAAc,QACrC4E,EAAM1K,UAAYC,EAClB,MAAM0K,EAAUrL,SAASwG,cAAc,QAKvC,OAJA6E,EAAQ3K,UAAYC,EACpB0K,EAAQC,KAAO,UACfF,EAAM1E,YAAY2E,GAClBF,EAAOzE,YAAY0E,GACZC,CAAO,EAKVE,EAAmB,CAAC,QAAS,SAAU,OA+R7C,EA5RwBrM,IAoBjB,IApBkB,cAIvBsM,EAAa,UAEbvK,EAAYsK,EAAgB,YAE5BE,EAAW,SAGXC,EAAQ,WACRC,EAAU,QACVC,EAAO,UACP3I,EAAS,wBAGT4I,EAAuB,UAEvBnL,GACDxB,EAEC,MAAQ4M,SAAUC,IAAoBC,EAAAA,EAAAA,YAAWC,EAAAA,IAG3C,UAAEC,EAAS,YAAEC,EAAW,SAAEpL,EAAQ,SAAEC,IAAaM,EAAAA,EAAAA,UAAQ,KAC7D,IAAKyK,EAAiB,MAAO,CAAC,EAC9B,MAAMK,EAAgBL,EAAgBM,aAEhCC,EAAS,CAAC,EAEVH,EAAc,IAAIrM,MAAMsM,GAAetN,KAAK,MAClD,IAAK,IAAIyN,EAAe,EAAGA,EAAeH,EAAeG,IAAgB,CACvE,MAAMhE,EAAQiD,EAAce,GAC5B,GAAc,OAAVhE,EAAgB,SACpB,MAAMiE,EAAUT,EAAgBU,kBAAkBF,GAC5CG,EAAmB,CACvB7M,MAAO0M,EACPI,OAAQH,EAAQG,OAChBC,OAAQJ,EAAQK,iBAAmBL,EAAQI,OAC3CrE,MAAOA,GAET4D,EAAYI,GAAgBG,EAC5B,MAAMI,EAAQN,EAAQO,UAChBrN,EAAU4M,EAAOQ,GACnBpN,EAASA,EAAQ8B,KAAKkL,GACrBJ,EAAOQ,GAAS,CAACJ,EACxB,CACA,MAAMR,EAAYvC,OAAOqD,QAAQV,GAAQ5K,KAAIuL,IAAwB,IAAtBH,EAAOI,GAASD,EAC7D,MAAO,CACLE,KAAM,SAAWL,EACjBI,SAAUA,EACX,IAGGnM,EAAWa,KAAKkC,OAAO0H,GACvBxK,EAAWY,KAAKoC,OAAOwH,GAE7B,GAAIvK,EAAW,CAEb,MAAM+B,GAAagF,EAAAA,EAAAA,OAChBb,MAAMlG,GACNmG,OAAO,CAACpG,GAAWA,EAAWD,GAAY,EAAGA,IAEhDoL,EAAY3G,SAAQgH,IACbA,IACLA,EAAQvC,MAAQjH,EAAWwJ,EAAQjE,OAAM,GAE7C,CAEA,MAAO,CAAE2D,YAAWC,cAAapL,WAAUC,WAAU,GACpD,CAACwK,EAAevK,EAAW8K,KAGvBqB,EAAUC,EAAWC,IAAiBC,EAAAA,EAAAA,KAGvCC,GAAcjO,EAAAA,EAAAA,QAAO,IAGrBkO,GAA4BhJ,EAAAA,EAAAA,UAAS,KAGpCiJ,EAAkBC,GAAuB9B,GAE5C4B,EAGEG,GAAsBrO,EAAAA,EAAAA,QAAOmO,IAEnCnI,EAAAA,EAAAA,YAAW,KACTqI,EAAoBlO,QAAUgO,CAAgB,GAC7C,CAACA,KAGJnI,EAAAA,EAAAA,YAAU,KACR,MAAMsI,EAAU7N,SAAS8N,eAAe,WACxC,IAAKD,EAAS,OACd,MAAME,EAAkBC,IACtB,MAAMxB,EAAUwB,EAAM7C,OACD,YAAjBqB,EAAQlB,MACZJ,EAAWsB,EAAQ,EAEfyB,EAAiBD,IACrB,MAAMxB,EAAUwB,EAAM7C,OACD,YAAjBqB,EAAQlB,MACZkB,EAAQ0B,YAAY1B,EAAQ2B,UAAU,EAElCC,EAAkBJ,IACtB,MAAMK,EAAiBL,EAAM7C,OAC7B,GAA4B,YAAxBkD,EAAe/C,KAAoB,OAEvC+C,EAAeH,YAAYG,EAAeF,WAG1C,MAAM5B,EAAe8B,EAAeC,aAAa,gBAC3C9B,EAAUL,EAAYI,GAEtB1M,EAAQ+N,EAAoBlO,QAAQ6O,QAAQ/B,GAE5CgC,GAAyB,IAAX3O,EAEd4O,EAAWjC,EAAQiC,SAAWjC,EAAQiC,SAAWrB,IAEvD,GAAIoB,EAAa,CACfhC,EAAQiC,SAAWA,EAEf/C,GAAUA,EAASc,EAASD,EAAckC,GAC9C,MAAMpD,EAAUH,EAAWmD,GAC3BhD,EAAQ1K,MAAM,oBAAsB8N,EACpCjB,EAAY9N,QAAQ8B,KAAK6J,GACzBuC,EAAoBlO,QAAQ8B,KAAKgL,EACnC,KACK,CACHA,EAAQiC,SAAW,KAEf9C,GAAYA,EAAWa,EAASD,EAAckC,GAClD,MAAMrD,EAAQiD,EAAeF,UAG7Bd,EAAUoB,GACVJ,EAAeH,YAAY9C,GAI3BoC,EAAY9N,QAAQgP,OAAO7O,EAAO,GAClC+N,EAAoBlO,QAAQgP,OAAO7O,EAAO,EAC5C,CAEAqL,EAAWmD,GAEXV,EAAoB,IAAKC,EAAoBlO,SAAU,EAUzD,OANAmO,EAAQ9C,iBAAiB,YAAagD,GAAiB,GAEvDF,EAAQ9C,iBAAiB,WAAYkD,GAAgB,GAErDJ,EAAQ9C,iBAAiB,YAAaqD,GAAiB,GAEhD,KACLP,EAAQ7C,oBAAoB,YAAa+C,GAAiB,GAC1DF,EAAQ7C,oBAAoB,WAAYiD,GAAgB,GACxDJ,EAAQ7C,oBAAoB,YAAaoD,GAAiB,GAC1Dd,GAAe,CAChB,GACA,CACDpB,EACAyB,EACAxB,EACAT,EACAC,EACAyB,EACAC,EACAC,IAoBF,GAAKvB,EAGL,OACEtL,EAAAA,EAAAA,KAAA,OAAKC,UAAWA,GAAaC,EAAcC,UACzCuB,EAAAA,EAAAA,MAAA,OAAKzB,UAAWC,EAAiBC,SAAA,CAC9BK,IACCR,EAAAA,EAAAA,KAACkO,EAAAA,EAAW,CACV7N,MAAO2K,EACPzK,SAAUA,EACVD,SAAUA,EACVE,UAAWA,EACXE,UAAU,EACVT,UAAWC,KAGfF,EAAAA,EAAAA,KAAC2B,EAAAA,EAAW,CAAC1B,UAAWC,EAAcsK,GAAG,UAASrK,SAC/CsL,EAAUxK,KAAIkN,IAEXzM,EAAAA,EAAAA,MAAA,WAAS0M,MAAI,EAAAjO,SAAA,EACXH,EAAAA,EAAAA,KAAA,WAASE,MAAO,CAAEmO,OAAQ,WAAYlO,SAAEgO,EAASzB,QACjD1M,EAAAA,EAAAA,KAAA,QAAMC,UAAWC,EAAeC,SAC7BgO,EAAS1B,SACP6B,QAAO,CAACC,EAAeC,EAAgBC,KACrBA,EA/Od,KA+OkD,GACvCF,EAAcxN,KAAK,IAGjC,OAFkBwN,EAAcA,EAAclN,OAAS,GAC7CN,KAAKyN,GACRD,CAAa,GACnB,IACFtN,KAAI,CAACyN,EAAcC,KAClB,MAEMC,EADJF,EAAaA,EAAarN,OAAS,GAAG8K,QAvPrC,IA0PAwC,EAAa,GACVE,EAAUH,EAAazN,KAAI,CAAC8K,EAAS3M,KAEvCY,EAAAA,EAAAA,KAAA,QACE6K,KAAM,UAEN5K,UAAWC,EACXG,MACEmC,GAAaA,EAAUuJ,EAASA,EAAQ3M,OAE1C0P,aAAc/C,EAAQ3M,MAAMe,UAE5BH,EAAAA,EAAAA,KAAA,QACEC,UAAWC,EACXA,MAAO,CAAEqJ,gBAAiBwC,EAAQvC,OAAQrJ,SAEzC4L,EAAQG,UAXN9M,KAgBX,OACEsC,EAAAA,EAAAA,MAAA,QAAuBzB,UAAWC,EAAkBC,SAAA,CACjD0O,EAjRF,KAkREA,EAAQxN,SACPrB,EAAAA,EAAAA,KAAA,QAAMC,UAAWC,EAA4BC,UAC3CH,EAAAA,EAAAA,KAAA,QAAMC,UAAWC,EAAyBC,SACvCyO,QALED,EASJ,QA/CER,EAASzB,UAuDjCO,EAAiB5L,OAAS,IACzBrB,EAAAA,EAAAA,KAAC+O,EAAAA,EAAU,CACT1O,MAAM,mBACNoC,QA7FcuM,KACtB,IAAK,MAAMpE,KAAWmC,EAAY9N,QAAS,CACzC,MAAM0L,EAAQC,EAAQtF,cACPqF,EAAMrF,cACdmI,YAAY9C,EACrB,CACAoC,EAAY9N,QAAU,GACtB4N,IACAI,EAAiBlI,SAAQgH,IACvBA,EAAQiC,SAAW,IAAI,IAEzBd,EAAoB,IAChB/B,GAASA,GAAS,EAkFdlL,UAAWC,EACXsB,KAAK,QAAOrB,UAEZH,EAAAA,EAAAA,KAACiP,EAAAA,EAAe,CAACC,KAAMC,EAAAA,YAIzB,C,kDCzTV,MAAMC,EAAyB,CAAC,MAAO,QAAS,OAAQ,SAAU,UAwClE,EAnCkB,WAGZ,IAFJC,EAAeC,UAAAjO,OAAA,QAAA+E,IAAAkJ,UAAA,GAAAA,UAAA,GAAGF,EAClBG,EAASD,UAAAjO,OAAA,QAAA+E,IAAAkJ,UAAA,GAAAA,UAAA,GAAG,QAGZ,MAAME,GAAa1Q,EAAAA,EAAAA,QAAO,IAG1B,OAAO+B,EAAAA,EAAAA,UAAQ,IAuBN,CAtBU8L,KACf,IAAK,MAAMnD,KAAS6F,EAAiB,CAEnC,IAAe,IADDG,EAAWvQ,QAAQ6O,QAAQtE,GAGvC,OADAgG,EAAWvQ,QAAQ8B,KAAKyI,GACjBA,CAEX,CACA,OAAO+F,CAAS,EAGA/F,IAChB,GAAIA,IAAU+F,EAAW,OACzB,MAAMnQ,EAAQoQ,EAAWvQ,QAAQ6O,QAAQtE,GACzC,IAAe,IAAXpK,EAAc,MAAM,IAAI2D,MAAM,SAADI,OAAUqG,EAAK,iBAChDgG,EAAWvQ,QAAQgP,OAAO7O,EAAO,EAAE,EAIfyN,KACpB2C,EAAWvQ,QAAU,EAAE,IAGxB,CAACoQ,EAAiBE,GACvB,C,qJCxCO,SAASE,EAAoBC,GAClC,OAAOC,EAAAA,EAAAA,IAAqB,UAAWD,EACzC,EACoBE,EAAAA,EAAAA,GAAuB,UAAW,CAAC,S,eCDvD,MAAMC,EAAY,CAAC,YAAa,UAoB1BC,GAAWC,EAAAA,EAAAA,IAAOC,EAAAA,EAAO,CAC7BtD,KAAM,UACNgD,KAAM,OACNO,kBAAmBA,CAACrR,EAAOsR,IAAWA,EAAOC,MAH9BJ,EAId,KACM,CACLK,SAAU,aAwDd,EArD0BC,EAAAA,YAAiB,SAAcC,EAAS5R,GAChE,MAAME,GAAQ2R,EAAAA,EAAAA,GAAgB,CAC5B3R,MAAO0R,EACP5D,KAAM,aAEF,UACFzM,EAAS,OACTuQ,GAAS,GACP5R,EACJ6R,GAAQC,EAAAA,EAAAA,GAA8B9R,EAAOiR,GACzCc,GAAaC,EAAAA,EAAAA,GAAS,CAAC,EAAGhS,EAAO,CACrC4R,WAEIK,EA/BkBF,KACxB,MAAM,QACJE,GACEF,EAIJ,OAAOG,EAAAA,EAAAA,GAHO,CACZX,KAAM,CAAC,SAEoBV,EAAqBoB,EAAQ,EAwB1CE,CAAkBJ,GAClC,OAAoB3Q,EAAAA,EAAAA,KAAK8P,GAAUc,EAAAA,EAAAA,GAAS,CAC1C3Q,WAAW+Q,EAAAA,EAAAA,GAAKH,EAAQV,KAAMlQ,GAC9BgR,UAAWT,EAAS,OAAIpK,EACxB1H,IAAKA,EACLiS,WAAYA,GACXF,GACL,G,0ICnDO,SAASS,EAA2BxB,GACzC,OAAOC,EAAAA,EAAAA,IAAqB,iBAAkBD,EAChD,EAC2BE,EAAAA,EAAAA,GAAuB,iBAAkB,CAAC,S,eCDrE,MAAMC,EAAY,CAAC,YAAa,aAkB1BsB,GAAkBpB,EAAAA,EAAAA,IAAO,MAAO,CACpCrD,KAAM,iBACNgD,KAAM,OACNO,kBAAmBA,CAACrR,EAAOsR,IAAWA,EAAOC,MAHvBJ,EAIrB,KACM,CACL3I,QAAS,GACT,eAAgB,CACdgK,cAAe,QAoDrB,EAhDiCf,EAAAA,YAAiB,SAAqBC,EAAS5R,GAC9E,MAAME,GAAQ2R,EAAAA,EAAAA,GAAgB,CAC5B3R,MAAO0R,EACP5D,KAAM,oBAEF,UACFzM,EAAS,UACTG,EAAY,OACVxB,EACJ6R,GAAQC,EAAAA,EAAAA,GAA8B9R,EAAOiR,GACzCc,GAAaC,EAAAA,EAAAA,GAAS,CAAC,EAAGhS,EAAO,CACrCwB,cAEIyQ,EAlCkBF,KACxB,MAAM,QACJE,GACEF,EAIJ,OAAOG,EAAAA,EAAAA,GAHO,CACZX,KAAM,CAAC,SAEoBe,EAA4BL,EAAQ,EA2BjDE,CAAkBJ,GAClC,OAAoB3Q,EAAAA,EAAAA,KAAKmR,GAAiBP,EAAAA,EAAAA,GAAS,CACjDS,GAAIjR,EACJH,WAAW+Q,EAAAA,EAAAA,GAAKH,EAAQV,KAAMlQ,GAC9B0Q,WAAYA,EACZjS,IAAKA,GACJ+R,GACL,G","sources":["webpack://mdposit/./src/components/animated-card/style.module.css?d4d9","components/animated-card/index.js","webpack://mdposit/./src/components/color-legend/style.module.css?0c39","components/color-legend/index.js","components/d3-heatmap-grid/index.js","webpack://mdposit/./src/components/residue-selector/style.module.css?fec6","components/residue-selector/index.js","hooks/use-colors/index.js","../node_modules/@mui/material/Card/cardClasses.js","../node_modules/@mui/material/Card/Card.js","../node_modules/@mui/material/CardContent/cardContentClasses.js","../node_modules/@mui/material/CardContent/CardContent.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"container\":\"style_container__M9GCG\"};","import React, { useLayoutEffect, useRef, forwardRef } from 'react';\nimport { Card } from '@mui/material';\n\nimport reducedMotion from '../../utils/reduced-motion';\n\nimport style from './style.module.css';\n\nconst KEYFRAMES = { opacity: [0, 1] };\n\nif (!reducedMotion()) {\n  KEYFRAMES.transform = ['translateY(50px)', 'translateY(0)'];\n}\n\nconst ANIMATION_OPTIONS = {\n  fill: 'both',\n  easing: 'cubic-bezier(0, .99, .56, 1.1)',\n  duration: 500,\n};\n\n// Make the card appear and slide softly from down to up when the page is loaded\nconst AnimatedCard = forwardRef(({ overrideComponent, ...props }, ref) => {\n  const containerRef = useRef(null);\n\n  useLayoutEffect(() => {\n    const node = containerRef.current && containerRef.current.firstElementChild;\n    if (!(node && node.animate)) return;\n\n    const index = Array.from(\n      document.querySelectorAll('main section'),\n    ).findIndex(section => node === section);\n\n    const animation = node.animate(KEYFRAMES, {\n      ...ANIMATION_OPTIONS,\n      delay: index * 150,\n    });\n\n    return () => animation.cancel();\n  }, []);\n\n  const Component = overrideComponent ? 'section' : Card;\n\n  return (\n    <div ref={containerRef} className={style.container}>\n      <Component component=\"section\" {...props} ref={ref} />\n    </div>\n  );\n});\n\nexport default AnimatedCard;\n","// extracted by mini-css-extract-plugin\nexport default {\"horizontal\":\"style_horizontal__KW-k9\",\"vertical\":\"style_vertical__YKrT2\",\"heatmap-horizontal\":\"style_heatmap-horizontal__HjdIF\",\"heatmap-vertical\":\"style_heatmap-vertical__utgJY\"};","import React, { useMemo } from 'react';\n\nimport { CardContent } from '@mui/material';\n\nimport style from './style.module.css';\n\nimport D3HeatmapGrid from '../d3-heatmap-grid';\n\n// Display a color legend using the d3 heatmap\nconst ColorLegend = ({\n  // Title to be rendered over the legend\n  title = '',\n  // Maximum and minimum possible values\n  maxValue = 1,\n  minValue = 0,\n  // Colors to represent the values range from lower to higher (e.g. ['red', 'white', 'blue'])\n  colorPlan,\n  // Number of cells in the legend heatmap (i.e. how many times we split the color bar)\n  splits = 19,\n  // Set if the color bar must be veritcal\n  vertical = false,\n  // Allow to force a custom className from the parent component\n  className,\n}) => {\n  // Create a fake 'data' object for the heatmap\n  const { legendData, legendLabels } = useMemo(() => {\n    // Set the legend, which is another heatmap\n    // Make labels for different value regions\n    const values = [];\n    // If the minimum and maximum are the same then there is only one label to show\n    if (minValue === maxValue) values.push(minValue);\n    // Otherwise make the different regions\n    // WARNING: If we have same minimum and maximum values then the logic below will enter in an infinite loop\n    else for (let i = minValue; i <= maxValue; i += (maxValue - minValue) / splits)\n      values.push(i);\n\n    // Round all values\n    let legendLabels = values.map(val => Math.round(val));\n    // If there is more than 1 label then the make sure all of them are unique\n    // WARNING: If we have a single label  the logic below will enter in an infinite loop\n    if (legendLabels.length > 1)\n      // If there are repeated labels then we round to the next 10 fold lower scale until there are no more duplicates\n      for (let decimal = 1; new Set(legendLabels).size < legendLabels.length; decimal++) {\n        legendLabels = values.map(val => Math.round(val * 10 ** decimal) / 10 ** decimal);\n      }\n\n    // Data must be an array inside an array\n    const legendData = vertical ? values.map(v => [v]) : [values];\n    return { legendData, legendLabels };\n  }, [maxValue, minValue, splits, vertical]);\n\n  // Render\n  return (\n    <CardContent\n      className={\n        className ? className : vertical ? style.vertical : style.horizontal\n      }\n    >\n      {title}\n      <D3HeatmapGrid\n        data={legendData}\n        xAxisValues={vertical ? [''] : legendLabels}\n        yAxisValues={vertical ? legendLabels : ['']}\n        colorPlan={colorPlan}\n        flippedXAxisValues={false}\n        className={\n          vertical ? style['heatmap-vertical'] : style['heatmap-horizontal']\n        }\n      />\n    </CardContent>\n  );\n};\n\nexport default ColorLegend;\n","import React, { useRef, useEffect, useState, memo } from 'react';\n\nimport { getTextWidth, getTextSizeDOM } from '../../utils/document-measurer';\n\nimport { axisBottom, select, scaleLinear, scaleBand, axisLeft } from 'd3';\n\nimport { setTooltipPosition } from '../../utils/tooltip-position-manager';\n\n// According to d3 documentation\nconst defaultD3font = 'normal 10px sans-serif';\n// Experimentally verfied\nconst titlesD3font = 'normal 14px sans-serif';\n\n// DANI: Ni este 'memo' ni el 'useMemo' de dentro funcionan. Siempre se vuelve a calcular\n// Lo óptimo sería que funcionase, ya que cada vez que el ususario hace click todo se vuelve a cargar\n// Hay que construir una 'comparision function': https://reactjs.org/docs/react-api.html#reactmemo\n\n// Input 'data' is expected to be an array of arrays (i.e. a matrix)\nconst D3HeatmapGrid = memo(\n  ({\n    data, // The main values\n    xAxisValues = [], // String labels for the horizontal axis\n    yAxisValues = [], // String labels for the vertical axis\n    xAxisLabel, // String title for the horizontal axis\n    yAxisLabel, // String title for the vertical axis\n    verticalPadding = 0,\n    colorPlan = ['red', 'white', 'blue'],\n    colorScale, // In case a color scale is passed it overrides the max, mid and min colors\n    onTooltip, // Text to be rendered on the tooltip\n    onClick, // Function to be called when clicking on the heatmap\n    flippedXAxisValues = true, // Set if values in x axis is horizontal (false) or vertical (true)\n    margin = { top: 10, right: 10, bottom: 10, left: 10 },\n    className,\n  }) => {\n    if (!data)\n      throw new Error(\n        `Data is missing. Data is mandatory for the heatmap representation`,\n      );\n    // Check that there are no duplicates in both x and y axes values\n    // WARNING: Duplicates would not make the heatmap fail, but they will result in overlaps\n    if (xAxisValues.length !== new Set(xAxisValues).size) {\n      console.log(xAxisValues);\n      throw new Error(`Duplicated values in the X axis. See console logs`);\n    }\n    if (yAxisValues.length !== new Set(yAxisValues).size) {\n      console.log(yAxisValues);\n      throw new Error(`Duplicated values in the Y axis. See console logs`);\n    }\n\n    // If any label is empty, fill it with 1-n numbers\n    if (xAxisValues.length === 0)\n      xAxisValues = Array.from(Array(data[0].length).keys());\n    if (yAxisValues.length === 0)\n      yAxisValues = Array.from(Array(data[0].length).keys());\n\n    // Convert data to heatmap friendly format\n\n    // Join all rows into a single array with all values\n    const values = [].concat(...data);\n    // Save the maximum and minimum values\n    const maxv = Math.max(...values);\n    const minv = Math.min(...values);\n    // Repeat the x labels as many times as rows are there\n    const xlabs = [].concat(...Array(data.length).fill(xAxisValues));\n    // Repeat each y label as many times as rows are there\n    const ylabs = [];\n    for (const lab of yAxisValues)\n      ylabs.push(...Array(xAxisValues.length).fill(lab));\n    // Fill an array with an object fo each d, x and y\n    const fdata = [];\n    for (const i in values) {\n      fdata.push({ v: values[i], x: xlabs[i], y: ylabs[i] });\n    }\n\n    // Set the reference to the element where the heatmap will be allocated\n    const containerRef = useRef(null);\n    // Save the previous chart reference so we can remove it before a new render\n    const previousCharts = useRef(null);\n\n    // Use a state as a workaround to force rerenders on window resize\n    const [, setCurrentWindow] = useState(null);\n\n    // ----------------------------------------------------------------------------------------\n\n    // OFFSETS: Estimate the space needed for all the labels and titles to not overlap\n\n    // Set a small offset to be added between normal labels and 90 degrees rotated labels\n    // This offset is added between the y labels (normal) and the y title (rotated)\n    // This offset is added between the x labels (rotated) and the x title (normal)\n    const roatatedTextOffset = 9; // In px\n\n    // Set a small offset to keep away the axis labels and the axis values\n    // They are very close to the axis values by default\n    const axisLabelsOffset = 9; // In px\n\n    // Measure the height of normal and text and labels\n    const textHeight = getTextSizeDOM('|', defaultD3font).height;\n    const labelsHeight =\n      getTextSizeDOM('|', titlesD3font).height + axisLabelsOffset;\n\n    // Get the calculated widths of all y labels and select the maximum\n    // In addition, add a small offset between labels and the axis which is added further\n    // This offset is only in x axes, which are rotated 90 degrees and end too much close to the axis\n    const maxXAxisWidth =\n      Math.max(\n        ...xAxisValues.map(label => getTextWidth(label, defaultD3font)),\n      ) + roatatedTextOffset;\n    // Get the calculated widths of all y labels and select the maximum\n    const maxYAxisWidth = Math.max(\n      ...yAxisValues.map(label => getTextWidth(label, defaultD3font)),\n    );\n\n    // In addition, add a small offset between labels and the axis which is added further\n    // This offset is only in x axes, which are rotated 90 degrees and end too much close to the axis\n    const xAxisLabelHegiht = xAxisLabel ? labelsHeight : 0;\n    const yAxisLabelHegiht = yAxisLabel ? labelsHeight + roatatedTextOffset : 0;\n\n    // Finally, estimate the space needed by axes, titles, etc.\n    const requiredXOffset = flippedXAxisValues\n      ? maxXAxisWidth + xAxisLabelHegiht\n      : textHeight + xAxisLabelHegiht;\n    const requiredYOffset =\n      yAxisValues.length === 1\n        ? Math.max(maxYAxisWidth, getTextWidth(yAxisLabel, titlesD3font))\n        : maxYAxisWidth + yAxisLabelHegiht;\n\n    // Set the dimensions and offsets of the graph\n    const offset = {\n      top: margin.top,\n      right: margin.right,\n      bottom: requiredXOffset + margin.bottom,\n      left: requiredYOffset + margin.left,\n    };\n\n    // ----------------------------------------------------------------------------------------\n\n    // The chart is assigned to a referenced 'div' which must be rendered first\n    // All this process is runned after the render\n    useEffect(() => {\n      // Reset the chart\n      // WARNING: For some reason, if this part is re-render the original render is not gone\n      // WARNING: We must reset the element manually or infinite elements are rendered and stacked\n      if (previousCharts.current)\n        previousCharts.current.forEach(chart => chart.remove());\n\n      // Get the current element where all this heatmap is placed\n      const container = containerRef.current;\n      // The first render, when there is no reference to the current element yet, we skip the process\n      const {\n        clientWidth: width,\n        clientHeight: height,\n      } = container.parentElement;\n\n      // Calculate the body width and height\n      const bodyWidth = width - offset.left - offset.right;\n      const bodyHeight = height - offset.top - offset.bottom;\n\n      // Calculate how many labels we can show in any axis while avoiding overlapping\n      // Take in count that bottom labels are rotated 90º, so it is their height that counts\n      // The '* 1.05' is to grant a small padding\n      const xSlots =\n        bodyWidth / ((flippedXAxisValues ? textHeight : maxXAxisWidth) * 1.05);\n      const ySlots = bodyHeight / (textHeight * 1.05);\n\n      // Estimate how many labels we must skip to reach the desired number\n      const xstep = Math.ceil(xAxisValues.length / xSlots);\n      const ystep = Math.ceil(yAxisValues.length / ySlots);\n\n      // Use canvas to display the heatmap blocks since d3 is not as efficient\n      // Canvas is set this way so we can access this specific element later\n      // WARNING: Using the 'document.getElementById' is risky since there may be more\n      // WARNING: e.g. the color legend\n      const canvasElement = document.createElement('CANVAS');\n      select(container)\n        .node()\n        .appendChild(canvasElement);\n      const canvas = select(canvasElement)\n        .attr('id', 'canvas')\n        .attr('width', bodyWidth)\n        .attr('height', bodyHeight)\n        .style('position', 'absolute')\n        .style('top', offset.top + 'px')\n        .style('left', offset.left + 'px')\n        .style('cursor', onClick ? 'pointer' : undefined);\n      const canvasContext = canvas\n        .node()\n        .getContext('2d' /*, {desynchronized: true}*/);\n\n      // append the svg object to the body of the page\n      const svg = select(container)\n        .append('svg')\n        .attr('id', 'svg')\n        .attr('viewBox', [0, 0, width, height]);\n\n      // Build X scales and axis:\n      const x = scaleBand()\n        .range([offset.left, bodyWidth + offset.left])\n        .domain(xAxisValues)\n        .paddingInner(0);\n\n      const xAxis = svg\n        .append('g')\n        .attr('transform', 'translate(0,' + (bodyHeight + offset.top) + ')')\n        .call(\n          axisBottom(x).tickFormat((d, i) => {\n            if (i % xstep === 0) return d;\n            else return '';\n          }),\n        )\n        .selectAll('text');\n\n      if (flippedXAxisValues) {\n        xAxis\n          .style('text-anchor', 'end')\n          .attr('dx', -roatatedTextOffset + 'px')\n          .attr('dy', -roatatedTextOffset + 'px')\n          .attr('transform', 'rotate(-90)');\n      }\n\n      // Build the X axis label\n      svg\n        .append('text')\n        .attr('class', 'x label')\n        .attr('text-anchor', 'middle')\n        .attr('x', offset.left + bodyWidth / 2)\n        .attr('y', offset.top + bodyHeight + requiredXOffset)\n        .text(xAxisLabel);\n\n      // Build Y scales and axis:\n      const y = scaleBand()\n        .domain(yAxisValues)\n        .range([offset.top, bodyHeight + offset.top])\n        .padding(verticalPadding);\n\n      svg\n        .append('g')\n        .attr('transform', 'translate(' + offset.left + ', 0)')\n        .call(\n          axisLeft(y).tickFormat((d, i) => {\n            if (i % ystep === 0) return d;\n            else return '';\n          }),\n        );\n\n      // Build the Y axis label\n      if (yAxisValues.length === 1) {\n        svg\n          .append('text')\n          .attr('class', 'y label')\n          .attr('text-anchor', 'start')\n          .attr('x', 0)\n          .attr('y', margin.top + bodyHeight)\n          .text(yAxisLabel);\n      } else {\n        svg\n          .append('text')\n          .attr('class', 'y label')\n          .attr('text-anchor', 'middle')\n          .attr('x', -(offset.top + bodyHeight / 2))\n          .attr(\n            'y',\n            margin.left +\n              yAxisLabelHegiht -\n              roatatedTextOffset -\n              axisLabelsOffset,\n          )\n          .attr('transform', 'rotate(-90)')\n          .text(yAxisLabel);\n      }\n\n      // Build color scale\n      const myColor = colorScale\n        ? colorScale\n        : scaleLinear()\n            .range(colorPlan)\n            .domain([minv, (minv + maxv) / 2, maxv]);\n\n      // Get cell size according to d3 scale band\n      const cellWidth = x.bandwidth();\n      const cellHeight = y.bandwidth();\n\n      // Display heatmap cells using canvas\n      data.forEach((row, cy) => {\n        const yPosition = y(yAxisValues[cy]) - offset.top;\n        row.forEach((value, cx) => {\n          const xPosition = x(xAxisValues[cx]) - offset.left;\n          canvasContext.fillStyle = myColor(value);\n          canvasContext.fillRect(xPosition, yPosition, cellWidth, cellHeight);\n        });\n      });\n\n      // Get the current mouse position in a standard format\n      const getMousePosition = e => {\n        // Get canvas current position\n        // WARNING: This line must be inside the function since canvas position may change when scrolling\n        const canvasRect = canvasElement.getBoundingClientRect();\n        // Get the exact mouse positions\n        const xPosition = e.clientX - canvasRect.left;\n        const yPosition = e.clientY - canvasRect.top;\n        // Calculate the equivalent x and y indexes\n        let xIndex = Math.floor(xPosition / x.step());\n        let yIndex = Math.floor(yPosition / y.step());\n        // Sometimes it may happend in the borders of the heatmap that ihe index is out of range\n        const xLimit = data[0].length - 1;\n        if (xIndex < 0) xIndex = 0;\n        if (xIndex > xLimit) xIndex = xLimit;\n        const yLimit = data.length - 1;\n        if (yIndex < 0) yIndex = 0;\n        if (yIndex > yLimit) yIndex = yLimit;\n        // Get also the equivalent axis values and the cell value\n        const xAxisValue = xAxisValues[xIndex];\n        const yAxisValue = yAxisValues[yIndex];\n        const value = data[yIndex][xIndex];\n        return { xIndex, yIndex, value, xAxisValue, yAxisValue };\n      };\n\n      // In case there is a tooltip, handle how to show it\n      let tooltip;\n      if (onTooltip) {\n        // Set up the tooltip, which is hidden by default\n        tooltip = document.createElement('div');\n        Object.assign(tooltip.style, {\n          display: 'none',\n          position: 'absolute',\n          pointerEvents: 'none',\n          backgroundColor: 'rgba( 0, 0, 0, 0.6 )',\n          color: 'lightgrey',\n          padding: '8px',\n          fontFamily: 'sans-serif',\n        });\n        container.appendChild(tooltip);\n\n        canvasElement.onmousemove = e => {\n          // Get current mouse position\n          const mousePosition = getMousePosition(e);\n          // Set the tooltip text\n          tooltip.innerText = onTooltip(mousePosition);\n          //console.log(xIndex + ',' + yIndex);\n          // Set the tooltip position inside the heatmap\n          tooltip.style.display = 'inline-block';\n          const {\n            x: xTooltipPosition,\n            y: yTooltipPosition,\n          } = setTooltipPosition(\n            container,\n            tooltip,\n            { x: e.clientX, y: e.clientY },\n            3,\n          );\n          tooltip.style.left = xTooltipPosition + 'px';\n          tooltip.style.top = yTooltipPosition + 'px';\n        };\n        canvasElement.onmouseleave = () => {\n          tooltip.style.display = 'none';\n        };\n      }\n\n      // Handle when a cell is clicked\n      if (onClick) {\n        canvasElement.onmousedown = e => {\n          // Get current mouse position\n          const mousePosition = getMousePosition(e);\n          // Call the on click function\n          onClick(mousePosition);\n        };\n      }\n\n      // Record all elements which must be removed manually when re-rendering\n      previousCharts.current = tooltip ? [svg, canvas, tooltip] : [svg, canvas];\n\n      const handleResize = () => {\n        setCurrentWindow({\n          innerWidth: window.innerWidth,\n          innerHeight: window.innerHeight,\n        });\n      };\n      window.addEventListener('resize', handleResize);\n\n      // Cleaning function\n      return () => {\n        window.removeEventListener('resize', handleResize);\n      };\n    }); // This useEffect has no dependencies\n\n    // Finally, render the heatmap\n    return (\n      // It is important to specify a height value\n      // Otherwise canvas and svg may be not coordinated\n      <div\n        className={className}\n        style={className ? undefined : { height: '600px', width: '600px' }}\n      >\n        <div\n          ref={containerRef}\n          id={'container'}\n          // WARNING: This width 100% may seem redundant, but chrome needs it\n          style={{ position: 'relative', width: '100%', height: '100%' }}\n        />\n      </div>\n    );\n  },\n);\n\nexport default D3HeatmapGrid;\n","// extracted by mini-css-extract-plugin\nexport default {\"default\":\"style_default__XssaH\",\"horizontal\":\"style_horizontal__FFwZj\",\"thin\":\"style_thin__lEVc2\",\"scroll\":\"style_scroll__uw-00\",\"flexible\":\"style_flexible__Jijoh\",\"normal\":\"style_normal__ymO1T\",\"letter\":\"style_letter__NUedA\",\"margined\":\"style_margined__ItdEs\",\"selected\":\"style_selected__zvOgZ\",\"extra-right-margin\":\"style_extra-right-margin__ixA6k\",\"small-up-number\":\"style_small-up-number__6VamN\",\"pivot\":\"style_pivot__Q44O7\",\"pointer\":\"style_pointer__QFoOj\",\"button\":\"style_button__9jcdg\"};","import React, { useContext, useMemo, useEffect, useRef, useState } from 'react';\n\nimport style from './style.module.css';\n\nimport { CardContent, IconButton } from '@mui/material';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faTrash } from '@fortawesome/free-solid-svg-icons';\n\nimport ColorLegend from '../color-legend';\n\nimport useColors from '../../hooks/use-colors';\n\nimport { scaleLinear } from 'd3';\n\nimport { ProjectCtx } from '../../contexts';\n\n// Set the number of residues between each numeration flag\nconst residuesPerGroup = 10;\n\n// Add a triangle / arrow over the selected residue letter\n// Return also the visual part, so its color can be changed\nconst addPointer = target => {\n  const pivot = document.createElement('span');\n  pivot.className = style.pivot;\n  const pointer = document.createElement('span');\n  pointer.className = style.pointer;\n  pointer.lang = 'pointer';\n  pivot.appendChild(pointer);\n  target.appendChild(pivot);\n  return pointer;\n};\n\n// Set the color of each residue letter in the residue selector by default\n// WARNING: White looks better as minimum color because the background is white so the contrast is low\nconst defaultColorPlan = ['white', 'yellow', 'red'];\n\n// Render a flexible sequence of numerated residues which is also interactive\nconst ResidueSelector = ({\n  // A list of values to color residues\n  // The list must have the same length that the total residues list\n  // Null values will hide residues in the selector\n  residueValues,\n  // Set how residues must be colored according to their 'value'\n  colorPlan = defaultColorPlan,\n  // Set the title for the color legend\n  legendTitle,\n  // Use these callbacks to receive the selected/deselected residues and all its data\n  // WARNING: They must be memoized or strange things may happen\n  onSelect,\n  onDeselect,\n  onClean,\n  onTooltip,\n  // Pass a whole useState to make it handle the selected residues\n  // This only makes sense if you want to control the residues selection from outside this tool in addition\n  forcedResiduesSelection,\n  // To force a styling\n  className,\n}) => {\n  // Get the current project data\n  const { topology: topologyManager } = useContext(ProjectCtx);\n\n  // Get the residues list in model notation\n  const { sequences, residueData, maxValue, minValue } = useMemo(() => {\n    if (!topologyManager) return {};\n    const residuesCount = topologyManager.residueCount;\n    // Get all topology residues and separate them by chains\n    const chains = {};\n    // Get also all residues together and fill missing residues with nulls\n    const residueData = new Array(residuesCount).fill(null);\n    for (let residueIndex = 0; residueIndex < residuesCount; residueIndex++) {\n      const value = residueValues[residueIndex];\n      if (value === null) continue;\n      const residue = topologyManager.getResidueByIndex(residueIndex);\n      const formattedResidue = {\n        index: residueIndex,\n        letter: residue.letter,\n        number: residue.referenceNumber || residue.number,\n        value: value,\n      };\n      residueData[residueIndex] = formattedResidue;\n      const chain = residue.chainName;\n      const current = chains[chain];\n      if (current) current.push(formattedResidue);\n      else chains[chain] = [formattedResidue];\n    }\n    const sequences = Object.entries(chains).map(([chain, residues]) => {\n      return {\n        name: 'Chain ' + chain,\n        residues: residues,\n      };\n    });\n    // Get the minimum and maximum residue values\n    const maxValue = Math.max(...residueValues);\n    const minValue = Math.min(...residueValues);\n    // Set the color scale\n    if (colorPlan) {\n      // WARNING: It is recomended to use white as the majoritarian color for esthetic reasons\n      const colorScale = scaleLinear()\n        .range(colorPlan)\n        .domain([minValue, (minValue + maxValue) / 2, maxValue]);\n      // Set the color of each residue\n      residueData.forEach(residue => {\n        if (!residue) return;\n        residue.color = colorScale(residue.value);\n      });\n    }\n\n    return { sequences, residueData, maxValue, minValue };\n  }, [residueValues, colorPlan, topologyManager]);\n\n  // Use the colors hook\n  const [getColor, freeColor, freeAllColors] = useColors();\n\n  // Save all current pointers\n  const pointersRef = useRef([]);\n\n  // Track when one point in the graph is selected (internal default state)\n  const internalResiduesSelection = useState([]);\n  // Track when one point in the graph is selected\n  // WARNING: The color marks implementation requires the 'selectedResidues' state to be an array of objects\n  const [selectedResidues, setSelectedResidues] = forcedResiduesSelection\n    ? forcedResiduesSelection\n    : internalResiduesSelection;\n  // Set a reference to selected residues\n  // Use this to access to the dynamic value of the state in an already declared function\n  const selectedResiduesRef = useRef(selectedResidues);\n  // Update the reference all the time\n  useEffect (() => {\n    selectedResiduesRef.current = selectedResidues;\n  }, [selectedResidues]);\n\n  // Add events to manage when the mouse hovers / outs / clicks on residues\n  useEffect(() => {\n    const manager = document.getElementById('manager');\n    if (!manager) return;\n    const handleMouseOver = event => {\n      const residue = event.target;\n      if (residue.lang !== 'residue') return;\n      addPointer(residue);\n    };\n    const handleMouseOut = event => {\n      const residue = event.target;\n      if (residue.lang !== 'residue') return;\n      residue.removeChild(residue.lastChild);\n    };\n    const hadleMouseClick = event => {\n      const residueElement = event.target;\n      if (residueElement.lang !== 'residue') return;\n      // Remove the hover pointer so it does not interfere with the click pointer\n      residueElement.removeChild(residueElement.lastChild);\n      // WARNING: This method does not allow to get objects and there is no easy way to do it\n      // Thats why it is done this work around with the residue index\n      const residueIndex = residueElement.getAttribute('residueindex');\n      const residue = residueData[residueIndex];\n      // Get the index of the selected residue\n      const index = selectedResiduesRef.current.indexOf(residue);\n      // Set if the current residue is already selected or not\n      const notSelected = index === -1;\n      // Set the tag color\n      const tagcolor = residue.tagcolor ? residue.tagcolor : getColor();\n      // In case it is not selected\n      if (notSelected) {\n        residue.tagcolor = tagcolor;\n        // Call the 'onSelect' function passing the current selected residue object\n        if (onSelect) onSelect(residue, residueIndex, tagcolor);\n        const pointer = addPointer(residueElement);\n        pointer.style['border-top-color'] = tagcolor;\n        pointersRef.current.push(pointer);\n        selectedResiduesRef.current.push(residue);\n      }\n      else {\n        residue.tagcolor = null;\n        // Call the 'onDeselect' function passing the current deselected residue object\n        if (onDeselect) onDeselect(residue, residueIndex, tagcolor);\n        const pivot = residueElement.lastChild;\n        //const pointer = pivot.lastChild;\n        //tagcolor = pointer.style['border-top-color'];\n        freeColor(tagcolor);\n        residueElement.removeChild(pivot);\n        // WARNING: Do not run this command inside 'setSelectedResidues' since it may be run twice\n        // This is not a problem however for the state itself\n        // The double run is a React conspiration to force you to keep updaters as pure functions\n        pointersRef.current.splice(index, 1);\n        selectedResiduesRef.current.splice(index, 1);\n      }\n      // Set the hover pointer back\n      addPointer(residueElement);\n      // Update the selected residues state\n      setSelectedResidues([ ...selectedResiduesRef.current ]);\n    };\n\n    // Highlight the residue when the mouse is over\n    manager.addEventListener('mouseover', handleMouseOver, true);\n    // Unhighlight the residue when the mouse is out\n    manager.addEventListener('mouseout', handleMouseOut, true);\n    // Set the selected residue when the mouse clicks\n    manager.addEventListener('mousedown', hadleMouseClick, true);\n    // Remove all events and free all tagcolors in the clean up function\n    return () => {\n      manager.removeEventListener('mouseover', handleMouseOver, true);\n      manager.removeEventListener('mouseout', handleMouseOut, true);\n      manager.removeEventListener('mousedown', hadleMouseClick, true);\n      freeAllColors();\n    };\n  }, [\n    sequences,\n    setSelectedResidues,\n    residueData,\n    onSelect,\n    onDeselect,\n    getColor,\n    freeColor,\n    freeAllColors,\n  ]);\n\n  // Set a function to remove all selected residues\n  const cleanSelections = () => {\n    for (const pointer of pointersRef.current) {\n      const pivot = pointer.parentElement;\n      const target = pivot.parentElement;\n      target.removeChild(pivot);\n    }\n    pointersRef.current = [];\n    freeAllColors();\n    selectedResidues.forEach(residue => {\n      residue.tagcolor = null;\n    });\n    setSelectedResidues([]);\n    if (onClean) onClean();\n  };\n\n  // If topology data is not yet loaded then wait\n  if (!topologyManager) return;\n\n  // Render\n  return (\n    <div className={className || style.default}>\n      <div className={style.horizontal}>\n        {colorPlan && (\n          <ColorLegend\n            title={legendTitle}\n            minValue={minValue}\n            maxValue={maxValue}\n            colorPlan={colorPlan}\n            vertical={true}\n            className={style.thin}\n          />\n        )}\n        <CardContent className={style.scroll} id=\"manager\">\n          {sequences.map(sequence => {\n            return (\n              <details open key={sequence.name}>\n                <summary style={{ cursor: 'pointer' }}>{sequence.name}</summary>\n                <span className={style.flexible}>\n                  {sequence.residues\n                    .reduce((residueGroups, currentResidue, currentIndex) => {\n                      const groupEnd = currentIndex % residuesPerGroup === 0;\n                      if (groupEnd) residueGroups.push([]);\n                      const lastGroup = residueGroups[residueGroups.length - 1];\n                      lastGroup.push(currentResidue);\n                      return residueGroups;\n                    }, [])\n                    .map((residueGroup, groupIndex) => {\n                      const lastResidueNumber =\n                        residueGroup[residueGroup.length - 1].number;\n                      const groupNumber =\n                        lastResidueNumber ||\n                        (groupIndex + 1) * residuesPerGroup;\n                      const letters = residueGroup.map((residue, index) => {\n                        return (\n                          <span\n                            lang={'residue'}\n                            key={index}\n                            className={style['normal']}\n                            title={\n                              onTooltip && onTooltip(residue, residue.index)\n                            }\n                            residueindex={residue.index}\n                          >\n                            <span\n                              className={style['letter']}\n                              style={{ backgroundColor: residue.color }}\n                            >\n                              {residue.letter}\n                            </span>\n                          </span>\n                        );\n                      });\n                      return (\n                        <span key={groupIndex} className={style['margined']}>\n                          {letters}\n                          {letters.length === residuesPerGroup && (\n                            <span className={style['extra-right-margin']}>\n                              <span className={style['small-up-number']}>\n                                {groupNumber}\n                              </span>\n                            </span>\n                          )}\n                        </span>\n                      );\n                    })}\n                </span>\n              </details>\n            );\n          })}\n        </CardContent>\n        {selectedResidues.length > 0 && (\n          <IconButton\n            title=\"Clean selections\"\n            onClick={cleanSelections}\n            className={style.button}\n            size=\"large\"\n          >\n            <FontAwesomeIcon icon={faTrash} />\n          </IconButton>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default ResidueSelector;\n","import { useMemo, useRef } from 'react';\n\n// These colors are used to mark different selections\n// When all colors are used the next selections are marked in black\nconst defaultAvailableColors = ['red', 'green', 'blue', 'orange', 'purple'];\n\n// This hook is a special getter of available colors that tracks which colors have been already got\n// This way you will not get the same color twice\n// In addition 2 more functions are returned to free a specific color or all colors\nconst useColors = (\n  availableColors = defaultAvailableColors,\n  overColor = 'black',\n) => {\n  // Track used colors\n  const usedColors = useRef([]);\n\n  // Return a color from the asigned colors list which has not been given yet\n  return useMemo(() => {\n    const getColor = () => {\n      for (const color of availableColors) {\n        const index = usedColors.current.indexOf(color);\n        if (index === -1) {\n          usedColors.current.push(color);\n          return color;\n        }\n      }\n      return overColor;\n    };\n    // Consider the specified color as available to be given again\n    const freeColor = color => {\n      if (color === overColor) return;\n      const index = usedColors.current.indexOf(color);\n      if (index === -1) throw new Error(`Color ${color} is not used`);\n      usedColors.current.splice(index, 1);\n    };\n\n    // Consider all colors as available to be given again\n    const freeAllColors = () => {\n      usedColors.current = [];\n    };\n    return [getColor, freeColor, freeAllColors];\n  }, [availableColors, overColor]);\n};\n\nexport default useColors;\n","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getCardUtilityClass(slot) {\n  return generateUtilityClass('MuiCard', slot);\n}\nconst cardClasses = generateUtilityClasses('MuiCard', ['root']);\nexport default cardClasses;","'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"className\", \"raised\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport chainPropTypes from '@mui/utils/chainPropTypes';\nimport composeClasses from '@mui/utils/composeClasses';\nimport styled from '../styles/styled';\nimport { useDefaultProps } from '../DefaultPropsProvider';\nimport Paper from '../Paper';\nimport { getCardUtilityClass } from './cardClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root']\n  };\n  return composeClasses(slots, getCardUtilityClass, classes);\n};\nconst CardRoot = styled(Paper, {\n  name: 'MuiCard',\n  slot: 'Root',\n  overridesResolver: (props, styles) => styles.root\n})(() => {\n  return {\n    overflow: 'hidden'\n  };\n});\nconst Card = /*#__PURE__*/React.forwardRef(function Card(inProps, ref) {\n  const props = useDefaultProps({\n    props: inProps,\n    name: 'MuiCard'\n  });\n  const {\n      className,\n      raised = false\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const ownerState = _extends({}, props, {\n    raised\n  });\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(CardRoot, _extends({\n    className: clsx(classes.root, className),\n    elevation: raised ? 8 : undefined,\n    ref: ref,\n    ownerState: ownerState\n  }, other));\n});\nprocess.env.NODE_ENV !== \"production\" ? Card.propTypes /* remove-proptypes */ = {\n  // ┌────────────────────────────── Warning ──────────────────────────────┐\n  // │ These PropTypes are generated from the TypeScript type definitions. │\n  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │\n  // └─────────────────────────────────────────────────────────────────────┘\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * If `true`, the card will use raised styling.\n   * @default false\n   */\n  raised: chainPropTypes(PropTypes.bool, props => {\n    if (props.raised && props.variant === 'outlined') {\n      return new Error('MUI: Combining `raised={true}` with `variant=\"outlined\"` has no effect.');\n    }\n    return null;\n  }),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])\n} : void 0;\nexport default Card;","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getCardContentUtilityClass(slot) {\n  return generateUtilityClass('MuiCardContent', slot);\n}\nconst cardContentClasses = generateUtilityClasses('MuiCardContent', ['root']);\nexport default cardContentClasses;","'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"className\", \"component\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport composeClasses from '@mui/utils/composeClasses';\nimport styled from '../styles/styled';\nimport { useDefaultProps } from '../DefaultPropsProvider';\nimport { getCardContentUtilityClass } from './cardContentClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root']\n  };\n  return composeClasses(slots, getCardContentUtilityClass, classes);\n};\nconst CardContentRoot = styled('div', {\n  name: 'MuiCardContent',\n  slot: 'Root',\n  overridesResolver: (props, styles) => styles.root\n})(() => {\n  return {\n    padding: 16,\n    '&:last-child': {\n      paddingBottom: 24\n    }\n  };\n});\nconst CardContent = /*#__PURE__*/React.forwardRef(function CardContent(inProps, ref) {\n  const props = useDefaultProps({\n    props: inProps,\n    name: 'MuiCardContent'\n  });\n  const {\n      className,\n      component = 'div'\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const ownerState = _extends({}, props, {\n    component\n  });\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(CardContentRoot, _extends({\n    as: component,\n    className: clsx(classes.root, className),\n    ownerState: ownerState,\n    ref: ref\n  }, other));\n});\nprocess.env.NODE_ENV !== \"production\" ? CardContent.propTypes /* remove-proptypes */ = {\n  // ┌────────────────────────────── Warning ──────────────────────────────┐\n  // │ These PropTypes are generated from the TypeScript type definitions. │\n  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │\n  // └─────────────────────────────────────────────────────────────────────┘\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: PropTypes.elementType,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])\n} : void 0;\nexport default CardContent;"],"names":["KEYFRAMES","opacity","reducedMotion","transform","ANIMATION_OPTIONS","fill","easing","duration","forwardRef","_ref","ref","overrideComponent","props","containerRef","useRef","useLayoutEffect","node","current","firstElementChild","animate","index","Array","from","document","querySelectorAll","findIndex","section","animation","delay","cancel","Component","Card","_jsx","className","style","children","component","title","maxValue","minValue","colorPlan","splits","vertical","legendData","legendLabels","useMemo","values","push","i","map","val","Math","round","length","decimal","Set","size","v","_jsxs","CardContent","D3HeatmapGrid","data","xAxisValues","yAxisValues","flippedXAxisValues","defaultD3font","titlesD3font","memo","xAxisLabel","yAxisLabel","verticalPadding","colorScale","onTooltip","onClick","margin","top","right","bottom","left","Error","console","log","keys","concat","maxv","max","minv","min","xlabs","ylabs","lab","fdata","x","y","previousCharts","setCurrentWindow","useState","textHeight","getTextSizeDOM","height","labelsHeight","maxXAxisWidth","label","getTextWidth","maxYAxisWidth","xAxisLabelHegiht","yAxisLabelHegiht","requiredXOffset","requiredYOffset","offset","useEffect","forEach","chart","remove","container","clientWidth","width","clientHeight","parentElement","bodyWidth","bodyHeight","xSlots","ySlots","xstep","ceil","ystep","canvasElement","createElement","select","appendChild","canvas","attr","undefined","canvasContext","getContext","svg","append","scaleBand","range","domain","paddingInner","xAxis","call","axisBottom","tickFormat","d","selectAll","text","padding","axisLeft","myColor","scaleLinear","cellWidth","bandwidth","cellHeight","row","cy","yPosition","value","cx","xPosition","fillStyle","fillRect","getMousePosition","e","canvasRect","getBoundingClientRect","clientX","clientY","xIndex","floor","step","yIndex","xLimit","yLimit","xAxisValue","yAxisValue","tooltip","Object","assign","display","position","pointerEvents","backgroundColor","color","fontFamily","onmousemove","mousePosition","innerText","xTooltipPosition","yTooltipPosition","setTooltipPosition","onmouseleave","onmousedown","handleResize","innerWidth","window","innerHeight","addEventListener","removeEventListener","id","addPointer","target","pivot","pointer","lang","defaultColorPlan","residueValues","legendTitle","onSelect","onDeselect","onClean","forcedResiduesSelection","topology","topologyManager","useContext","ProjectCtx","sequences","residueData","residuesCount","residueCount","chains","residueIndex","residue","getResidueByIndex","formattedResidue","letter","number","referenceNumber","chain","chainName","entries","_ref2","residues","name","getColor","freeColor","freeAllColors","useColors","pointersRef","internalResiduesSelection","selectedResidues","setSelectedResidues","selectedResiduesRef","manager","getElementById","handleMouseOver","event","handleMouseOut","removeChild","lastChild","hadleMouseClick","residueElement","getAttribute","indexOf","notSelected","tagcolor","splice","ColorLegend","sequence","open","cursor","reduce","residueGroups","currentResidue","currentIndex","residueGroup","groupIndex","groupNumber","letters","residueindex","IconButton","cleanSelections","FontAwesomeIcon","icon","faTrash","defaultAvailableColors","availableColors","arguments","overColor","usedColors","getCardUtilityClass","slot","generateUtilityClass","generateUtilityClasses","_excluded","CardRoot","styled","Paper","overridesResolver","styles","root","overflow","React","inProps","useDefaultProps","raised","other","_objectWithoutPropertiesLoose","ownerState","_extends","classes","composeClasses","useUtilityClasses","clsx","elevation","getCardContentUtilityClass","CardContentRoot","paddingBottom","as"],"sourceRoot":""}