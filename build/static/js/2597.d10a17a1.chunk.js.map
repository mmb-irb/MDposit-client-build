{"version":3,"file":"static/js/2597.d10a17a1.chunk.js","mappings":"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","sources":["webpack://mdposit/./src/components/animated-card/style.module.css?d4d9","components/animated-card/index.js","webpack://mdposit/./src/components/color-legend/style.module.css?0c39","components/color-legend/index.js","components/d3-heatmap-grid/index.js","webpack://mdposit/./src/components/heatmap/style.module.css?f410","../node_modules/punycode/punycode.es6.js","components/heatmap/index.js","webpack://mdposit/./src/components/interaction-selector/style.module.css?5392","components/interaction-selector/index.js","webpack://mdposit/./src/components/viewer-spawner/style.module.css?df6e","components/viewer-spawner/index.js","utils/document-measurer/index.js","utils/tooltip-position-manager/index.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"container\":\"style_container__M9GCG\"};","import React, { useLayoutEffect, useRef, forwardRef } from 'react';\nimport { Card } from '@mui/material';\n\nimport reducedMotion from '../../utils/reduced-motion';\n\nimport style from './style.module.css';\n\nconst KEYFRAMES = { opacity: [0, 1] };\n\nif (!reducedMotion()) {\n  KEYFRAMES.transform = ['translateY(50px)', 'translateY(0)'];\n}\n\nconst ANIMATION_OPTIONS = {\n  fill: 'both',\n  easing: 'cubic-bezier(0, .99, .56, 1.1)',\n  duration: 500,\n};\n\n// Make the card appear and slide softly from down to up when the page is loaded\nconst AnimatedCard = forwardRef(({ overrideComponent, ...props }, ref) => {\n  const containerRef = useRef(null);\n\n  useLayoutEffect(() => {\n    const node = containerRef.current && containerRef.current.firstElementChild;\n    if (!(node && node.animate)) return;\n\n    const index = Array.from(\n      document.querySelectorAll('main section'),\n    ).findIndex(section => node === section);\n\n    const animation = node.animate(KEYFRAMES, {\n      ...ANIMATION_OPTIONS,\n      delay: index * 150,\n    });\n\n    return () => animation.cancel();\n  }, []);\n\n  const Component = overrideComponent ? 'section' : Card;\n\n  return (\n    <div ref={containerRef} className={style.container}>\n      <Component component=\"section\" {...props} ref={ref} />\n    </div>\n  );\n});\n\nexport default AnimatedCard;\n","// extracted by mini-css-extract-plugin\nexport default {\"horizontal\":\"style_horizontal__KW-k9\",\"vertical\":\"style_vertical__YKrT2\",\"heatmap-horizontal\":\"style_heatmap-horizontal__HjdIF\",\"heatmap-vertical\":\"style_heatmap-vertical__utgJY\"};","import React, { useMemo } from 'react';\n\nimport { CardContent } from '@mui/material';\n\nimport style from './style.module.css';\n\nimport D3HeatmapGrid from '../d3-heatmap-grid';\n\n// Display a color legend using the d3 heatmap\nconst ColorLegend = ({\n  // Title to be rendered over the legend\n  title = '',\n  // Maximum and minimum possible values\n  maxValue = 1,\n  minValue = 0,\n  // Colors to represent the values range from lower to higher (e.g. ['red', 'white', 'blue'])\n  colorPlan,\n  // Number of cells in the legend heatmap (i.e. how many times we split the color bar)\n  splits = 19,\n  // Set if the color bar must be veritcal\n  vertical = false,\n  // Allow to force a custom className from the parent component\n  className,\n}) => {\n  // Create a fake 'data' object for the heatmap\n  const { legendData, legendLabels } = useMemo(() => {\n    // Set the legend, which is another heatmap\n    // Make labels for different value regions\n    const values = [];\n    // If the minimum and maximum are the same then there is only one label to show\n    if (minValue === maxValue) values.push(minValue);\n    // Otherwise make the different regions\n    // WARNING: If we have same minimum and maximum values then the logic below will enter in an infinite loop\n    else for (let i = minValue; i <= maxValue; i += (maxValue - minValue) / splits)\n      values.push(i);\n\n    // Round all values\n    let legendLabels = values.map(val => Math.round(val));\n    // If there is more than 1 label then the make sure all of them are unique\n    // WARNING: If we have a single label  the logic below will enter in an infinite loop\n    if (legendLabels.length > 1)\n      // If there are repeated labels then we round to the next 10 fold lower scale until there are no more duplicates\n      for (let decimal = 1; new Set(legendLabels).size < legendLabels.length; decimal++) {\n        legendLabels = values.map(val => Math.round(val * 10 ** decimal) / 10 ** decimal);\n      }\n\n    // Data must be an array inside an array\n    const legendData = vertical ? values.map(v => [v]) : [values];\n    return { legendData, legendLabels };\n  }, [maxValue, minValue, splits, vertical]);\n\n  // Render\n  return (\n    <CardContent\n      className={\n        className ? className : vertical ? style.vertical : style.horizontal\n      }\n    >\n      {title}\n      <D3HeatmapGrid\n        data={legendData}\n        xAxisValues={vertical ? [''] : legendLabels}\n        yAxisValues={vertical ? legendLabels : ['']}\n        colorPlan={colorPlan}\n        flippedXAxisValues={false}\n        className={\n          vertical ? style['heatmap-vertical'] : style['heatmap-horizontal']\n        }\n      />\n    </CardContent>\n  );\n};\n\nexport default ColorLegend;\n","import React, { useRef, useEffect, useState, memo } from 'react';\n\nimport { getTextWidth, getTextSizeDOM } from '../../utils/document-measurer';\n\nimport { axisBottom, select, scaleLinear, scaleBand, axisLeft } from 'd3';\n\nimport { setTooltipPosition } from '../../utils/tooltip-position-manager';\n\n// According to d3 documentation\nconst defaultD3font = 'normal 10px sans-serif';\n// Experimentally verfied\nconst titlesD3font = 'normal 14px sans-serif';\n\n// DANI: Ni este 'memo' ni el 'useMemo' de dentro funcionan. Siempre se vuelve a calcular\n// Lo óptimo sería que funcionase, ya que cada vez que el ususario hace click todo se vuelve a cargar\n// Hay que construir una 'comparision function': https://reactjs.org/docs/react-api.html#reactmemo\n\n// Input 'data' is expected to be an array of arrays (i.e. a matrix)\nconst D3HeatmapGrid = memo(\n  ({\n    data, // The main values\n    xAxisValues = [], // String labels for the horizontal axis\n    yAxisValues = [], // String labels for the vertical axis\n    xAxisLabel, // String title for the horizontal axis\n    yAxisLabel, // String title for the vertical axis\n    verticalPadding = 0,\n    colorPlan = ['red', 'white', 'blue'],\n    colorScale, // In case a color scale is passed it overrides the max, mid and min colors\n    onTooltip, // Text to be rendered on the tooltip\n    onClick, // Function to be called when clicking on the heatmap\n    flippedXAxisValues = true, // Set if values in x axis is horizontal (false) or vertical (true)\n    margin = { top: 10, right: 10, bottom: 10, left: 10 },\n    className,\n  }) => {\n    if (!data)\n      throw new Error(\n        `Data is missing. Data is mandatory for the heatmap representation`,\n      );\n    // Check that there are no duplicates in both x and y axes values\n    // WARNING: Duplicates would not make the heatmap fail, but they will result in overlaps\n    if (xAxisValues.length !== new Set(xAxisValues).size) {\n      console.log(xAxisValues);\n      throw new Error(`Duplicated values in the X axis. See console logs`);\n    }\n    if (yAxisValues.length !== new Set(yAxisValues).size) {\n      console.log(yAxisValues);\n      throw new Error(`Duplicated values in the Y axis. See console logs`);\n    }\n\n    // If any label is empty, fill it with 1-n numbers\n    if (xAxisValues.length === 0)\n      xAxisValues = Array.from(Array(data[0].length).keys());\n    if (yAxisValues.length === 0)\n      yAxisValues = Array.from(Array(data[0].length).keys());\n\n    // Convert data to heatmap friendly format\n\n    // Join all rows into a single array with all values\n    const values = [].concat(...data);\n    // Save the maximum and minimum values\n    const maxv = Math.max(...values);\n    const minv = Math.min(...values);\n    // Repeat the x labels as many times as rows are there\n    const xlabs = [].concat(...Array(data.length).fill(xAxisValues));\n    // Repeat each y label as many times as rows are there\n    const ylabs = [];\n    for (const lab of yAxisValues)\n      ylabs.push(...Array(xAxisValues.length).fill(lab));\n    // Fill an array with an object fo each d, x and y\n    const fdata = [];\n    for (const i in values) {\n      fdata.push({ v: values[i], x: xlabs[i], y: ylabs[i] });\n    }\n\n    // Set the reference to the element where the heatmap will be allocated\n    const containerRef = useRef(null);\n    // Save the previous chart reference so we can remove it before a new render\n    const previousCharts = useRef(null);\n\n    // Use a state as a workaround to force rerenders on window resize\n    const [, setCurrentWindow] = useState(null);\n\n    // ----------------------------------------------------------------------------------------\n\n    // OFFSETS: Estimate the space needed for all the labels and titles to not overlap\n\n    // Set a small offset to be added between normal labels and 90 degrees rotated labels\n    // This offset is added between the y labels (normal) and the y title (rotated)\n    // This offset is added between the x labels (rotated) and the x title (normal)\n    const roatatedTextOffset = 9; // In px\n\n    // Set a small offset to keep away the axis labels and the axis values\n    // They are very close to the axis values by default\n    const axisLabelsOffset = 9; // In px\n\n    // Measure the height of normal and text and labels\n    const textHeight = getTextSizeDOM('|', defaultD3font).height;\n    const labelsHeight =\n      getTextSizeDOM('|', titlesD3font).height + axisLabelsOffset;\n\n    // Get the calculated widths of all y labels and select the maximum\n    // In addition, add a small offset between labels and the axis which is added further\n    // This offset is only in x axes, which are rotated 90 degrees and end too much close to the axis\n    const maxXAxisWidth =\n      Math.max(\n        ...xAxisValues.map(label => getTextWidth(label, defaultD3font)),\n      ) + roatatedTextOffset;\n    // Get the calculated widths of all y labels and select the maximum\n    const maxYAxisWidth = Math.max(\n      ...yAxisValues.map(label => getTextWidth(label, defaultD3font)),\n    );\n\n    // In addition, add a small offset between labels and the axis which is added further\n    // This offset is only in x axes, which are rotated 90 degrees and end too much close to the axis\n    const xAxisLabelHegiht = xAxisLabel ? labelsHeight : 0;\n    const yAxisLabelHegiht = yAxisLabel ? labelsHeight + roatatedTextOffset : 0;\n\n    // Finally, estimate the space needed by axes, titles, etc.\n    const requiredXOffset = flippedXAxisValues\n      ? maxXAxisWidth + xAxisLabelHegiht\n      : textHeight + xAxisLabelHegiht;\n    const requiredYOffset =\n      yAxisValues.length === 1\n        ? Math.max(maxYAxisWidth, getTextWidth(yAxisLabel, titlesD3font))\n        : maxYAxisWidth + yAxisLabelHegiht;\n\n    // Set the dimensions and offsets of the graph\n    const offset = {\n      top: margin.top,\n      right: margin.right,\n      bottom: requiredXOffset + margin.bottom,\n      left: requiredYOffset + margin.left,\n    };\n\n    // ----------------------------------------------------------------------------------------\n\n    // The chart is assigned to a referenced 'div' which must be rendered first\n    // All this process is runned after the render\n    useEffect(() => {\n      // Reset the chart\n      // WARNING: For some reason, if this part is re-render the original render is not gone\n      // WARNING: We must reset the element manually or infinite elements are rendered and stacked\n      if (previousCharts.current)\n        previousCharts.current.forEach(chart => chart.remove());\n\n      // Get the current element where all this heatmap is placed\n      const container = containerRef.current;\n      // The first render, when there is no reference to the current element yet, we skip the process\n      const {\n        clientWidth: width,\n        clientHeight: height,\n      } = container.parentElement;\n\n      // Calculate the body width and height\n      const bodyWidth = width - offset.left - offset.right;\n      const bodyHeight = height - offset.top - offset.bottom;\n\n      // Calculate how many labels we can show in any axis while avoiding overlapping\n      // Take in count that bottom labels are rotated 90º, so it is their height that counts\n      // The '* 1.05' is to grant a small padding\n      const xSlots =\n        bodyWidth / ((flippedXAxisValues ? textHeight : maxXAxisWidth) * 1.05);\n      const ySlots = bodyHeight / (textHeight * 1.05);\n\n      // Estimate how many labels we must skip to reach the desired number\n      const xstep = Math.ceil(xAxisValues.length / xSlots);\n      const ystep = Math.ceil(yAxisValues.length / ySlots);\n\n      // Use canvas to display the heatmap blocks since d3 is not as efficient\n      // Canvas is set this way so we can access this specific element later\n      // WARNING: Using the 'document.getElementById' is risky since there may be more\n      // WARNING: e.g. the color legend\n      const canvasElement = document.createElement('CANVAS');\n      select(container)\n        .node()\n        .appendChild(canvasElement);\n      const canvas = select(canvasElement)\n        .attr('id', 'canvas')\n        .attr('width', bodyWidth)\n        .attr('height', bodyHeight)\n        .style('position', 'absolute')\n        .style('top', offset.top + 'px')\n        .style('left', offset.left + 'px')\n        .style('cursor', onClick ? 'pointer' : undefined);\n      const canvasContext = canvas\n        .node()\n        .getContext('2d' /*, {desynchronized: true}*/);\n\n      // append the svg object to the body of the page\n      const svg = select(container)\n        .append('svg')\n        .attr('id', 'svg')\n        .attr('viewBox', [0, 0, width, height]);\n\n      // Build X scales and axis:\n      const x = scaleBand()\n        .range([offset.left, bodyWidth + offset.left])\n        .domain(xAxisValues)\n        .paddingInner(0);\n\n      const xAxis = svg\n        .append('g')\n        .attr('transform', 'translate(0,' + (bodyHeight + offset.top) + ')')\n        .call(\n          axisBottom(x).tickFormat((d, i) => {\n            if (i % xstep === 0) return d;\n            else return '';\n          }),\n        )\n        .selectAll('text');\n\n      if (flippedXAxisValues) {\n        xAxis\n          .style('text-anchor', 'end')\n          .attr('dx', -roatatedTextOffset + 'px')\n          .attr('dy', -roatatedTextOffset + 'px')\n          .attr('transform', 'rotate(-90)');\n      }\n\n      // Build the X axis label\n      svg\n        .append('text')\n        .attr('class', 'x label')\n        .attr('text-anchor', 'middle')\n        .attr('x', offset.left + bodyWidth / 2)\n        .attr('y', offset.top + bodyHeight + requiredXOffset)\n        .text(xAxisLabel);\n\n      // Build Y scales and axis:\n      const y = scaleBand()\n        .domain(yAxisValues)\n        .range([offset.top, bodyHeight + offset.top])\n        .padding(verticalPadding);\n\n      svg\n        .append('g')\n        .attr('transform', 'translate(' + offset.left + ', 0)')\n        .call(\n          axisLeft(y).tickFormat((d, i) => {\n            if (i % ystep === 0) return d;\n            else return '';\n          }),\n        );\n\n      // Build the Y axis label\n      if (yAxisValues.length === 1) {\n        svg\n          .append('text')\n          .attr('class', 'y label')\n          .attr('text-anchor', 'start')\n          .attr('x', 0)\n          .attr('y', margin.top + bodyHeight)\n          .text(yAxisLabel);\n      } else {\n        svg\n          .append('text')\n          .attr('class', 'y label')\n          .attr('text-anchor', 'middle')\n          .attr('x', -(offset.top + bodyHeight / 2))\n          .attr(\n            'y',\n            margin.left +\n              yAxisLabelHegiht -\n              roatatedTextOffset -\n              axisLabelsOffset,\n          )\n          .attr('transform', 'rotate(-90)')\n          .text(yAxisLabel);\n      }\n\n      // Build color scale\n      const myColor = colorScale\n        ? colorScale\n        : scaleLinear()\n            .range(colorPlan)\n            .domain([minv, (minv + maxv) / 2, maxv]);\n\n      // Get cell size according to d3 scale band\n      const cellWidth = x.bandwidth();\n      const cellHeight = y.bandwidth();\n\n      // Display heatmap cells using canvas\n      data.forEach((row, cy) => {\n        const yPosition = y(yAxisValues[cy]) - offset.top;\n        row.forEach((value, cx) => {\n          const xPosition = x(xAxisValues[cx]) - offset.left;\n          canvasContext.fillStyle = myColor(value);\n          canvasContext.fillRect(xPosition, yPosition, cellWidth, cellHeight);\n        });\n      });\n\n      // Get the current mouse position in a standard format\n      const getMousePosition = e => {\n        // Get canvas current position\n        // WARNING: This line must be inside the function since canvas position may change when scrolling\n        const canvasRect = canvasElement.getBoundingClientRect();\n        // Get the exact mouse positions\n        const xPosition = e.clientX - canvasRect.left;\n        const yPosition = e.clientY - canvasRect.top;\n        // Calculate the equivalent x and y indexes\n        let xIndex = Math.floor(xPosition / x.step());\n        let yIndex = Math.floor(yPosition / y.step());\n        // Sometimes it may happend in the borders of the heatmap that ihe index is out of range\n        const xLimit = data[0].length - 1;\n        if (xIndex < 0) xIndex = 0;\n        if (xIndex > xLimit) xIndex = xLimit;\n        const yLimit = data.length - 1;\n        if (yIndex < 0) yIndex = 0;\n        if (yIndex > yLimit) yIndex = yLimit;\n        // Get also the equivalent axis values and the cell value\n        const xAxisValue = xAxisValues[xIndex];\n        const yAxisValue = yAxisValues[yIndex];\n        const value = data[yIndex][xIndex];\n        return { xIndex, yIndex, value, xAxisValue, yAxisValue };\n      };\n\n      // In case there is a tooltip, handle how to show it\n      let tooltip;\n      if (onTooltip) {\n        // Set up the tooltip, which is hidden by default\n        tooltip = document.createElement('div');\n        Object.assign(tooltip.style, {\n          display: 'none',\n          position: 'absolute',\n          pointerEvents: 'none',\n          backgroundColor: 'rgba( 0, 0, 0, 0.6 )',\n          color: 'lightgrey',\n          padding: '8px',\n          fontFamily: 'sans-serif',\n        });\n        container.appendChild(tooltip);\n\n        canvasElement.onmousemove = e => {\n          // Get current mouse position\n          const mousePosition = getMousePosition(e);\n          // Set the tooltip text\n          tooltip.innerText = onTooltip(mousePosition);\n          //console.log(xIndex + ',' + yIndex);\n          // Set the tooltip position inside the heatmap\n          tooltip.style.display = 'inline-block';\n          const {\n            x: xTooltipPosition,\n            y: yTooltipPosition,\n          } = setTooltipPosition(\n            container,\n            tooltip,\n            { x: e.clientX, y: e.clientY },\n            3,\n          );\n          tooltip.style.left = xTooltipPosition + 'px';\n          tooltip.style.top = yTooltipPosition + 'px';\n        };\n        canvasElement.onmouseleave = () => {\n          tooltip.style.display = 'none';\n        };\n      }\n\n      // Handle when a cell is clicked\n      if (onClick) {\n        canvasElement.onmousedown = e => {\n          // Get current mouse position\n          const mousePosition = getMousePosition(e);\n          // Call the on click function\n          onClick(mousePosition);\n        };\n      }\n\n      // Record all elements which must be removed manually when re-rendering\n      previousCharts.current = tooltip ? [svg, canvas, tooltip] : [svg, canvas];\n\n      const handleResize = () => {\n        setCurrentWindow({\n          innerWidth: window.innerWidth,\n          innerHeight: window.innerHeight,\n        });\n      };\n      window.addEventListener('resize', handleResize);\n\n      // Cleaning function\n      return () => {\n        window.removeEventListener('resize', handleResize);\n      };\n    }); // This useEffect has no dependencies\n\n    // Finally, render the heatmap\n    return (\n      // It is important to specify a height value\n      // Otherwise canvas and svg may be not coordinated\n      <div\n        className={className}\n        style={className ? undefined : { height: '600px', width: '600px' }}\n      >\n        <div\n          ref={containerRef}\n          id={'container'}\n          // WARNING: This width 100% may seem redundant, but chrome needs it\n          style={{ position: 'relative', width: '100%', height: '100%' }}\n        />\n      </div>\n    );\n  },\n);\n\nexport default D3HeatmapGrid;\n","// extracted by mini-css-extract-plugin\nexport default {\"card\":\"style_card__ad3Ck\",\"loading\":\"style_loading__boyy5\",\"heatmap\":\"style_heatmap__03kXZ\"};","'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7F]/; // Note: U+007F DEL is excluded too.\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, callback) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = callback(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {String} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(domain, callback) {\n\tconst parts = domain.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tdomain = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tdomain = domain.replace(regexSeparators, '\\x2E');\n\tconst labels = domain.split('.');\n\tconst encoded = map(labels, callback).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = codePoints => String.fromCodePoint(...codePoints);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint >= 0x30 && codePoint < 0x3A) {\n\t\treturn 26 + (codePoint - 0x30);\n\t}\n\tif (codePoint >= 0x41 && codePoint < 0x5B) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint >= 0x61 && codePoint < 0x7B) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tconst oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\t\t\tif (digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tconst inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tconst basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue === n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.3.1',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nexport { ucs2decode, ucs2encode, decode, encode, toASCII, toUnicode };\nexport default punycode;\n","import React, { Suspense, useMemo } from 'react';\n\nimport { CardContent } from '@mui/material';\n\nimport style from './style.module.css';\n\nimport D3HeatmapGrid from '../d3-heatmap-grid';\n\nimport ColorLegend from '../color-legend';\nimport { ucs2 } from 'punycode';\n\nconst Heatmap = ({\n  // The expected data format is an complex object\n  inputData,\n  // Maximum number of x and y cells\n  xMaxCells = 110,\n  yMaxCells = 260,\n  // Function to set what text must appear in the hover tooltip\n  onTooltip,\n  // Function to be called when the user clicks in a heatmap cell\n  onClick,\n  // Title to be rendered over the legend\n  // No legend will be rendered if it is blank\n  legendTitle = '',\n  // Colors to represent the values range from lower to higher (e.g. ['red', 'white', 'blue'])\n  colorPlan,\n  // Titles for x and y axes\n  xTitle,\n  yTitle,\n}) => {\n  // Data processing\n  const {\n    data,\n    xLabels,\n    yLabels,\n    minValue,\n    maxValue,\n    xstep,\n    ystep,\n  } = useMemo(() => {\n    // Return if the payload is not ready\n    if (!inputData || !inputData.data || inputData.data.length === 0) return {};\n\n    // Get the data reference\n    const rData = inputData.data;\n    let rxLabels = inputData.xLabels;\n    let ryLabels = inputData.yLabels;\n\n    // Get data set x and y lengths\n    const xLength = rData[0].length;\n    const yLength = rData.length;\n\n    // Check all rows to have the same length\n    rData.forEach(row => {\n      if (row.length !== xLength)\n        throw new Error('All rows must have the same length');\n    });\n\n    const xstep = xLength / xMaxCells;\n    const ystep = yLength / yMaxCells;\n\n    // Get a reduced subset of data which respects the maximum x and y lengths\n    let data;\n    if (ystep <= 1) {\n      if (xstep <= 1) {\n        data = rData;\n      } else {\n        data = new Array(yLength);\n        const summarizedIndexes = new Array(xMaxCells);\n        for (let x = 0; x < xMaxCells; x++) {\n          summarizedIndexes[x] = Math.round(x * xstep);\n        }\n        for (let y = 0; y < yLength; y++) {\n          data[y] = summarizedIndexes.map(x => rData[y][x]);\n        }\n      }\n    } else {\n      // WARNING: Note that the list of lists has to be generated this way\n      // WARNING: If you fill the first array with an array then it will be same array for all values\n      data = new Array(yMaxCells).fill().map(u => new Array(xMaxCells).fill(null));\n      if (xstep <= 1) {\n        for (let y = 0; y < yMaxCells; y++) {\n          data[y] = rData[Math.round(y * ystep)];\n        }\n      } else {\n        for (let y = 0; y < yMaxCells; y++) {\n          const yIndex = Math.round(y * ystep);\n          for (let x = 0; x < xMaxCells; x++) {\n            const xIndex = Math.round(x * xstep);\n            data[y][x] = rData[yIndex][xIndex];\n          }\n        }\n      }\n    }\n\n    // Create 1-n labels if they are not provided\n    if (!rxLabels) rxLabels = Array.from(Array(xLength).keys());\n    if (!ryLabels) ryLabels = Array.from(Array(yLength).keys());\n\n    // Check that both lengths match as they should\n    if (xLength !== rxLabels.length)\n      console.error('Heatmap error: x labels do not match data dimensions');\n    if (yLength !== ryLabels.length)\n      console.error('Heatmap error: y labels do not match data dimensions');\n\n    // Set the heatmap labels\n    let xLabels;\n    let yLabels;\n\n    // x labels\n    if (xstep <= 1) {\n      xLabels = rxLabels;\n    } else {\n      xLabels = new Array(xMaxCells);\n      for (let i = 0; i < xMaxCells; i++)\n        xLabels[i] = rxLabels[Math.round(i * xstep)];\n    }\n\n    // y labels\n    if (ystep <= 1) {\n      yLabels = ryLabels;\n    } else {\n      yLabels = new Array(yMaxCells);\n      for (let i = 0; i < yMaxCells; i++)\n        yLabels[i] = ryLabels[Math.round(i * ystep)];\n    }\n\n    // Set the legend, which is another heatmap\n    const minValue = Math.min(...data.map(values => Math.min(...values)));\n    const maxValue = Math.max(...data.map(values => Math.max(...values)));\n\n    // Save all processed data\n    return {\n      data: data,\n      xLabels: xLabels,\n      yLabels: yLabels,\n      minValue: minValue,\n      maxValue: maxValue,\n      xstep,\n      ystep,\n    };\n    // WARNING: Changes in 'inputData' may be not detected\n  }, [inputData, xMaxCells, yMaxCells]);\n\n  // Render loading or error messages according with the API response\n  if (!inputData) return 'Heatmap Error: No \"inputData\" was provided';\n  if (!inputData.data || inputData.data.length === 0)\n    return 'Heatmap Error: The data field is empty or non existent';\n\n  // The main value and axes values are the same, but not the incides\n  // Since we reduced the dataset we must convert indices in order to match the original dataset\n  const convertMousePosition = ({\n    xIndex,\n    yIndex,\n    value,\n    xAxisValue,\n    yAxisValue,\n  }) => {\n    const realXIndex = xstep <= 1 ? xIndex : Math.round(xIndex * xstep);\n    const realYIndex = ystep <= 1 ? yIndex : Math.round(yIndex * ystep);\n    return {\n      xIndex: realXIndex,\n      yIndex: realYIndex,\n      value,\n      xAxisValue,\n      yAxisValue,\n    };\n  };\n\n  const handleMouseClick = e => {\n    if (!onClick) return;\n    const mousePosition = convertMousePosition(e);\n    return onClick(mousePosition);\n  };\n\n  const handleMouseTooltip = e => {\n    if (!onTooltip) return;\n    const mousePosition = convertMousePosition(e);\n    return onTooltip(mousePosition);\n  };\n\n  // Render\n  return (\n    <Suspense fallback={<div className={style.loading}>Loading...</div>}>\n      <D3HeatmapGrid\n        data={data}\n        xAxisValues={xLabels}\n        yAxisValues={yLabels}\n        colorPlan={colorPlan}\n        xAxisLabel={xTitle}\n        yAxisLabel={yTitle}\n        onClick={handleMouseClick}\n        onTooltip={handleMouseTooltip}\n        className={style.heatmap}\n      />\n      {legendTitle && (\n        <CardContent>\n          <ColorLegend\n            title={legendTitle}\n            minValue={minValue}\n            maxValue={maxValue}\n            colorPlan={colorPlan}\n          />\n        </CardContent>\n      )}\n    </Suspense>\n  );\n};\n\nexport default Heatmap;\n","// extracted by mini-css-extract-plugin\nexport default {\"horizontal\":\"style_horizontal__2DIWx\",\"horizontal-margined\":\"style_horizontal-margined__e9fQR\"};","import React, { Suspense } from 'react';\n\nimport {\n  FormControlLabel,\n  Radio,\n  RadioGroup,\n  Select,\n  MenuItem,\n  TextField,\n  IconButton,\n} from '@mui/material';\n\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faExchangeAlt } from '@fortawesome/free-solid-svg-icons';\n\nimport Loading from '../loading';\n\nimport style from './style.module.css';\n\nconst residueOptions = [\n  { label: 'All residues', value: 'residue_indices' },\n  { label: 'Interface residues', value: 'interface_indices' },\n];\n\n// Render a panel which allows to select the desired interaction\n// If the user selects a new interaction then the 'setSelectedInteraction' is set as its index\n// Interactions have the following structure:\n// { name: string, label: string, ... }\n// The 'label' field will replace the 'name' in the selector labels if exists\n// When 'selectedResidues' is passed, render also tools to select interaction residues\n// Residue options are 'all' or 'interface' residues\n// DANI: La guinda sería un 'custom' en las opciones de residuos\n// DANI: La idea sería desplegar dos residue selectors, uno para cada interaction agent\nconst InteractionSelector = ({\n  interactions,\n  selectedInteraction,\n  setSelectedInteraction,\n  selectedResidues,\n  setSelectedResidues,\n  selectedOrder,\n  handleToggleOrder,\n  firstOrderLabel, // The label to be represented over the first order rectangle\n  firstOrderTooltip, // The tooltip to be shown for the first order rectangle\n  secondOrderLabel, // The label to be represented over the second order rectangle\n  secondOrderTooltip, // The tooltip to be shown for the second order rectangle\n  toggleOrderTooltip, // The tooltip to be shown for the toggle order button\n  interfaceOnly = false, // Set if the 'All residues' button is enabled\n}) => {\n  const changeInteraction = event => {\n    setSelectedInteraction(event.target.value);\n  };\n\n  const changeResidues = event => {\n    setSelectedResidues(event.target.value);\n  };\n\n  const changeOrder = () => {\n    handleToggleOrder();\n  };\n\n  const currentInteraction = interactions[selectedInteraction];\n\n  // Render\n  return (\n    <Suspense fallback={<Loading />}>\n      <Select\n        value={selectedInteraction}\n        onChange={changeInteraction}\n        className={style['horizontal-margined']}\n      >\n        {interactions.map((interaction, i) => (\n          <MenuItem key={i} value={i}>\n            {interaction.label || interaction.name}\n          </MenuItem>\n        ))}\n      </Select>\n      {selectedResidues && (\n        <RadioGroup\n          value={selectedResidues}\n          onChange={changeResidues}\n          className={style.horizontal}\n        >\n          {residueOptions.map((opt, i) => (\n            <FormControlLabel\n              key={i}\n              value={opt.value}\n              control={<Radio color=\"primary\" />}\n              label={opt.label}\n              disabled={opt.label === 'All residues' && interfaceOnly}\n            />\n          ))}\n        </RadioGroup>\n      )}\n      {selectedOrder !== undefined && (\n        <>\n          <TextField\n            //margin=\"dense\"\n            label={firstOrderLabel}\n            title={firstOrderTooltip}\n            value={\n              selectedOrder\n                ? currentInteraction.agent_1\n                : currentInteraction.agent_2\n            }\n          />\n          <IconButton\n            title={toggleOrderTooltip}\n            onClick={changeOrder}\n            size=\"large\"\n          >\n            <FontAwesomeIcon icon={faExchangeAlt} />\n          </IconButton>\n          <TextField\n            //margin=\"dense\"\n            label={secondOrderLabel}\n            title={secondOrderTooltip}\n            value={\n              selectedOrder\n                ? currentInteraction.agent_2\n                : currentInteraction.agent_1\n            }\n          />\n        </>\n      )}\n    </Suspense>\n  );\n};\n\nexport default InteractionSelector;\n","// extracted by mini-css-extract-plugin\nexport default {\"rnd\":\"style_rnd__Txifm\",\"floating-card\":\"style_floating-card__HHpby\"};","import React, { lazy, Suspense, useRef, useState } from 'react';\n\n// Rnd is the resizable and draggable system where the ngl viewer is placed\nimport { Rnd } from 'react-rnd';\n\nimport Card from '../animated-card';\n\nimport style from './style.module.css';\n\nconst ViewerWithControls = lazy(() =>\n  import(\n    /* webpackChunkName: 'viewer-with-controls' */ '../viewer-with-controls'\n  ),\n);\n\n// Minimal ngl window height\nconst MIN_NGL_DIMENSION = 150;\n\n// Counter to get always the maximum zIndex\n// This is useful to set a new or currently dragged/resized ngl window over the others\nlet maxZ = 0;\nconst nextZ = () => {\n  maxZ += 1;\n  return maxZ;\n};\n\n// This function spawns all the NGL viewers needed\n// i.e. one viewer with the requested 'props' and all previous viewers which have been nailed\nconst ViewerSpawner = ({ newViewer, nailing = true, onNail, onClose }) => {\n  // Store here all nailed NGL viewers\n  const [nailedViewers, setNailedViewers] = useState([]);\n\n  // Set the viewers as the nailed viewers and the new viewer\n  const viewers = [...nailedViewers];\n\n  // Keep listed all arrays which have been used (i.e. ngl viewers which have been nailed or closed)\n  const usedIds = useRef([]);\n\n  if (newViewer) {\n    // Find a new suitable Id that meet 2 conditions:\n    // - There is never 2 viewers with the same id, so we avoid errors\n    // - If we pick diferent frames in the graph without nailing anything, the current viewer has always the same id\n    // (This way the current viewer does not appear in the origin position every time)\n    const getNewId = () => {\n      let id = 0;\n      while (id < 999) {\n        if (usedIds.current.indexOf(id) === -1) return id;\n        id += 1;\n      }\n      console.error('Maximum number of viewers reached');\n    };\n\n    // Set a unique id for this props based in the last nailed viewer\n    newViewer.id = getNewId();\n    newViewer.close = () => {\n      if (nailing) {\n        setNailedViewers(nailed => {\n          const newNailed = [...nailed];\n          const index = nailed.indexOf(newViewer);\n          if (index !== -1) newNailed.splice(index, 1);\n          return newNailed;\n        });\n      }\n      if (onClose) onClose(newViewer);\n      usedIds.current.push(newViewer.id);\n    };\n    // If the nailer function is passed, add the logic for the viewer to be nailed further\n    if (nailing)\n      newViewer.nail = () => {\n        setNailedViewers(nailed => [...nailed, newViewer]);\n        if (onNail) onNail(newViewer);\n        usedIds.current.push(newViewer.id);\n      };\n    // Add the current viewer to the viewers list\n    viewers.push(newViewer);\n  }\n\n  // Render a viewer for each prop. Use the 'selected' parameter as unique id\n  return viewers.map(viewer => <NGLViewerInDND key={viewer.id} {...viewer} />);\n};\n\n// This component render a small NGL viewer\n// It is called when user clicks in a point in the projections component\n// Also it is called by the generic analysis page\nconst NGLViewerInDND = props => {\n  // Set a reference for the viewer\n  // If a reference is passed among the viewer arguments then use it instead\n  const viewerRef = props.viewerRef || useRef(null);\n\n  // Set the default position and size\n  const [place, setPlace] = useState(() => {\n    // Set an extra margin\n    const MARGIN = 20;\n    // Get the screen pixel sizes and vertical scroll position\n    const { innerWidth, innerHeight, scrollY } = window;\n    // The spawned elements are parented to the 'main' element, not to the 'body'\n    // We have to take this in count, since the header adds an extra offset in vertical position\n    const offsetHeight = document.querySelector('main').offsetTop;\n    // Set a reasonable dimension for the ngl window\n    const dimension = Math.max(\n      Math.min(innerWidth / 4, innerHeight / 4),\n      MIN_NGL_DIMENSION,\n    );\n    const reasonableHeight = 1.5 * dimension;\n    const reasonableWidth = 2 * dimension;\n    return {\n      // WARNING: If you set the width as 'auto' the window stays very wide when exiting fullscreen\n      width: reasonableWidth, // Let the Rnd logic set the width automatically\n      height: reasonableHeight, // Reasonable height\n      x: 0, // Left border\n      y: innerHeight - offsetHeight - reasonableHeight - MARGIN + scrollY, // Bottom border\n    };\n  });\n\n  return (\n    // Rnd is the draggable and resizable system where the ngl viewer is placed\n    <Rnd\n      position={{ x: place.x, y: place.y }}\n      size={{ width: place.width, height: place.height }}\n      // Update the zIndex to make this window the first visible\n      style={{ zIndex: nextZ() }}\n      className={style.rnd}\n      data-rnd\n      // Limits where the window can be dragged/resized to\n      // WARNING: bounds=\"main\" is problematic since the window may appear out of bounds\n      // WARNING: Then when it is moved for the first time it jumps inside the bonds, not elegant\n      bounds=\"window\"\n      // Prevent the mouse to drag/resize the window when it is over specific elements\n      cancel=\"canvas, [data-popover], #preventDragSize\"\n      // On drag/resize starts we do not change anything, but use the hook to re-render this component\n      // The Z Index is updated and the selected window becomes the first in the z axis automatically\n      // WARNING: Drag functions are also called when you just click (e.g. clicking buttons)\n      onDragStart={() => {\n        setPlace({ ...place });\n      }}\n      onResizeStart={() => {\n        setPlace({ ...place });\n      }}\n      onDragStop={(e, d) => {\n        // Use this to reject some bugged event calls: e.g. the frames number selector\n        if (e.layerX === 0 && e.layerY === 0) return;\n        // We re-render only if the new position does not equal the old position\n        if (place.x !== d.x || place.y !== d.y)\n          setPlace({\n            ...place,\n            x: d.x,\n            y: d.y,\n          });\n      }}\n      // Re-adapt the viewer and update the position/size when the window is resized\n      onResize={() => viewerRef.current && viewerRef.current.autoResize()}\n      onResizeStop={(e, direction, ref, delta, position) => {\n        setPlace({\n          width: ref.style.width,\n          height: ref.style.height,\n          ...position,\n        });\n        // if (!viewerRef.current) return;\n        // viewerRef.current.autoResize();\n        // viewerRef.current.autoResize.flush();\n      }}\n    >\n      <Card className={style['floating-card']} elevation={4}>\n        <Suspense fallback={null}>\n          <ViewerWithControls\n            className={style['floating-card']}\n            ref={viewerRef}\n            startsPlaying={false}\n            {...props}\n          />\n        </Suspense>\n      </Card>\n    </Rnd>\n  );\n};\n\nexport default ViewerSpawner;\n","// Function involved in getting text pixels width\n// WARNING: These functions do not work properly in Chrome (not an easy problem)\n\n// This function allows to calculate the width of a given string text\n// The font for the calculation in the d3 default font\nexport const getTextWidth = (text, font = 'bold 10px sans-serif') => {\n  const canvas =\n    getTextWidth.canvas ||\n    (getTextWidth.canvas = document.createElement('canvas'));\n  const context = canvas.getContext('2d');\n  context.font = font;\n  const metrics = context.measureText(text);\n  return metrics.width;\n};\n\n// Alternative way to obtain text width\n// Probably the only way to obtain text height\nexport const getTextSizeDOM = (text, font = 'bold 10px sans-serif') => {\n  const element = document.createElement('div');\n  const content = document.createTextNode(text);\n  element.appendChild(content);\n  Object.assign(element.style, {\n    font: font,\n    position: 'absolute',\n    visibility: 'hidden',\n    height: 'auto',\n    width: 'auto',\n    'white-space': 'nowrap',\n  });\n  document.body.appendChild(element);\n  return { width: element.clientWidth, height: element.clientHeight };\n};\n\n// Get the whole body width\nexport const getBodyWidth = () => {\n  return Math.max(\n    document.body.scrollWidth,\n    document.documentElement.scrollWidth,\n    document.body.offsetWidth,\n    document.documentElement.offsetWidth,\n    document.documentElement.clientWidth,\n  );\n};\n\n// Get the whole body height\nexport const getBodyHeight = () => {\n  return Math.max(\n    document.body.scrollHeight,\n    document.documentElement.scrollHeight,\n    document.body.offsetHeight,\n    document.documentElement.offsetHeight,\n    document.documentElement.clientHeight,\n  );\n};\n","// Set the most suitable position for a tooltip\n// Use the parent element to set the limits where this tooltip may be\n// Use the tooltip element to get the suze of the tooltip\n// Use the reference position (e.g. mouse position) to place the tooltip\n// The offset is the pixels of separation between the reference and the tooltip\n// The idea is that the tooltip may be over/under and left/right of the reference position\n// It depends on how close to each limit is the reference position\nexport const setTooltipPosition = (parent, tooltip, reference, offset = 0) => {\n  const limits = parent.getBoundingClientRect();\n  const size = tooltip.getBoundingClientRect();\n  let x = reference.x;\n  // If it is more at the right side\n  if (Math.abs(limits.left - x) > Math.abs(x - limits.right)) {\n    const xSize = size.right - size.left;\n    x -= offset + xSize;\n  }\n  // If it is more at the left side\n  else {\n    x += offset;\n  }\n  // After this, apply the parent offset\n  x -= limits.left;\n  let y = reference.y;\n  // If it is more at the bottom side\n  if (Math.abs(limits.top - y) > Math.abs(y - limits.bottom)) {\n    const ySize = size.bottom - size.top;\n    y -= offset + ySize;\n  }\n  // If it is more at the top side\n  else {\n    y += offset;\n  }\n  // After this, apply the parent offset\n  y -= limits.top;\n  // Return the coordinates\n  return { x, y };\n};\n"],"names":["KEYFRAMES","opacity","reducedMotion","transform","ANIMATION_OPTIONS","fill","easing","duration","forwardRef","_ref","ref","overrideComponent","props","containerRef","useRef","useLayoutEffect","node","current","firstElementChild","animate","index","Array","from","document","querySelectorAll","findIndex","section","animation","delay","cancel","Component","Card","_jsx","className","style","children","component","title","maxValue","minValue","colorPlan","splits","vertical","legendData","legendLabels","useMemo","values","push","i","map","val","Math","round","length","decimal","Set","size","v","_jsxs","CardContent","D3HeatmapGrid","data","xAxisValues","yAxisValues","flippedXAxisValues","defaultD3font","titlesD3font","memo","xAxisLabel","yAxisLabel","verticalPadding","colorScale","onTooltip","onClick","margin","top","right","bottom","left","Error","console","log","keys","concat","maxv","max","minv","min","xlabs","ylabs","lab","fdata","x","y","previousCharts","setCurrentWindow","useState","textHeight","getTextSizeDOM","height","labelsHeight","maxXAxisWidth","label","getTextWidth","maxYAxisWidth","xAxisLabelHegiht","yAxisLabelHegiht","requiredXOffset","requiredYOffset","offset","useEffect","forEach","chart","remove","container","clientWidth","width","clientHeight","parentElement","bodyWidth","bodyHeight","xSlots","ySlots","xstep","ceil","ystep","canvasElement","createElement","select","appendChild","canvas","attr","undefined","canvasContext","getContext","svg","append","scaleBand","range","domain","paddingInner","xAxis","call","axisBottom","tickFormat","d","selectAll","text","padding","axisLeft","myColor","scaleLinear","cellWidth","bandwidth","cellHeight","row","cy","yPosition","value","cx","xPosition","fillStyle","fillRect","getMousePosition","e","canvasRect","getBoundingClientRect","clientX","clientY","xIndex","floor","step","yIndex","xLimit","yLimit","xAxisValue","yAxisValue","tooltip","Object","assign","display","position","pointerEvents","backgroundColor","color","fontFamily","onmousemove","mousePosition","innerText","xTooltipPosition","yTooltipPosition","setTooltipPosition","onmouseleave","onmousedown","handleResize","innerWidth","window","innerHeight","addEventListener","removeEventListener","id","String","fromCharCode","inputData","xMaxCells","yMaxCells","legendTitle","xTitle","yTitle","xLabels","yLabels","rData","rxLabels","ryLabels","xLength","yLength","summarizedIndexes","u","error","convertMousePosition","_ref2","Suspense","fallback","ColorLegend","residueOptions","interactions","selectedInteraction","setSelectedInteraction","selectedResidues","setSelectedResidues","selectedOrder","handleToggleOrder","firstOrderLabel","firstOrderTooltip","secondOrderLabel","secondOrderTooltip","toggleOrderTooltip","interfaceOnly","currentInteraction","Loading","Select","onChange","event","target","interaction","MenuItem","name","RadioGroup","opt","FormControlLabel","control","Radio","disabled","_Fragment","TextField","agent_1","agent_2","IconButton","changeOrder","FontAwesomeIcon","icon","faExchangeAlt","ViewerWithControls","lazy","maxZ","NGLViewerInDND","viewerRef","place","setPlace","scrollY","offsetHeight","querySelector","offsetTop","dimension","reasonableHeight","Rnd","zIndex","bounds","onDragStart","onResizeStart","onDragStop","layerX","layerY","onResize","autoResize","onResizeStop","direction","delta","elevation","startsPlaying","newViewer","nailing","onNail","onClose","nailedViewers","setNailedViewers","viewers","usedIds","getNewId","indexOf","close","nailed","newNailed","splice","nail","viewer","font","arguments","context","measureText","element","content","createTextNode","visibility","body","parent","reference","limits","abs"],"sourceRoot":""}