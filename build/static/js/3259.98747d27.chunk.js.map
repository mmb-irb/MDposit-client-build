{"version":3,"file":"static/js/3259.98747d27.chunk.js","mappings":"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","sources":["pages/accession/sasa/index.js","webpack://mdposit/./src/pages/accession/sasa/style.module.css?0b8d"],"sourcesContent":["import React, {\n  Suspense,\n  useState,\n  useContext,\n  useMemo,\n  useCallback,\n  useRef,\n} from 'react';\nimport { useInView } from 'react-intersection-observer';\n\nimport { Typography } from '@mui/material';\n\nimport { color as d3color, scaleLinear } from 'd3';\n\nimport Card from '../../../components/animated-card';\nimport ViewerWithControls from '../../../components/viewer-with-controls';\nimport Loading from '../../../components/loading';\n\nimport useAPI from '../../../hooks/use-api';\n\nimport { ProjectCtx } from '../../../contexts';\n\nimport { BASE_PATH_PROJECTS } from '../../../utils/constants';\n\nimport style from './style.module.css';\n\n//import Selector from '../../../components/selector';\n\nimport { ColormakerRegistry } from 'ngl';\n\nimport ResidueSelector from '../../../components/residue-selector';\n\nimport Graph from '../../../components/graph';\n\n// Define permanent options for the \"useInView\"\nconst useInViewOptions = { triggerOnce: true, rootMargin: '100px' };\n\n// Set the color of each residue in the NGL representation\n// WARNING: Grey looks better than white because the background may be white and resdiues are hard to see\nconst nglColorPlan = ['grey', 'yellow', 'red'];\n\n// Set the custom highlighted types\n// In this analysis, since the default representation is spacefill, all highligths must be spacefill\n// Otherwise they would be eclipsed by the base representation\nconst highlightTypes = {\n  atoms: 'spacefill',\n  residues: 'spacefill',\n  chains: 'spacefill',\n  selections: 'spacefill',\n};\n\nconst Sasa = () => {\n  // Track if the NGL viewer\n  // The status isNglVisible is returned true/false when the element is in/out the screen respectively\n  const [nglRef, isNglVisible] = useInView(useInViewOptions);\n\n  // Get the current project data\n  const {\n    accessionAndMdNumber,\n    metadata,\n    topology,\n    // Use populations to calculate mean SAS values\n    // Frames which represent a higher populated state have a stronger weight in the calculation\n    populations,\n  } = useContext(ProjectCtx);\n\n  // Get the default representations\n  const defaultRepresentations = topology && topology.defaultRepresentations;\n\n  // Set a ref to the ngl which allows access to its exposed methods\n  const viewerRef = useRef(null);\n  // Set a ref to the graph which allows access to its exposed methods\n  const graphRef = useRef(null);\n\n  // Send a request to the API with the url of the specific analysis\n  const { loading, payload, error } = useAPI(\n    `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/analyses/sasa/`,\n  );\n\n  // Set when one point in the graph is selected\n  const [selectedResidues, setSelectedResidues] = useState([]);\n\n  // Get the residues list in model notation\n  const {\n    components,\n    representations,\n    framesNumber,\n    xAxisStep,\n    xAxisLabel,\n    isEnsemble,\n    xTooltip,\n    xWeights,\n    data,\n  } = useMemo(() => {\n    // If we are sting waiting for data to load then stop here\n    if (!topology || !metadata || !payload || (populations && populations.loading))\n      return {};\n\n    // Check data to be coherent\n    // Note that sasa analysis must always have the same number of residues that the topology\n    const residueCount = topology.residueCount;\n    if (residueCount !== payload.saspf.length) throw new Error(\n      `Number of residues in the analysis (${\n        payload.saspf.length\n      }) does not match number of residues in the topology (${\n        residueCount\n      })`,\n    );\n\n    // Duplicate the payload data but removing a few values\n    // Data from single atom residues (i.e. ions) is discarded since they may raise the maximum SAS a lot\n    // Note that sasa analysis will always have the same number of residues that the topology\n    // Excluded residues (e.g. membrane residues) have null in all its values\n    const data = { saspf: [], means: [], stdvs: [] };\n    for (let r = 0; r < residueCount; r++) {\n      //const atomCount = topology.getResidueByIndex(r).atomCount;\n      //if (atomCount === 1) {\n      const residueClassification = topology.getResidueByIndex(r).classification;\n      if (residueClassification === 'ion') {\n        data.saspf[r] = null;\n        data.means[r] = null;\n        data.stdvs[r] = null;\n      } else {\n        data.saspf[r] = payload.saspf[r];\n        data.means[r] = payload.means[r];\n        data.stdvs[r] = payload.stdvs[r];\n      }\n    }\n\n    // Find out if there is an unique residue with data and, if so, find its residue index\n    let uniqueResidue;\n    for (let r = 0; r < residueCount; r++) {\n      if (data.saspf[r]) {\n        if (uniqueResidue === undefined) uniqueResidue = r;\n        else {\n          uniqueResidue = null;\n          break;\n        }\n      }\n    }\n\n    // If there is one residue only with sas data then select it already\n    // This is useful for when we have a ligand alone, for instance\n    if (uniqueResidue !== null)\n      setSelectedResidues([{ color: 'black', index: uniqueResidue }]);\n\n    // Calculate the mean and standard deviation of each residue saspf\n    // Also get the maximum and minimum means\n    const means = data.means;\n    const max = Math.max(...means);\n    const min = Math.min(...means);\n\n    // Set the color scale according to the maximum and minimum means\n    const nglColorScale = scaleLinear()\n      .range(nglColorPlan)\n      .domain([min, (min + max) / 2, max]);\n\n    // Set each residue color in the ngl representation according to the color cale\n    // WARNING: Grey looks better than white because the background is white and the structure is easier to see\n    const colorScheme = ColormakerRegistry.addScheme(function(params) {\n      this.atomColor = atom => {\n        // Find the residue index and then the entropy for this residue\n        const residueIndex = atom.residueIndex;\n        const residueClassification = topology.getResidueByIndex(residueIndex).classification;\n        // Single atom residues (i.e. ions) are discarded since they may raise the maximum SAS a lot\n        if (residueClassification === 'ion') return 16777215;\n        const mean = means[residueIndex];\n        if (mean === null) return 16777215;\n        // Calculate the interpolated rgb for this value\n        // The interpolated color comes in rbg format\n        const hexColor = d3color(nglColorScale(mean)).formatHex();\n        // The color interpolation returns a string like '#000000'\n        // We remove the first character ('#') and parse it to integer from hexadecimal\n        const color = parseInt(hexColor.substring(1), 16);\n        return color;\n      };\n    });\n\n    // Get the frames step from the analysis itself\n    const frameStep = payload['step'];\n\n    // Load the required frames from the main trajectory\n    const trajectoryUrl = `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/files/trajectory`;\n    const mainURL = `${trajectoryUrl}?frames=1:${metadata.mdFrames}:${frameStep}`;\n\n    // Set the components by setting a custom component with an extended trajectory\n    const components = [ { trajectoryURLs: [mainURL] } ];\n\n    // Set the representations by showing all default representations repainted\n    const representations = [];\n    defaultRepresentations.forEach(representation => {\n      const newRepresentation = { ...representation };\n      newRepresentation.color = 'custom';\n      newRepresentation.customScheme = colorScheme;\n      newRepresentation.type = 'spacefill';\n      representations.push(newRepresentation);\n    });\n\n    // Get the number of frames in the analysis from the a sample residue data\n    const sampleResidueData = data.saspf.find(residueData => residueData !== null);\n    const framesNumber = sampleResidueData.length;\n\n    // Get the total time length\n    const timeLength = metadata.timeLength;\n    // If this is an ensemble or we are missing the time length then we use frames as the x axis\n    // If this is a trajectory and we have the time length then we use time as the x axis\n    const isEnsemble = metadata.TYPE === 'ensemble';\n    let xAxisStep;\n    let xAxisLabel;\n    let xTooltip;\n    if (isEnsemble || !timeLength) {\n      xAxisStep = frameStep;\n      xAxisLabel = 'Frames';\n      xTooltip = xValue => 'frame ' + xValue;\n    }\n    else {\n      xAxisStep = timeLength / (framesNumber - 1);\n      xAxisLabel = 'Time (ns)';\n      xTooltip = xValue => +xValue.toFixed(2) + ' ns';\n    }\n    // Get the weigths for each data value corresponding frame\n    let xWeights;\n    if (populations && populations.payload) {\n      xWeights = [];\n      for (let i = 0; i < populations.payload.length; i += xAxisStep) {\n        xWeights.push(populations.payload[i]);\n      }\n    }\n\n    return {\n      components,\n      representations,\n      framesNumber,\n      xAxisStep,\n      xAxisLabel,\n      isEnsemble,\n      xTooltip,\n      xWeights,\n      data,\n    };\n  }, [\n    payload,\n    topology,\n    metadata,\n    accessionAndMdNumber,\n    defaultRepresentations,\n    populations,\n    setSelectedResidues\n  ]);\n\n  // Get the residues list in model notation\n  const { selectedData, selectedResidueIndices } = useMemo(() => {\n    // Now get only the selected residues\n    const selectedData = {};\n    const selectedResidueIndices = [];\n    // Color the first selected residues in the graph\n    selectedResidues.forEach((residue, i) => {\n      const currentResidueData = data.saspf[residue.index];\n      const newData = { data: currentResidueData };\n      newData.color = residue.color;\n      selectedData[i] = newData;\n      selectedResidueIndices.push(residue.index);\n    });\n    return { selectedData, selectedResidueIndices };\n  }, [data, selectedResidues]);\n\n  // When the user clicks on the graph\n  const handleFrameSelection = useCallback(frame => {\n    viewerRef.current.togglePlaying(false);\n    viewerRef.current.currentFrame = frame;\n  }, []);\n\n  // When the ngl is playing\n  const handleFrameProgress = useCallback(\n    progress => {\n      if (!graphRef.current) return;\n      // Process is a float number which ranges from 0 to 1\n      // Guess the frame number which belongs to the process\n      // WARNING: The follwoing multiplication must return always a whole number\n      // WARNING: This 'round' is only for the float problem (e.g. 57 = 56.9999...)\n      //console.log('SASA frameCount: ' + framesNumber);\n      const frame = Math.round(progress * (framesNumber - 1));\n      graphRef.current.marks = [\n        {\n          x: frame,\n          attr: { fill: '#c8c8c8' },\n        },\n      ];\n    },\n    [framesNumber],\n  );\n\n  // When a residue is selected\n  const handleSelect = useCallback(\n    (residue, residueIndex, color) => {\n      const selectedResidue = { color, index: residueIndex };\n      setSelectedResidues(previous => [...previous, selectedResidue]);\n    },\n    [setSelectedResidues],\n  );\n  // When a residue is deselected\n  const handleDeselect = useCallback(\n    (residue, residueIndex) => {\n      setSelectedResidues(previous =>\n        previous.filter(residue => residue.index !== residueIndex),\n      );\n    },\n    [setSelectedResidues],\n  );\n  // When the clean all residues button is clicked\n  const handleClean = useCallback(() => {\n    setSelectedResidues([]);\n  }, [setSelectedResidues]);\n\n  // Handle what to write on the tooltip when the user hovers a specific residue letter\n  const handleTooltip = useCallback(\n    (residue, residueIndex) => {\n      const currentResidueMean = data.means[residueIndex];\n      const currentResidueStdv = data.stdvs[residueIndex];\n      const meanSAS = Math.round(currentResidueMean * 100) / 100;\n      const stdvSAS = Math.round(currentResidueStdv * 100) / 100;\n      return `Mean SAS: ${meanSAS}\\nStandard deviation: ${stdvSAS}`;\n    },\n    [data],\n  );\n\n  // Render loading or error messages according with the API response\n  if (loading || (populations && populations.loading)) return <Loading />;\n  else if (error) return error.toString();\n  else if (populations && populations.error)\n    return populations.error.toString();\n  else if (!payload) return 'Something bad happened';\n  else if (populations && !populations.payload)\n    return 'Something bad happened with populations';\n\n  if (!topology || !metadata) return <Loading />;\n\n  // Render\n  return (\n    <Suspense fallback={<Loading />}>\n      {topology.residueCount > 1 && <Card>\n        <ResidueSelector\n          residueValues={data.means}\n          legendTitle={'Average Relative SAS (Å²)'}\n          onSelect={handleSelect}\n          onDeselect={handleDeselect}\n          onClean={handleClean}\n          onTooltip={handleTooltip}\n        />\n      </Card>}\n      <Card className={style.graphcard}>\n        {selectedResidues.length > 0 ? (\n          <Graph\n            yData={selectedData}\n            step={xAxisStep}\n            xAxisLabel={xAxisLabel}\n            yAxisLabel={'Relative SAS (Å²)'}\n            type={isEnsemble ? 'dots' : 'line'}\n            xWeights={xWeights}\n            xTooltip={xTooltip}\n            onSelect={handleFrameSelection}\n            className={style.graph}\n            ref={graphRef}\n          />\n        ) : (\n          <div className={style['graph-placeholder']}>\n            <Typography variant=\"h6\">No residue selected</Typography>\n          </div>\n        )}\n      </Card>\n      <Card className={style.nglcard} ref={nglRef}>\n        {/* Render the NGL viewer when it is on screen*/}\n        {isNglVisible ? (\n          <ViewerWithControls\n            className={style.container}\n            startingComponents={components}\n            startingRepresentations={representations}\n            selectedResidueIndices={selectedResidueIndices}\n            onProgress={handleFrameProgress}\n            ref={viewerRef}\n            framesSelect={false}\n            highlightTypes={highlightTypes}\n          />\n        ) : (\n          <div style={{ height: '50vh' }} />\n        )}\n      </Card>\n    </Suspense>\n  );\n};\n\nexport default Sasa;\n","// extracted by mini-css-extract-plugin\nexport default {\"graphcard\":\"style_graphcard__Cgh8H\",\"graph\":\"style_graph__rikGP\",\"graph-placeholder\":\"style_graph-placeholder__ef29F\",\"nglcard\":\"style_nglcard__lD0br\",\"container\":\"style_container__lvt9H\"};"],"names":["useInViewOptions","triggerOnce","rootMargin","nglColorPlan","highlightTypes","atoms","residues","chains","selections","Sasa","nglRef","isNglVisible","useInView","accessionAndMdNumber","metadata","topology","populations","useContext","ProjectCtx","defaultRepresentations","viewerRef","useRef","graphRef","loading","payload","error","useAPI","BASE_PATH_PROJECTS","selectedResidues","setSelectedResidues","useState","components","representations","framesNumber","xAxisStep","xAxisLabel","isEnsemble","xTooltip","xWeights","data","useMemo","residueCount","saspf","length","Error","means","stdvs","r","getResidueByIndex","classification","uniqueResidue","undefined","color","index","max","Math","min","nglColorScale","scaleLinear","range","domain","colorScheme","ColormakerRegistry","addScheme","params","this","atomColor","atom","residueIndex","mean","hexColor","d3color","formatHex","parseInt","substring","frameStep","trajectoryURLs","mdFrames","forEach","representation","newRepresentation","customScheme","type","push","find","residueData","timeLength","TYPE","xValue","toFixed","i","selectedData","selectedResidueIndices","residue","newData","handleFrameSelection","useCallback","frame","current","togglePlaying","currentFrame","handleFrameProgress","progress","round","marks","x","attr","fill","handleSelect","selectedResidue","previous","handleDeselect","filter","handleClean","handleTooltip","currentResidueMean","currentResidueStdv","_jsx","Loading","toString","_jsxs","Suspense","fallback","children","Card","ResidueSelector","residueValues","legendTitle","onSelect","onDeselect","onClean","onTooltip","className","style","graphcard","Graph","yData","step","yAxisLabel","graph","ref","Typography","variant","nglcard","ViewerWithControls","container","startingComponents","startingRepresentations","onProgress","framesSelect","height"],"sourceRoot":""}