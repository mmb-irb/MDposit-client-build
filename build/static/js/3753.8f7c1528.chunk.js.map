{"version":3,"file":"static/js/3753.8f7c1528.chunk.js","mappings":"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","sources":["webpack://mdposit/./src/components/interaction-selector/style.module.css?5392","components/interaction-selector/index.js","components/ngl-viewer/use-default-representations/index.js","pages/accession/rmsd-pairwise/index.js","webpack://mdposit/./src/components/viewer-spawner/style.module.css?df6e","components/viewer-spawner/index.js","webpack://mdposit/./src/pages/accession/rmsd-pairwise/style.module.css?bc81","hooks/use-remfo/index.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"horizontal\":\"style_horizontal__2DIWx\",\"horizontal-margined\":\"style_horizontal-margined__e9fQR\"};","import React, { Suspense } from 'react';\n\nimport {\n  FormControlLabel,\n  Radio,\n  RadioGroup,\n  Select,\n  MenuItem,\n  TextField,\n  IconButton,\n} from '@mui/material';\n\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faExchangeAlt } from '@fortawesome/free-solid-svg-icons';\n\nimport Loading from '../loading';\n\nimport style from './style.module.css';\n\nconst residueOptions = [\n  { label: 'All residues', value: 'residue_indices' },\n  { label: 'Interface residues', value: 'interface_indices' },\n];\n\n// Render a panel which allows to select the desired interaction\n// If the user selects a new interaction then the 'setSelectedInteraction' is set as its index\n// Interactions have the following structure:\n// { name: string, label: string, ... }\n// The 'label' field will replace the 'name' in the selector labels if exists\n// When 'selectedResidues' is passed, render also tools to select interaction residues\n// Residue options are 'all' or 'interface' residues\n// DANI: La guinda sería un 'custom' en las opciones de residuos\n// DANI: La idea sería desplegar dos residue selectors, uno para cada interaction agent\nconst InteractionSelector = ({\n  interactions,\n  selectedInteraction,\n  setSelectedInteraction,\n  selectedResidues,\n  setSelectedResidues,\n  selectedOrder,\n  handleToggleOrder,\n  firstOrderLabel, // The label to be represented over the first order rectangle\n  firstOrderTooltip, // The tooltip to be shown for the first order rectangle\n  secondOrderLabel, // The label to be represented over the second order rectangle\n  secondOrderTooltip, // The tooltip to be shown for the second order rectangle\n  toggleOrderTooltip, // The tooltip to be shown for the toggle order button\n  interfaceOnly = false, // Set if the 'All residues' button is enabled\n}) => {\n  const changeInteraction = event => {\n    setSelectedInteraction(event.target.value);\n  };\n\n  const changeResidues = event => {\n    setSelectedResidues(event.target.value);\n  };\n\n  const changeOrder = () => {\n    handleToggleOrder();\n  };\n\n  const currentInteraction = interactions[selectedInteraction];\n\n  // Render\n  return (\n    <Suspense fallback={<Loading />}>\n      <Select\n        value={selectedInteraction}\n        onChange={changeInteraction}\n        className={style['horizontal-margined']}\n      >\n        {interactions.map((interaction, i) => (\n          <MenuItem key={i} value={i} disabled={interaction.failed}>\n            {interaction.label || interaction.name}\n          </MenuItem>\n        ))}\n      </Select>\n      {selectedResidues && (\n        <RadioGroup\n          value={selectedResidues}\n          onChange={changeResidues}\n          className={style.horizontal}\n        >\n          {residueOptions.map((opt, i) => (\n            <FormControlLabel\n              key={i}\n              value={opt.value}\n              control={<Radio color=\"primary\" />}\n              label={opt.label}\n              disabled={opt.label === 'All residues' && interfaceOnly}\n            />\n          ))}\n        </RadioGroup>\n      )}\n      {selectedOrder !== undefined && (\n        <>\n          <TextField\n            //margin=\"dense\"\n            label={firstOrderLabel}\n            title={firstOrderTooltip}\n            value={\n              selectedOrder\n                ? currentInteraction.agent_1\n                : currentInteraction.agent_2\n            }\n          />\n          <IconButton\n            title={toggleOrderTooltip}\n            onClick={changeOrder}\n            size=\"large\"\n          >\n            <FontAwesomeIcon icon={faExchangeAlt} />\n          </IconButton>\n          <TextField\n            //margin=\"dense\"\n            label={secondOrderLabel}\n            title={secondOrderTooltip}\n            value={\n              selectedOrder\n                ? currentInteraction.agent_2\n                : currentInteraction.agent_1\n            }\n          />\n        </>\n      )}\n    </Suspense>\n  );\n};\n\nexport default InteractionSelector;\n","// React logic\nimport { useMemo, useContext } from 'react';\n\nimport { ProjectCtx } from '../../../contexts';\n\nimport { generateRanges } from 'src/utils/auxiliar-functions';\n\n// Use this hook to get the memoized NGL default representations\nconst useDefaultRepresentations = () => {\n  // Get current project data\n  const { topology } = useContext(ProjectCtx);\n  // Set the chains to be represented in the NGL viewer by default\n  const defaultRepresentations = useMemo(() => {\n    // If there is no topology yet then return here and wait for data to be downloaded\n    if (!topology) return [];\n    // Set a list to store all final representations\n    const reps = [];\n    // Iterate the different chains\n    // Every representation, no matter the type, will be organized as one per chain\n    topology.iterchains().forEach(chain => {\n      // Set the chain label\n      const metadataChainName = chain.metadataChainName\n      const chainLabel = metadataChainName\n        ? `${metadataChainName} (Chain ${chain.name})`\n        : `Chain ${chain.name}`;\n      // Get residues in the current chain\n      const chainResidues = chain.residues;\n      // 1. Polymers such as proteins and nucleic acids\n      // Represent polymers in cartoon and colored by chain\n      // Note that coarse grain (CG) residues will not be propery represented in cartoon\n      // For this reason we must create a separated representation for them in spacefill (vdw)\n      const respresentPolymer = polymer => {\n        // Start by classify residues (note that this logic is actually run only once and then stored)\n        const residues = chainResidues.filter(residue => residue.classification === polymer);\n        if (residues.length === 0) return;\n        // First of all handle coarse grain residues\n        const cgResidues = residues.filter(residue => residue.isCg);\n        if (cgResidues.length > 0) {\n          const cgResiduesIndices = cgResidues.map(residue => residue.index);\n          const { rangedSelection: nglSelection } = topology.residueIndices2Ngl(cgResiduesIndices);\n          // Set the new representation\n          reps.push({\n            name: `${chainLabel} - ${polymer} polymer (coarse grain)`,\n            selection: nglSelection,\n            type: 'spacefill',\n            color: 'chainid',\n          });\n        }\n        // Now keep going with the all atom residues\n        const aaResidues = residues.filter(residue => !residue.isCg);\n        // Get ranges of residue indices in a row\n        const aaResiduesIndices = aaResidues.map(residue => residue.index);\n        const ranges =  [ ...generateRanges(aaResiduesIndices) ];\n        // Those regions with 3 residues or less are not representable by cartoon (NGL limitation)\n        // Therefore, we will set an additional licorice representation for them\n        const shortRanges = ranges.filter(range => range.length <= 3);\n        if (shortRanges.length > 0) {\n          // Transform the residue indices to a NGL selection\n          const shortResidueIndices = shortRanges.reduce((ac, curr) => ac.concat(curr), []);\n          const { rangedSelection: nglSelection } = topology.residueIndices2Ngl(shortResidueIndices);\n          // Set the new representation\n          reps.push({\n            name: `${chainLabel} - ${polymer} polymer (short)`,\n            selection: nglSelection,\n            type: 'licorice',\n            color: 'chainid',\n          });\n        }\n        // The long ranges are to be displayed in cartoon\n        const longRanges = ranges.filter(range => range.length > 3);\n        if (longRanges.length > 0) {\n          // Transform the residue indices to a NGL selection\n          const longResidueIndices = longRanges.reduce((ac, curr) => ac.concat(curr), []);\n          const { rangedSelection: nglSelection } = topology.residueIndices2Ngl(longResidueIndices);\n          // Set the new representation\n          reps.push({\n            name: `${chainLabel} - ${polymer} polymer`,\n            selection: nglSelection,\n            type: 'cartoon',\n            color: 'chainid',\n          });\n          // If this is a nucleic polymer then set also a representation for its bases\n          const nucleicPolymers = new Set([ 'dna', 'rna', 'nucleic' ]);\n          if (nucleicPolymers.has(polymer)) {\n            reps.push({\n              name: `${chainLabel} - ${polymer} bases`,\n              selection: nglSelection,\n              type: 'base',\n              color: 'resname',\n            });\n          }\n        }\n      }\n      // Represent protein polymers\n      respresentPolymer('protein');\n      // Represent DNA polymers\n      respresentPolymer('dna');\n      // Represent RNA polymers\n      respresentPolymer('rna');\n      // Represent other nucleic polymers\n      respresentPolymer('nucleic');\n      // 2. Ligands, small molecules which are referenced\n      // Represent ligands in ball+stick (cpk) colored by element\n      // Start by classify residues (note that this logic is actually run only once and then stored)\n      const ligandResidues = chainResidues.filter(residue => residue.classification === 'ligand');\n      if (ligandResidues.length > 0) {\n        // In case we have more than a different ligand in this chain, set a representation for each one\n        const ligandIds = new Set(ligandResidues.map(residue => residue.referenceId));\n        for (const ligandId of ligandIds) {\n          // Get the NGL selection of traget residues\n          const currentLigandResidueIndices = ligandResidues\n            .filter(residue => residue.referenceId === ligandId)\n            .map(residue => residue.index);\n          const { rangedSelection: nglSelection } = topology.residueIndices2Ngl(currentLigandResidueIndices);\n          // Add the representation\n          reps.push({\n            name: `${chainLabel} - ligand ${ligandId}`,\n            selection: nglSelection,\n            type: 'ball+stick',\n            color: 'element'\n          });\n        }\n      }\n      // 3. Lipids, usually membranes\n      // Represent membranes in grey licorice, with a reduced oppacity\n      // Thus we ease observing what is there inside of the membrane\n      // Start by finding lipid residues\n      const lipidClasses = new Set([ 'fatty', 'steroid' ]);\n      const lipidResidues = chainResidues.filter(residue => lipidClasses.has(residue.classification));\n      if (lipidResidues.length > 0) {\n        // Now parse them to a NGL selection\n        const lipidResidueIndices = lipidResidues.map(residue => residue.index);\n        const { rangedSelection: nglSelection } = topology.residueIndices2Ngl(lipidResidueIndices);\n        // Add the representation\n        reps.push({\n          name: `${chainLabel} - lipids`,\n          selection: nglSelection,\n          type: 'licorice',\n          color: 'grey',\n          opacity: 0.5,\n        });\n      }\n      // 4. Ions, single atoms\n      // Represent ions using spacefill (vdw) and colored by element\n      // Start by finding ion residues\n      const ionResidues = chainResidues.filter(residue => residue.classification === 'ion');\n      if (ionResidues.length > 0) {\n        // Now parse them to a NGL selection\n        const ionResidueIndices = ionResidues.map(residue => residue.index);\n        const { rangedSelection: nglSelection } = topology.residueIndices2Ngl(ionResidueIndices);\n        // Add the representation\n        reps.push({\n          name: `${chainLabel} - ions`,\n          selection: nglSelection,\n          type: 'spacefill',\n          color: 'element',\n        });\n      }\n      // 5. Other, anything else\n      // Residues not falling in any previous section will be represented in low opacity purple licorice\n      // This includes solvent and unknown residues (e.g. carbohydrates)\n      const otherClasses = new Set([ 'solvent', 'unknown' ]);\n      const otherResidues = chainResidues.filter(residue => otherClasses.has(residue.classification));\n      if (otherResidues.length > 0) {\n        // Now parse them to a NGL selection\n        const otherResiduesIndices = otherResidues.map(residue => residue.index);\n        const { rangedSelection: nglSelection } = topology.residueIndices2Ngl(otherResiduesIndices);\n        // Add the representation\n        reps.push({\n          name: `${chainLabel} - other`,\n          selection: nglSelection,\n          type: 'licorice',\n          color: 'purple',\n          opacity: 0.3,\n        });\n      }\n    });\n\n    return reps;\n  }, [topology]);\n\n  return defaultRepresentations;\n};\n\nexport default useDefaultRepresentations;\n","import React, { useContext, useState, useMemo, useRef } from 'react';\n\nimport { CardContent, Chip, Typography } from '@mui/material';\n\nimport useAPI from '../../../hooks/use-api';\nimport useRemfo from 'src/hooks/use-remfo';\n\nimport Card from '../../../components/animated-card';\nimport Loading from '../../../components/loading';\nimport ViewerSpawner from '../../../components/viewer-spawner';\nimport useDefaultRepresentations from '../../../components/ngl-viewer/use-default-representations';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faExclamationTriangle } from '@fortawesome/free-solid-svg-icons';\n\nimport { ProjectCtx } from '../../../contexts';\n\nimport { BASE_PATH_PROJECTS } from '../../../utils/constants';\n\nimport style from './style.module.css';\n\nimport InteractionSelector from '../../../components/interaction-selector';\nimport Heatmap from '../../../components/heatmap';\n\n// Keep constant representation references to keep them between renders\nconst REPRESENTATION_REFERENCES = {\n  base: ['First frame', 'Second frame'],\n  interface: ['First frame interface', 'Second frame interface']\n}\n\n// Set the representation colors\nconst REPRESENTATION_COLORS = {\n  base: ['red', 'blue'],\n  interface: [\n    ['orange', 'yellow'], // Agent 1\n    ['purple', 'green'], // Agent 2\n  ] \n}\n\nconst RmsdPairwise = () => {\n  // Get the current project data\n  const {\n    accessionAndMdNumber,\n    metadata,\n    interactions: defaultInteractions,\n    topology,\n  } = useContext(ProjectCtx);\n\n  // Set a ref to the ngl which allows access to the ngl viewer exposed methods\n  const viewerRef = useRef(null);\n\n  // Set the available interactions\n  // Add the 'overall' option at the beginning, as a 'no interaction' option\n  const interactions = useMemo(() => {\n    if (!defaultInteractions) return [{ name: 'Overall' }];\n    // Label all metadata interactions with the 'interface residues' ending\n    defaultInteractions.forEach(interaction => {\n      interaction.label = interaction.name + ' (interface residues)';\n    });\n    const interactions = [{ name: 'Overall' }, ...defaultInteractions];\n    return interactions;\n  }, [defaultInteractions]);\n\n  // Send a request to the API with the url of the analyses index\n  const analysesUrlBase = `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/analyses`;\n  const indexUrl = `${analysesUrlBase}/rmsd-pairwise`;\n  const { loading: indexLoading, payload: indexPayload, error: indexError } = useAPI(indexUrl);\n\n  // The interaction to be displayed\n  const [selectedInteraction, setSelectedInteraction] = useState(0);\n\n  // The newest format has 4 fields: acceptors, donors, hydrogens and hbonds\n  // The hbonds includes arrays of true and false per frame\n  const interaction = interactions && interactions[selectedInteraction];\n\n  // Get analysis data from the API\n  // Set the target interaction name\n  const { interactionName, analysisName, analysisNote } = useMemo(() => {\n    // Wait for main data to be downloaded\n    if (!interaction || !indexPayload) return {};\n    // Check if the analysis is in the old or the new format\n    const isOld = indexPayload.data !== undefined;\n    // If so, there is no target analysis name, but the whole data is already in the payload\n    if (isOld) return { interactionName: interaction.name };\n    const targetEntry = indexPayload.find(entry => entry.name === interaction.name);\n    return {\n      interactionName: interaction.name,\n      analysisName: targetEntry.analysis,\n      // Notes are very exceptional, but some analyses may have\n      analysisNote: targetEntry.note\n    };\n  }, [interaction, indexPayload]);\n\n  // Send a request to the API with the url of some specific analysis\n  const interactionAnalysisUrl = analysisName ? `${analysesUrlBase}/${analysisName}` : null;\n  const { loading, payload, error } = useAPI(interactionAnalysisUrl);\n\n  // Now set the actual dataset to be used\n  // Note that this is a compatibility layer between the old and the new system\n  const dataset = useRemfo(previous => {\n    // Wait for the download to finish\n    if (!indexPayload) return previous;\n    // Check if the analysis is in the old or the new format\n    const isOld = indexPayload.data !== undefined;\n    // If this is the new system then the dataset is the payload itself\n    if (!isOld) {\n      if (!payload) return previous;\n      return payload;\n    }\n    // If this is the old system then the dataset is in the index payload\n    const interactionData = indexPayload.data.find(entry => entry.name === interactionName);\n    if (!interactionData) return { error: `Dataset for interaction \"${interactionName}\" not found` };\n    return interactionData;\n  }, [indexPayload, payload, interactionName]);\n\n  // Process analysis data for the heatmap\n  const { rmsds, AxesValues } = useMemo(() => {\n    // Return if the dataset is not ready\n    if (!dataset) return {};\n    // Get the rmsds values\n    const rmsds = dataset.rmsds;\n    // Calculate the step\n    // DANI: Esto no es del todo correcto pero hace que los números de frames siempre cuadren\n    const dataLength = rmsds.length;\n    const AxesStep = Math.floor(metadata.mdFrames / (dataLength - 1));\n    // DANI: Esto es lo correcto\n    // DANI: En algunos análisis antiguos las frames no cuadran y hay que rehacerlos\n    //const xAxesStep = dataset.step;\n    // Calculate the frames labels\n    // These values are used for BOTH axes\n    const AxesValues = Array(dataLength)\n      .fill(undefined)\n      .map((v, i) => i * AxesStep);\n    return { rmsds, AxesValues };\n  }, [dataset, metadata]);\n\n  // The selected frames\n  const [selectedFramePair, setSelectedFramePair] = useState(null);\n\n  // Set the component state\n  const [components, setComponents] = useState(null);\n\n  // Set the components value\n  useMemo(() => {\n    // If there is no selected pair then set the components as null\n    if (!selectedFramePair) return setComponents(null);\n    // If a frame pair is selected then set the components or update them accordingly\n    setComponents(previousComponents => {\n      // If there are no previous components then set them from scratch\n      if (previousComponents === null) {\n        return selectedFramePair.map((frame, index) => ({\n          name: `Frame ${index === 0 ? 'A' : 'B'}`,\n          frame: frame\n        }));\n      }\n      // If components already exists then just update them\n      selectedFramePair.forEach((frame, index) => {\n        const previousComponent = previousComponents[index];\n        previousComponent.name = `Frame ${index === 0 ? 'A' : 'B'}`;\n        previousComponent.frame = frame;\n      });\n      return [...previousComponents];\n    });\n  }, [selectedFramePair]);\n\n  // Get the default representations\n  const defaultRepresentations = useDefaultRepresentations();\n\n  // Set the component state\n  const [representations, setRepresentations] = useState(null);\n\n  // Set the viewer representations\n  useMemo(() => {\n    // If there are no components then clear the representations and stop here\n    if (!components) return setRepresentations(null);\n    // Get the selected interaction\n    const interaction = interactions[selectedInteraction];\n    // Get also the number of the interacting agents\n    const agents = [\n      { name: interaction.agent_1, interface: interaction.interface_indices_1 },\n      { name: interaction.agent_2, interface: interaction.interface_indices_2 }\n    ];\n    // Setup every representation or update the already existing ones\n    setRepresentations(previousRepresentations => {\n      // Set a list to keep updated representations\n      const newRepresentations = [];\n      // Find out if there is a selected interaction\n      const currentInteraction = selectedInteraction > 0;\n      // Find out if there was a selected interaction in the previous representations\n      const previousInteraction = !!(previousRepresentations && previousRepresentations.find(\n        rep => rep.reference && rep.reference.includes(REPRESENTATION_REFERENCES.interface[0])));\n      // Check if there was interactions in the previous\n      // If there were no previous representations then set the default values\n      if (previousRepresentations === null) {\n        components.forEach((component, index) => {\n          // Set the overall representations\n          // In case there is no interaction selected this would be opaque\n          // In case there is an interaction selected this would be transparent (just a reference)\n          defaultRepresentations.forEach(representation => {\n            const newRepresentation = { ...representation };\n            newRepresentation.name = `${component.name} - ${representation.name}`;\n            newRepresentation.color = REPRESENTATION_COLORS.base[index];\n            newRepresentation.component = component.name;\n            newRepresentation.reference = `${REPRESENTATION_REFERENCES.base[index]} - ${representation.name}`;\n            if (currentInteraction) {\n              newRepresentation.name += ' reference';\n              newRepresentation.opacity = 0.1;\n            }\n            newRepresentations.push(newRepresentation);\n          });\n        });\n      }\n      // If representations already exist then update them\n      else {\n        components.forEach((component, index) => {\n          // Iterate the default representations\n          defaultRepresentations.forEach(representation => {\n            // Find the previous corresponding representation\n            const reference = `${REPRESENTATION_REFERENCES.base[index]} - ${representation.name}`;\n            const previousRepresentation = previousRepresentations.find(rep => rep.reference === reference);\n            if (!previousRepresentation) throw new Error(`No previous representation with reference ${reference}`);\n            // Update the representation name and component\n            const previousComponentName = previousRepresentation.name.split(' - ')[0];\n            previousRepresentation.name = previousRepresentation.name.replace(previousComponentName, component.name);\n            previousRepresentation.component = component.name;\n            // Add or remove the 'reference' tail from the name and update the opacity\n            // If we passed from no selected interaction to selected interaction\n            if (currentInteraction && !previousInteraction) {\n              previousRepresentation.name += ' reference';\n              previousRepresentation.opacity = 0.1;\n            }\n            // If we passed from selected interaction to no selected interaction\n            if (!currentInteraction && previousInteraction) {\n              previousRepresentation.name = previousRepresentation.name.replace(' reference', '');\n              previousRepresentation.opacity = 1;\n            }\n            newRepresentations.push(previousRepresentation);\n          });\n        });\n      }\n      // Set interfaces representations, each with different colors\n      if (currentInteraction) {\n        // If we did not have a selected interaction then setup representations with default values\n        if (previousInteraction === false) {\n          components.forEach((component, index) => {\n            agents.forEach((agent, agentIndex) => {\n              // Get the interaction interface, if it exists, in NGL format\n              // The default interaction (Overall) has no interface\n              const selection = agent.interface && topology.residueIndices2Ngl(agent.interface);\n              // Set the new representation\n              newRepresentations.push({\n                name: `${component.name} - ${agent.name} interface`,\n                color: REPRESENTATION_COLORS.interface[index][agentIndex],\n                selection: selection.rangedSelection,\n                type: 'licorice',\n                component: component.name,\n                reference: `${REPRESENTATION_REFERENCES.interface[index]} - ${agent.name}`\n              });\n            });\n          });\n        }\n        // Otherwise update the already existing representations\n        else {\n          components.forEach((component, index) => {\n            agents.forEach(agent => {\n              // Get the interaction interface, if it exists, in NGL format\n              // The default interaction (Overall) has no interface\n              const selection = agent.interface && topology.residueIndices2Ngl(agent.interface);\n              // Find the previous representation for interface 1\n              const reference = `${REPRESENTATION_REFERENCES.interface[index]} - ${agent.name}`;\n              const previousRepresentation = previousRepresentations.find(\n                rep => rep.reference === reference\n              );\n              // Update its name, selection and component\n              previousRepresentation.name = `${component.name} - ${agent.name} interface`;\n              previousRepresentation.selection = selection.rangedSelection;\n              previousRepresentation.component = component.name;\n              newRepresentations.push(previousRepresentation);\n            });\n          });\n        }\n      }\n      // Add previous custom representations (added by the user)\n      previousRepresentations && previousRepresentations.filter(rep => rep.custom)\n        .forEach(representation => {\n          // Update the component to target the first component\n          representation.component = components[0].name;\n          newRepresentations.push(representation);\n        });\n      // Update the representations state\n      return newRepresentations;\n    });\n  }, [\n    components,\n    topology,\n    interactions,\n    selectedInteraction,\n    defaultRepresentations,\n  ]);\n\n  // Render loading or error messages according with the API response\n  // Render loading or error messages according with the API response\n  if (indexError) return indexError.toString();\n  if (error) return error.toString();\n  if (dataset && dataset.error) return dataset.error;\n  if (!dataset) {\n    if (indexLoading || loading) return <Loading />;\n    // If there are no interactions or topology\n    if (!topology) return 'There is no topology';\n    return 'Something bad happened with the analysis data';\n  }\n\n  // Render\n  return (\n    <>\n      <Card>\n        <CardContent className={style.horizontal}>\n          <Typography variant=\"h6\">Residues selection:</Typography>\n          <InteractionSelector\n            interactions={interactions}\n            selectedInteraction={selectedInteraction}\n            setSelectedInteraction={setSelectedInteraction}\n          />\n          {selectedFramePair && (\n            <div>\n              {components && components.map((component, c) => (\n                <Chip key={c} label={'Frame ' + component.frame}\n                  style={{\n                    margin: '0.2em',\n                    backgroundColor: c === 0 ? 'red' : 'blue',\n                  }}\n                />\n              ))}\n              {selectedInteraction > 0 && components && components.map((component, c) => {\n                  // Get the interacting agents\n                  const interaction = interactions[selectedInteraction];\n                  const agents = [ interaction.agent_1, interaction.agent_2 ];\n                  // Generate a chip for every agent\n                  return agents.map((agent, a) => (\n                    <Chip key={a} label={'Frame ' + component.frame + ' - ' + agent}\n                      style={{\n                        margin: '0.2em',\n                        backgroundColor: a === 0\n                          ? c === 0\n                            ? 'orange'\n                            : 'purple'\n                          : c === 0\n                            ? 'yellow'\n                            : 'green',\n                      }}\n                    />\n                  ));\n                }\n              )}\n            </div>\n          )}\n        </CardContent>\n      </Card>\n      {analysisNote && <Card className={style.margined}>\n        <CardContent>\n          <div style={{ fontWeight: 'bold' }}>\n            <FontAwesomeIcon icon={faExclamationTriangle} size={'lg'} />\n            {' ' + analysisNote}\n          </div>\n        </CardContent>\n      </Card>}\n      <div className={indexLoading || loading ? style.disabled : style.enabled}>\n        <Card className={style.margined} id=\"heatmap\">\n          <CardContent>\n            <Heatmap\n              inputData={{\n                data: rmsds,\n                xLabels: AxesValues,\n                yLabels: AxesValues,\n              }}\n              onTooltip={({ value, xAxisValue, yAxisValue }) =>\n                `${xAxisValue} - ${yAxisValue}\\n${Math.round(value * 100) / 100} Å`\n              }\n              onClick={({ xAxisValue, yAxisValue }) =>\n                setSelectedFramePair([xAxisValue, yAxisValue])\n              }\n              legendTitle={'RMSD (Å)'}\n              maxColor={'red'}\n              minColor={'blue'}\n              xTitle={'Frames'}\n              yTitle={'Frames'}\n            />\n          </CardContent>\n        </Card>\n      </div>\n      <ViewerSpawner\n        // Set a viewer if there is selected frames\n        newViewer={components\n          ? {\n              componentsState: [components, setComponents],\n              representationsState: [representations, setRepresentations],\n              selRef: selectedFramePair,\n              viewerRef: viewerRef\n            }\n          : null\n        }\n        // If the nailed/closed viewer is the current viewer then reset the 'selected'\n        onNail={viewer =>\n          setSelectedFramePair(previous => {\n            if (viewer.selRef === previous) return null;\n            else return previous;\n          })\n        }\n        onClose={viewer =>\n          setSelectedFramePair(previous => {\n            if (viewer.selRef === previous) return null;\n            else return previous;\n          })\n        }\n      />\n    </>\n  );\n};\n\nexport default RmsdPairwise;\n","// extracted by mini-css-extract-plugin\nexport default {\"rnd\":\"style_rnd__Txifm\",\"floating-card\":\"style_floating-card__HHpby\"};","import React, { lazy, Suspense, useRef, useState } from 'react';\n\n// Rnd is the resizable and draggable system where the ngl viewer is placed\nimport { Rnd } from 'react-rnd';\n\nimport Card from '../animated-card';\n\nimport style from './style.module.css';\n\nconst ViewerWithControls = lazy(() =>\n  import(\n    /* webpackChunkName: 'viewer-with-controls' */ '../viewer-with-controls'\n  ),\n);\n\n// Minimal ngl window height\nconst MIN_NGL_DIMENSION = 150;\n\n// Counter to get always the maximum zIndex\n// This is useful to set a new or currently dragged/resized ngl window over the others\nlet maxZ = 0;\nconst nextZ = () => {\n  maxZ += 1;\n  return maxZ;\n};\n\n// This function spawns all the NGL viewers needed\n// i.e. one viewer with the requested 'props' and all previous viewers which have been nailed\nconst ViewerSpawner = ({ newViewer, nailing = true, onNail, onClose }) => {\n  // Store here all nailed NGL viewers\n  const [nailedViewers, setNailedViewers] = useState([]);\n\n  // Set the viewers as the nailed viewers and the new viewer\n  const viewers = [...nailedViewers];\n\n  // Keep listed all arrays which have been used (i.e. ngl viewers which have been nailed or closed)\n  const usedIds = useRef([]);\n\n  if (newViewer) {\n    // Find a new suitable Id that meet 2 conditions:\n    // - There is never 2 viewers with the same id, so we avoid errors\n    // - If we pick diferent frames in the graph without nailing anything, the current viewer has always the same id\n    // (This way the current viewer does not appear in the origin position every time)\n    const getNewId = () => {\n      let id = 0;\n      while (id < 999) {\n        if (usedIds.current.indexOf(id) === -1) return id;\n        id += 1;\n      }\n      console.error('Maximum number of viewers reached');\n    };\n\n    // Set a unique id for this props based in the last nailed viewer\n    newViewer.id = getNewId();\n    newViewer.close = () => {\n      if (nailing) {\n        setNailedViewers(nailed => {\n          const newNailed = [...nailed];\n          const index = nailed.indexOf(newViewer);\n          if (index !== -1) newNailed.splice(index, 1);\n          return newNailed;\n        });\n      }\n      if (onClose) onClose(newViewer);\n      usedIds.current.push(newViewer.id);\n    };\n    // If the nailer function is passed, add the logic for the viewer to be nailed further\n    if (nailing)\n      newViewer.nail = () => {\n        setNailedViewers(nailed => [...nailed, newViewer]);\n        if (onNail) onNail(newViewer);\n        usedIds.current.push(newViewer.id);\n      };\n    // Add the current viewer to the viewers list\n    viewers.push(newViewer);\n  }\n\n  // Render a viewer for each prop. Use the 'selected' parameter as unique id\n  return viewers.map(viewer => <NGLViewerInDND key={viewer.id} {...viewer} />);\n};\n\n// This component render a small NGL viewer\n// It is called when user clicks in a point in the projections component\n// Also it is called by the generic analysis page\nconst NGLViewerInDND = props => {\n  // Set a reference for the viewer\n  // If a reference is passed among the viewer arguments then use it instead\n  const viewerRef = props.viewerRef || useRef(null);\n\n  // Set the default position and size\n  const [place, setPlace] = useState(() => {\n    // Set an extra margin\n    const MARGIN = 20;\n    // Get the screen pixel sizes and vertical scroll position\n    const { innerWidth, innerHeight, scrollY } = window;\n    // The spawned elements are parented to the 'main' element, not to the 'body'\n    // We have to take this in count, since the header adds an extra offset in vertical position\n    const offsetHeight = document.querySelector('main').offsetTop;\n    // Set a reasonable dimension for the ngl window\n    const dimension = Math.max(\n      Math.min(innerWidth / 4, innerHeight / 4),\n      MIN_NGL_DIMENSION,\n    );\n    const reasonableHeight = 1.5 * dimension;\n    const reasonableWidth = 2 * dimension;\n    return {\n      // WARNING: If you set the width as 'auto' the window stays very wide when exiting fullscreen\n      width: reasonableWidth, // Let the Rnd logic set the width automatically\n      height: reasonableHeight, // Reasonable height\n      x: 0, // Left border\n      y: innerHeight - offsetHeight - reasonableHeight - MARGIN + scrollY, // Bottom border\n    };\n  });\n\n  return (\n    // Rnd is the draggable and resizable system where the ngl viewer is placed\n    <Rnd\n      position={{ x: place.x, y: place.y }}\n      size={{ width: place.width, height: place.height }}\n      // Update the zIndex to make this window the first visible\n      style={{ zIndex: nextZ() }}\n      className={style.rnd}\n      data-rnd\n      // Limits where the window can be dragged/resized to\n      // WARNING: bounds=\"main\" is problematic since the window may appear out of bounds\n      // WARNING: Then when it is moved for the first time it jumps inside the bonds, not elegant\n      bounds=\"window\"\n      // Prevent the mouse to drag/resize the window when it is over specific elements\n      cancel=\"canvas, [data-popover], #preventDragSize, .prevent-drag\"\n      // On drag/resize starts we do not change anything, but use the hook to re-render this component\n      // The Z Index is updated and the selected window becomes the first in the z axis automatically\n      // WARNING: Drag functions are also called when you just click (e.g. clicking buttons)\n      onDragStart={() => {\n        setPlace({ ...place });\n      }}\n      onResizeStart={() => {\n        setPlace({ ...place });\n      }}\n      onDragStop={(e, d) => {\n        // Use this to reject some bugged event calls: e.g. the frames number selector\n        if (e.layerX === 0 && e.layerY === 0) return;\n        // We re-render only if the new position does not equal the old position\n        if (place.x !== d.x || place.y !== d.y)\n          setPlace({\n            ...place,\n            x: d.x,\n            y: d.y,\n          });\n      }}\n      // Re-adapt the viewer and update the position/size when the window is resized\n      onResize={() => viewerRef.current && viewerRef.current.autoResize()}\n      onResizeStop={(e, direction, ref, delta, position) => {\n        setPlace({\n          width: ref.style.width,\n          height: ref.style.height,\n          ...position,\n        });\n        // if (!viewerRef.current) return;\n        // viewerRef.current.autoResize();\n        // viewerRef.current.autoResize.flush();\n      }}\n    >\n      <Card className={style['floating-card']} elevation={4}>\n        <Suspense fallback={null}>\n          <ViewerWithControls\n            className={style['floating-card']}\n            ref={viewerRef}\n            startsPlaying={false}\n            {...props}\n          />\n        </Suspense>\n      </Card>\n    </Rnd>\n  );\n};\n\nexport default ViewerSpawner;\n","// extracted by mini-css-extract-plugin\nexport default {\"widest\":\"style_widest__hZ7sO\",\"margined\":\"style_margined__GphyO\",\"margined-bottom\":\"style_margined-bottom__KpiYO\",\"horizontal\":\"style_horizontal__1xLer\",\"enabled\":\"style_enabled__Lh27c\",\"disabled\":\"style_disabled__qDRCr\"};","import { useMemo, useRef } from 'react';\n\n// Get a memoized value just like a useMemo would\n// However you can access the previous memoized value as the first (and only) function argument\nconst useRemfo = (func, deps) => {\n    const previousValue = useRef();\n    const newValue = useMemo(() => func(previousValue.current), deps);\n    previousValue.current = newValue;\n    return newValue;\n};\n\nexport default useRemfo;\n"],"names":["residueOptions","label","value","_ref","interactions","selectedInteraction","setSelectedInteraction","selectedResidues","setSelectedResidues","selectedOrder","handleToggleOrder","firstOrderLabel","firstOrderTooltip","secondOrderLabel","secondOrderTooltip","toggleOrderTooltip","interfaceOnly","currentInteraction","_jsxs","Suspense","fallback","_jsx","Loading","children","Select","onChange","event","target","className","style","map","interaction","i","MenuItem","disabled","failed","name","RadioGroup","opt","FormControlLabel","control","Radio","color","undefined","_Fragment","TextField","title","agent_1","agent_2","IconButton","onClick","changeOrder","size","FontAwesomeIcon","icon","faExchangeAlt","useDefaultRepresentations","topology","useContext","ProjectCtx","useMemo","reps","iterchains","forEach","chain","metadataChainName","chainLabel","concat","chainResidues","residues","respresentPolymer","polymer","filter","residue","classification","length","cgResidues","isCg","cgResiduesIndices","index","rangedSelection","nglSelection","residueIndices2Ngl","push","selection","type","aaResiduesIndices","ranges","generateRanges","shortRanges","range","shortResidueIndices","reduce","ac","curr","longRanges","longResidueIndices","Set","has","ligandResidues","ligandIds","referenceId","ligandId","currentLigandResidueIndices","lipidClasses","lipidResidues","lipidResidueIndices","opacity","ionResidues","ionResidueIndices","otherClasses","otherResidues","otherResiduesIndices","REPRESENTATION_REFERENCES","base","interface","REPRESENTATION_COLORS","RmsdPairwise","accessionAndMdNumber","metadata","defaultInteractions","viewerRef","useRef","analysesUrlBase","BASE_PATH_PROJECTS","indexUrl","loading","indexLoading","payload","indexPayload","error","indexError","useAPI","useState","interactionName","analysisName","analysisNote","data","targetEntry","find","entry","analysis","note","interactionAnalysisUrl","dataset","useRemfo","previous","interactionData","rmsds","AxesValues","dataLength","AxesStep","Math","floor","mdFrames","Array","fill","v","selectedFramePair","setSelectedFramePair","components","setComponents","previousComponents","frame","previousComponent","defaultRepresentations","representations","setRepresentations","agents","interface_indices_1","interface_indices_2","previousRepresentations","newRepresentations","previousInteraction","rep","reference","includes","component","representation","newRepresentation","_objectSpread","previousRepresentation","Error","previousComponentName","split","replace","agent","agentIndex","custom","toString","Card","CardContent","horizontal","Typography","variant","InteractionSelector","c","Chip","margin","backgroundColor","a","margined","fontWeight","faExclamationTriangle","enabled","id","Heatmap","inputData","xLabels","yLabels","onTooltip","xAxisValue","yAxisValue","round","_ref2","legendTitle","maxColor","minColor","xTitle","yTitle","ViewerSpawner","newViewer","componentsState","representationsState","selRef","onNail","viewer","onClose","ViewerWithControls","lazy","maxZ","NGLViewerInDND","props","place","setPlace","innerWidth","innerHeight","scrollY","window","offsetHeight","document","querySelector","offsetTop","dimension","max","min","reasonableHeight","width","height","x","y","Rnd","position","zIndex","bounds","cancel","onDragStart","onResizeStart","onDragStop","e","d","layerX","layerY","onResize","current","autoResize","onResizeStop","direction","ref","delta","elevation","startsPlaying","nailing","nailedViewers","setNailedViewers","viewers","usedIds","getNewId","indexOf","console","close","nailed","newNailed","splice","nail","func","deps","previousValue","newValue"],"sourceRoot":""}