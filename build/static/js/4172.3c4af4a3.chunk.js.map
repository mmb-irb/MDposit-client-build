{"version":3,"file":"static/js/4172.3c4af4a3.chunk.js","mappings":"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","sources":["webpack://mdposit/./src/components/animated-card/style.module.css?d4d9","components/animated-card/index.js","utils/tooltip-position-manager/index.js","webpack://mdposit/./src/components/heatmap/style.module.css?f410","../node_modules/punycode/punycode.es6.js","components/heatmap/index.js","webpack://mdposit/./src/components/color-legend/style.module.css?0c39","components/color-legend/index.js","utils/document-measurer/index.js","components/d3-heatmap-grid/index.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"container\":\"style_container__M9GCG\"};","import React, { useLayoutEffect, useRef, forwardRef } from 'react';\nimport { Card } from '@mui/material';\n\nimport reducedMotion from '../../utils/reduced-motion';\n\nimport style from './style.module.css';\n\nconst KEYFRAMES = { opacity: [0, 1] };\n\nif (!reducedMotion()) {\n  KEYFRAMES.transform = ['translateY(50px)', 'translateY(0)'];\n}\n\nconst ANIMATION_OPTIONS = {\n  fill: 'both',\n  easing: 'cubic-bezier(0, .99, .56, 1.1)',\n  duration: 500,\n};\n\n// Make the card appear and slide softly from down to up when the page is loaded\nconst AnimatedCard = forwardRef(({ overrideComponent, ...props }, ref) => {\n  const containerRef = useRef(null);\n\n  useLayoutEffect(() => {\n    const node = containerRef.current && containerRef.current.firstElementChild;\n    if (!(node && node.animate)) return;\n\n    const index = Array.from(\n      document.querySelectorAll('main section'),\n    ).findIndex(section => node === section);\n\n    const animation = node.animate(KEYFRAMES, {\n      ...ANIMATION_OPTIONS,\n      delay: index * 150,\n    });\n\n    return () => animation.cancel();\n  }, []);\n\n  const Component = overrideComponent ? 'section' : Card;\n\n  return (\n    <div ref={containerRef} className={style.container}>\n      <Component component=\"section\" {...props} ref={ref} />\n    </div>\n  );\n});\n\nexport default AnimatedCard;\n","// Set the most suitable position for a tooltip\n// Use the parent element to set the limits where this tooltip may be\n// Use the tooltip element to get the suze of the tooltip\n// Use the reference position (e.g. mouse position) to place the tooltip\n// The offset is the pixels of separation between the reference and the tooltip\n// The idea is that the tooltip may be over/under and left/right of the reference position\n// It depends on how close to each limit is the reference position\nexport const setTooltipPosition = (parent, tooltip, reference, offset = 0) => {\n  const limits = parent.getBoundingClientRect();\n  const size = tooltip.getBoundingClientRect();\n  let x = reference.x;\n  // If it is more at the right side\n  if (Math.abs(limits.left - x) > Math.abs(x - limits.right)) {\n    const xSize = size.right - size.left;\n    x -= offset + xSize;\n  }\n  // If it is more at the left side\n  else {\n    x += offset;\n  }\n  // After this, apply the parent offset\n  x -= limits.left;\n  let y = reference.y;\n  // If it is more at the bottom side\n  if (Math.abs(limits.top - y) > Math.abs(y - limits.bottom)) {\n    const ySize = size.bottom - size.top;\n    y -= offset + ySize;\n  }\n  // If it is more at the top side\n  else {\n    y += offset;\n  }\n  // After this, apply the parent offset\n  y -= limits.top;\n  // Return the coordinates\n  return { x, y };\n};\n","// extracted by mini-css-extract-plugin\nexport default {\"card\":\"style_card__ad3Ck\",\"loading\":\"style_loading__boyy5\",\"heatmap\":\"style_heatmap__03kXZ\"};","'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7F]/; // Note: U+007F DEL is excluded too.\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, callback) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = callback(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {String} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(domain, callback) {\n\tconst parts = domain.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tdomain = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tdomain = domain.replace(regexSeparators, '\\x2E');\n\tconst labels = domain.split('.');\n\tconst encoded = map(labels, callback).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = codePoints => String.fromCodePoint(...codePoints);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint >= 0x30 && codePoint < 0x3A) {\n\t\treturn 26 + (codePoint - 0x30);\n\t}\n\tif (codePoint >= 0x41 && codePoint < 0x5B) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint >= 0x61 && codePoint < 0x7B) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tconst oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\t\t\tif (digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tconst inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tconst basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue === n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.3.1',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nexport { ucs2decode, ucs2encode, decode, encode, toASCII, toUnicode };\nexport default punycode;\n","import React, { Suspense, useMemo } from 'react';\n\nimport { CardContent } from '@mui/material';\n\nimport style from './style.module.css';\n\nimport D3HeatmapGrid from '../d3-heatmap-grid';\n\nimport ColorLegend from '../color-legend';\nimport { ucs2 } from 'punycode';\n\nconst Heatmap = ({\n  // The expected data format is an complex object\n  inputData,\n  // Maximum number of x and y cells\n  xMaxCells = 110,\n  yMaxCells = 260,\n  // Function to set what text must appear in the hover tooltip\n  onTooltip,\n  // Function to be called when the user clicks in a heatmap cell\n  onClick,\n  // Title to be rendered over the legend\n  // No legend will be rendered if it is blank\n  legendTitle = '',\n  // Colors to represent the values range from lower to higher (e.g. ['red', 'white', 'blue'])\n  colorPlan,\n  // Titles for x and y axes\n  xTitle,\n  yTitle,\n  minValue: customMinValue, // Add these new props\n  maxValue: customMaxValue,\n}) => {\n  // Data processing\n  const {\n    data,\n    xLabels,\n    yLabels,\n    minValue,\n    maxValue,\n    xstep,\n    ystep,\n  } = useMemo(() => {\n    // Return if the payload is not ready\n    if (!inputData || !inputData.data || inputData.data.length === 0) return {};\n\n    // Get the data reference\n    const rData = inputData.data;\n    let rxLabels = inputData.xLabels;\n    let ryLabels = inputData.yLabels;\n\n    // Get data set x and y lengths\n    const xLength = rData[0].length;\n    const yLength = rData.length;\n\n    // Check all rows to have the same length\n    rData.forEach(row => {\n      if (row.length !== xLength)\n        throw new Error('All rows must have the same length');\n    });\n\n    const xstep = xLength / xMaxCells;\n    const ystep = yLength / yMaxCells;\n\n    // Get a reduced subset of data which respects the maximum x and y lengths\n    let data;\n    if (ystep <= 1) {\n      if (xstep <= 1) {\n        data = rData;\n      } else {\n        data = new Array(yLength);\n        const summarizedIndexes = new Array(xMaxCells);\n        for (let x = 0; x < xMaxCells; x++) {\n          summarizedIndexes[x] = Math.round(x * xstep);\n        }\n        for (let y = 0; y < yLength; y++) {\n          data[y] = summarizedIndexes.map(x => rData[y][x]);\n        }\n      }\n    } else {\n      // WARNING: Note that the list of lists has to be generated this way\n      // WARNING: If you fill the first array with an array then it will be same array for all values\n      data = new Array(yMaxCells).fill().map(u => new Array(xMaxCells).fill(null));\n      if (xstep <= 1) {\n        for (let y = 0; y < yMaxCells; y++) {\n          data[y] = rData[Math.round(y * ystep)];\n        }\n      } else {\n        for (let y = 0; y < yMaxCells; y++) {\n          const yIndex = Math.round(y * ystep);\n          for (let x = 0; x < xMaxCells; x++) {\n            const xIndex = Math.round(x * xstep);\n            data[y][x] = rData[yIndex][xIndex];\n          }\n        }\n      }\n    }\n\n    // Create 1-n labels if they are not provided\n    if (!rxLabels) rxLabels = Array.from(Array(xLength).keys());\n    if (!ryLabels) ryLabels = Array.from(Array(yLength).keys());\n\n    // Check that both lengths match as they should\n    if (xLength !== rxLabels.length)\n      console.error('Heatmap error: x labels do not match data dimensions');\n    if (yLength !== ryLabels.length)\n      console.error('Heatmap error: y labels do not match data dimensions');\n\n    // Set the heatmap labels\n    let xLabels;\n    let yLabels;\n\n    // x labels\n    if (xstep <= 1) {\n      xLabels = rxLabels;\n    } else {\n      xLabels = new Array(xMaxCells);\n      for (let i = 0; i < xMaxCells; i++)\n        xLabels[i] = rxLabels[Math.round(i * xstep)];\n    }\n\n    // y labels\n    if (ystep <= 1) {\n      yLabels = ryLabels;\n    } else {\n      yLabels = new Array(yMaxCells);\n      for (let i = 0; i < yMaxCells; i++)\n        yLabels[i] = ryLabels[Math.round(i * ystep)];\n    }\n\n    // Set the legend, which is another heatmap\n    const validValues = data.flat().filter(value => !isNaN(value));\n    const minValue = customMinValue ?? Math.min(...validValues);\n    const maxValue = customMaxValue ?? Math.max(...validValues);\n\n    // Save all processed data\n    return {\n      data: data,\n      xLabels: xLabels,\n      yLabels: yLabels,\n      minValue: minValue,\n      maxValue: maxValue,\n      xstep,\n      ystep,\n    };\n    // WARNING: Changes in 'inputData' may be not detected\n  }, [inputData, xMaxCells, yMaxCells, customMinValue, customMaxValue]);\n\n  // Render loading or error messages according with the API response\n  if (!inputData) return 'Heatmap Error: No \"inputData\" was provided';\n  if (!inputData.data || inputData.data.length === 0)\n    return 'Heatmap Error: The data field is empty or non existent';\n\n  // The main value and axes values are the same, but not the incides\n  // Since we reduced the dataset we must convert indices in order to match the original dataset\n  const convertMousePosition = ({\n    xIndex,\n    yIndex,\n    value,\n    xAxisValue,\n    yAxisValue,\n  }) => {\n    const realXIndex = xstep <= 1 ? xIndex : Math.round(xIndex * xstep);\n    const realYIndex = ystep <= 1 ? yIndex : Math.round(yIndex * ystep);\n    return {\n      xIndex: realXIndex,\n      yIndex: realYIndex,\n      value,\n      xAxisValue,\n      yAxisValue,\n    };\n  };\n\n  const handleMouseClick = e => {\n    if (!onClick) return;\n    const mousePosition = convertMousePosition(e);\n    return onClick(mousePosition);\n  };\n\n  const handleMouseTooltip = e => {\n    if (!onTooltip) return;\n    const mousePosition = convertMousePosition(e);\n    return onTooltip(mousePosition);\n  };\n\n  // Render\n  return (\n    <Suspense fallback={<div className={style.loading}>Loading...</div>}>\n      <D3HeatmapGrid\n        data={data}\n        xAxisValues={xLabels}\n        yAxisValues={yLabels}\n        colorPlan={colorPlan}\n        xAxisLabel={xTitle}\n        yAxisLabel={yTitle}\n        onClick={handleMouseClick}\n        onTooltip={handleMouseTooltip}\n        className={style.heatmap}\n        minValue={minValue}  // Add these\n        maxValue={maxValue}\n      />\n      {legendTitle && (\n        <CardContent>\n          <ColorLegend\n            title={legendTitle}\n            minValue={minValue}\n            maxValue={maxValue}\n            colorPlan={colorPlan}\n          />\n        </CardContent>\n      )}\n    </Suspense>\n  );\n};\n\nexport default Heatmap;\n","// extracted by mini-css-extract-plugin\nexport default {\"horizontal\":\"style_horizontal__KW-k9\",\"vertical\":\"style_vertical__YKrT2\",\"heatmap-horizontal\":\"style_heatmap-horizontal__HjdIF\",\"heatmap-vertical\":\"style_heatmap-vertical__utgJY\"};","import React, { useMemo } from 'react';\n\nimport { CardContent } from '@mui/material';\n\nimport style from './style.module.css';\n\nimport D3HeatmapGrid from '../d3-heatmap-grid';\n\n// Display a color legend using the d3 heatmap\nconst ColorLegend = ({\n  // Title to be rendered over the legend\n  title = '',\n  // Maximum and minimum possible values\n  maxValue = 1,\n  minValue = 0,\n  // Colors to represent the values range from lower to higher (e.g. ['red', 'white', 'blue'])\n  colorPlan,\n  // Number of cells in the legend heatmap (i.e. how many times we split the color bar)\n  splits = 19,\n  // Set if the color bar must be veritcal\n  vertical = false,\n  flip = false,\n  // Allow to force a custom className from the parent component\n  className,\n}) => {\n  // Create a fake 'data' object for the heatmap\n  const { legendData, legendLabels } = useMemo(() => {\n    // Set the legend, which is another heatmap\n    // Make labels for different value regions\n    const values = [];\n    // If the minimum and maximum are the same then there is only one label to show\n    if (minValue === maxValue) values.push(minValue);\n    // Otherwise make the different regions\n    // WARNING: If we have same minimum and maximum values then the logic below will enter in an infinite loop\n    else for (let i = minValue; i <= maxValue; i += (maxValue - minValue) / splits)\n      values.push(i);\n\n    // Round all values\n    let legendLabels = values.map(val => Math.round(val));\n    // If there is more than 1 label then the make sure all of them are unique\n    // WARNING: If we have a single label  the logic below will enter in an infinite loop\n    if (legendLabels.length > 1)\n      // If there are repeated labels then we round to the next 10 fold lower scale until there are no more duplicates\n      for (let decimal = 1; new Set(legendLabels).size < legendLabels.length; decimal++) {\n        legendLabels = values.map(val => Math.round(val * 10 ** decimal) / 10 ** decimal);\n      }\n\n    // Data must be an array inside an array\n    const legendData = vertical ? values.map(v => [v]) : [values];\n    if (flip) {\n      // Flip the legend data array\n      legendData.reverse();\n      legendLabels.reverse();\n    }\n\n    return { legendData, legendLabels };\n  }, [maxValue, minValue, splits, vertical]);\n\n  // Render\n  return (\n    <CardContent\n      className={\n        className ? className : vertical ? style.vertical : style.horizontal\n      }\n    >\n      {title}\n      <D3HeatmapGrid\n        data={legendData}\n        xAxisValues={vertical ? [''] : legendLabels}\n        yAxisValues={vertical ? legendLabels : ['']}\n        colorPlan={colorPlan}\n        flippedXAxisValues={false}\n        className={\n          vertical ? style['heatmap-vertical'] : style['heatmap-horizontal']\n        }\n      />\n    </CardContent>\n  );\n};\n\nexport default ColorLegend;\n","// Function involved in getting text pixels width\n// WARNING: These functions do not work properly in Chrome (not an easy problem)\n\n// This function allows to calculate the width of a given string text\n// The font for the calculation in the d3 default font\nexport const getTextWidth = (text, font = 'bold 10px sans-serif') => {\n  const canvas =\n    getTextWidth.canvas ||\n    (getTextWidth.canvas = document.createElement('canvas'));\n  const context = canvas.getContext('2d');\n  context.font = font;\n  const metrics = context.measureText(text);\n  return metrics.width;\n};\n\n// Alternative way to obtain text width\n// Probably the only way to obtain text height\nexport const getTextSizeDOM = (text, font = 'bold 10px sans-serif') => {\n  const element = document.createElement('div');\n  const content = document.createTextNode(text);\n  element.appendChild(content);\n  Object.assign(element.style, {\n    font: font,\n    position: 'absolute',\n    visibility: 'hidden',\n    height: 'auto',\n    width: 'auto',\n    'white-space': 'nowrap',\n  });\n  document.body.appendChild(element);\n  return { width: element.clientWidth, height: element.clientHeight };\n};\n\n// Get the whole body width\nexport const getBodyWidth = () => {\n  return Math.max(\n    document.body.scrollWidth,\n    document.documentElement.scrollWidth,\n    document.body.offsetWidth,\n    document.documentElement.offsetWidth,\n    document.documentElement.clientWidth,\n  );\n};\n\n// Get the whole body height\nexport const getBodyHeight = () => {\n  return Math.max(\n    document.body.scrollHeight,\n    document.documentElement.scrollHeight,\n    document.body.offsetHeight,\n    document.documentElement.offsetHeight,\n    document.documentElement.clientHeight,\n  );\n};\n","import React, { useRef, useEffect, useState, memo } from 'react';\n\nimport { getTextWidth, getTextSizeDOM } from '../../utils/document-measurer';\n\nimport { axisBottom, select, scaleLinear, scaleBand, axisLeft } from 'd3';\n\nimport { setTooltipPosition } from '../../utils/tooltip-position-manager';\n\n// According to d3 documentation\nconst defaultD3font = 'normal 10px sans-serif';\n// Experimentally verfied\nconst titlesD3font = 'normal 14px sans-serif';\n\n// DANI: Ni este 'memo' ni el 'useMemo' de dentro funcionan. Siempre se vuelve a calcular\n// Lo óptimo sería que funcionase, ya que cada vez que el ususario hace click todo se vuelve a cargar\n// Hay que construir una 'comparision function': https://reactjs.org/docs/react-api.html#reactmemo\n\n// Input 'data' is expected to be an array of arrays (i.e. a matrix)\nconst D3HeatmapGrid = memo(\n  ({\n    data, // The main values\n    xAxisValues = [], // String labels for the horizontal axis\n    yAxisValues = [], // String labels for the vertical axis\n    xAxisLabel, // String title for the horizontal axis\n    yAxisLabel, // String title for the vertical axis\n    verticalPadding = 0,\n    colorPlan = ['red', 'white', 'blue'],\n    colorScale, // In case a color scale is passed it overrides the max, mid and min colors\n    onTooltip, // Text to be rendered on the tooltip\n    onClick, // Function to be called when clicking on the heatmap\n    flippedXAxisValues = true, // Set if values in x axis is horizontal (false) or vertical (true)\n    margin = { top: 10, right: 10, bottom: 10, left: 10 },\n    className,\n    NaNColor = '#ffffff', // Default black color for NaN\n    minValue,\n    maxValue,\n    addBorder = true, // Add a border to each cell\n  }) => {\n    if (!data)\n      throw new Error(\n        `Data is missing. Data is mandatory for the heatmap representation`,\n      );\n    // Check that there are no duplicates in both x and y axes values\n    // WARNING: Duplicates would not make the heatmap fail, but they will result in overlaps\n    if (xAxisValues.length !== new Set(xAxisValues).size) {\n      console.log(xAxisValues);\n      throw new Error(`Duplicated values in the X axis. See console logs`);\n    }\n    if (yAxisValues.length !== new Set(yAxisValues).size) {\n      console.log(yAxisValues);\n      throw new Error(`Duplicated values in the Y axis. See console logs`);\n    }\n\n    // If any label is empty, fill it with 1-n numbers\n    if (xAxisValues.length === 0)\n      xAxisValues = Array.from(Array(data[0].length).keys());\n    if (yAxisValues.length === 0)\n      yAxisValues = Array.from(Array(data[0].length).keys());\n\n    // Convert data to heatmap friendly format\n\n    // Join all rows into a single array with all values\n    const values = [].concat(...data);\n    // Save the maximum and minimum values - excluding NaN values\n    const validValues = values.filter(value => !isNaN(value));\n    const maxv = maxValue ?? Math.max(...validValues);\n    const minv = minValue ?? Math.min(...validValues);\n    // Repeat the x labels as many times as rows are there\n    const xlabs = [].concat(...Array(data.length).fill(xAxisValues));\n    // Repeat each y label as many times as rows are there\n    const ylabs = [];\n    for (const lab of yAxisValues)\n      ylabs.push(...Array(xAxisValues.length).fill(lab));\n    // Fill an array with an object fo each d, x and y\n    const fdata = [];\n    for (const i in values) {\n      fdata.push({ v: values[i], x: xlabs[i], y: ylabs[i] });\n    }\n\n    // Set the reference to the element where the heatmap will be allocated\n    const containerRef = useRef(null);\n    // Save the previous chart reference so we can remove it before a new render\n    const previousCharts = useRef(null);\n\n    // Use a state as a workaround to force rerenders on window resize\n    const [, setCurrentWindow] = useState(null);\n\n    // ----------------------------------------------------------------------------------------\n\n    // OFFSETS: Estimate the space needed for all the labels and titles to not overlap\n\n    // Set a small offset to be added between normal labels and 90 degrees rotated labels\n    // This offset is added between the y labels (normal) and the y title (rotated)\n    // This offset is added between the x labels (rotated) and the x title (normal)\n    const roatatedTextOffset = 9; // In px\n\n    // Set a small offset to keep away the axis labels and the axis values\n    // They are very close to the axis values by default\n    const axisLabelsOffset = 9; // In px\n\n    // Measure the height of normal and text and labels\n    const textHeight = getTextSizeDOM('|', defaultD3font).height;\n    const labelsHeight =\n      getTextSizeDOM('|', titlesD3font).height + axisLabelsOffset;\n\n    // Get the calculated widths of all y labels and select the maximum\n    // In addition, add a small offset between labels and the axis which is added further\n    // This offset is only in x axes, which are rotated 90 degrees and end too much close to the axis\n    const maxXAxisWidth =\n      Math.max(\n        ...xAxisValues.map(label => getTextWidth(label, defaultD3font)),\n      ) + roatatedTextOffset;\n    // Get the calculated widths of all y labels and select the maximum\n    const maxYAxisWidth = Math.max(\n      ...yAxisValues.map(label => getTextWidth(label, defaultD3font)),\n    );\n\n    // In addition, add a small offset between labels and the axis which is added further\n    // This offset is only in x axes, which are rotated 90 degrees and end too much close to the axis\n    const xAxisLabelHegiht = xAxisLabel ? labelsHeight : 0;\n    const yAxisLabelHeight = yAxisLabel ? labelsHeight + roatatedTextOffset : 0;\n\n    // Finally, estimate the space needed by axes, titles, etc.\n    const requiredXOffset = flippedXAxisValues\n      ? maxXAxisWidth + xAxisLabelHegiht\n      : textHeight + xAxisLabelHegiht;\n    const requiredYOffset =\n      yAxisValues.length === 1\n        ? Math.max(maxYAxisWidth, getTextWidth(yAxisLabel, titlesD3font))\n        : maxYAxisWidth + yAxisLabelHeight;\n\n    // Set the dimensions and offsets of the graph\n    const offset = {\n      top: margin.top,\n      right: margin.right,\n      bottom: requiredXOffset + margin.bottom,\n      left: requiredYOffset + margin.left,\n    };\n\n    // ----------------------------------------------------------------------------------------\n\n    // The chart is assigned to a referenced 'div' which must be rendered first\n    // All this process is runned after the render\n    useEffect(() => {\n      // Reset the chart\n      // WARNING: For some reason, if this part is re-render the original render is not gone\n      // WARNING: We must reset the element manually or infinite elements are rendered and stacked\n      if (previousCharts.current)\n        previousCharts.current.forEach(chart => chart.remove());\n\n      // Get the current element where all this heatmap is placed\n      const container = containerRef.current;\n      // The first render, when there is no reference to the current element yet, we skip the process\n      const {\n        clientWidth: width,\n        clientHeight: height,\n      } = container.parentElement;\n\n      // Calculate the body width and height\n      const bodyWidth = width - offset.left - offset.right;\n      const bodyHeight = height - offset.top - offset.bottom;\n\n      // Calculate how many labels we can show in any axis while avoiding overlapping\n      // Take in count that bottom labels are rotated 90º, so it is their height that counts\n      // The '* 1.05' is to grant a small padding\n      const xSlots =\n        bodyWidth / ((flippedXAxisValues ? textHeight : maxXAxisWidth) * 1.05);\n      const ySlots = bodyHeight / (textHeight * 1.05);\n\n      // Estimate how many labels we must skip to reach the desired number\n      const xstep = Math.ceil(xAxisValues.length / xSlots);\n      const ystep = Math.ceil(yAxisValues.length / ySlots);\n\n      // Use canvas to display the heatmap blocks since d3 is not as efficient\n      // Canvas is set this way so we can access this specific element later\n      // WARNING: Using the 'document.getElementById' is risky since there may be more\n      // WARNING: e.g. the color legend\n      const canvasElement = document.createElement('CANVAS');\n      select(container)\n        .node()\n        .appendChild(canvasElement);\n      const canvas = select(canvasElement)\n        .attr('id', 'canvas')\n        .attr('width', bodyWidth)\n        .attr('height', bodyHeight)\n        .style('position', 'absolute')\n        .style('top', offset.top + 'px')\n        .style('left', offset.left + 'px')\n        .style('cursor', onClick ? 'pointer' : undefined);\n      const canvasContext = canvas\n        .node()\n        .getContext('2d' /*, {desynchronized: true}*/);\n\n      // append the svg object to the body of the page\n      const svg = select(container)\n        .append('svg')\n        .attr('id', 'svg')\n        .attr('viewBox', [0, 0, width, height]);\n\n      // Build X scales and axis:\n      const x = scaleBand()\n        .range([offset.left, bodyWidth + offset.left])\n        .domain(xAxisValues)\n        .paddingInner(0);\n\n      const xAxis = svg\n        .append('g')\n        .attr('transform', 'translate(0,' + (bodyHeight + offset.top) + ')')\n        .call(\n          axisBottom(x).tickFormat((d, i) => {\n            if (i % xstep === 0) return d;\n            else return '';\n          }),\n        )\n        .selectAll('text');\n\n      if (flippedXAxisValues) {\n        xAxis\n          .style('text-anchor', 'end')\n          .attr('dx', -roatatedTextOffset + 'px')\n          .attr('dy', -roatatedTextOffset + 'px')\n          .attr('transform', 'rotate(-90)');\n      }\n\n      // Build the X axis label\n      svg\n        .append('text')\n        .attr('class', 'x label')\n        .attr('text-anchor', 'middle')\n        .attr('x', offset.left + bodyWidth / 2)\n        .attr('y', offset.top + bodyHeight + requiredXOffset)\n        .text(xAxisLabel);\n\n      // Build Y scales and axis:\n      const y = scaleBand()\n        .domain(yAxisValues)\n        .range([offset.top, bodyHeight + offset.top])\n        .padding(verticalPadding);\n\n      svg\n        .append('g')\n        .attr('transform', 'translate(' + offset.left + ', 0)')\n        .call(\n          axisLeft(y).tickFormat((d, i) => {\n            if (i % ystep === 0) return d;\n            else return '';\n          }),\n        );\n\n      // Build the Y axis label\n      if (yAxisValues.length === 1) {\n        svg\n          .append('text')\n          .attr('class', 'y label')\n          .attr('text-anchor', 'start')\n          .attr('x', 0)\n          .attr('y', margin.top + bodyHeight)\n          .text(yAxisLabel);\n      } else {\n        svg\n          .append('text')\n          .attr('class', 'y label')\n          .attr('text-anchor', 'middle')\n          .attr('x', -(offset.top + bodyHeight / 2))\n          .attr(\n            'y',\n            margin.left +\n              yAxisLabelHeight -\n              roatatedTextOffset -\n              axisLabelsOffset,\n          )\n          .attr('transform', 'rotate(-90)')\n          .text(yAxisLabel);\n      }\n\n      // Build color scale\n      const myColor = value => {\n        if (isNaN(value)) {\n          return NaNColor;\n        }\n        \n        const colorMapper = colorScale \n          ? colorScale \n          : scaleLinear()\n              .range(colorPlan)\n              .domain([minv, (minv + maxv) / 2, maxv]);\n              \n        return colorMapper(value);\n      };\n\n      // Get cell size according to d3 scale band\n      const cellWidth = x.bandwidth();\n      const cellHeight = y.bandwidth();\n\n      // Display heatmap cells using canvas\n      data.forEach((row, cy) => {\n        const yPosition = y(yAxisValues[cy]) - offset.top;\n        row.forEach((value, cx) => {\n          const xPosition = x(xAxisValues[cx]) - offset.left;\n          canvasContext.fillStyle = myColor(value);\n          canvasContext.fillRect(xPosition, yPosition, cellWidth, cellHeight);\n        \n        if (addBorder){  \n          // Add border\n          canvasContext.strokeStyle = myColor(value); // Use same color as fill\n          canvasContext.lineWidth = 1;\n          canvasContext.strokeRect(xPosition, yPosition, cellWidth, cellHeight);}\n        });\n      });\n\n      // Get the current mouse position in a standard format\n      const getMousePosition = e => {\n        // Get canvas current position\n        // WARNING: This line must be inside the function since canvas position may change when scrolling\n        const canvasRect = canvasElement.getBoundingClientRect();\n        // Get the exact mouse positions\n        const xPosition = e.clientX - canvasRect.left;\n        const yPosition = e.clientY - canvasRect.top;\n        // Calculate the equivalent x and y indexes\n        let xIndex = Math.floor(xPosition / x.step());\n        let yIndex = Math.floor(yPosition / y.step());\n        // Sometimes it may happend in the borders of the heatmap that ihe index is out of range\n        const xLimit = data[0].length - 1;\n        if (xIndex < 0) xIndex = 0;\n        if (xIndex > xLimit) xIndex = xLimit;\n        const yLimit = data.length - 1;\n        if (yIndex < 0) yIndex = 0;\n        if (yIndex > yLimit) yIndex = yLimit;\n        // Get also the equivalent axis values and the cell value\n        const xAxisValue = xAxisValues[xIndex];\n        const yAxisValue = yAxisValues[yIndex];\n        const value = data[yIndex][xIndex];\n        return { xIndex, yIndex, value, xAxisValue, yAxisValue };\n      };\n\n      // In case there is a tooltip, handle how to show it\n      let tooltip;\n      if (onTooltip) {\n        // Set up the tooltip, which is hidden by default\n        tooltip = document.createElement('div');\n        Object.assign(tooltip.style, {\n          display: 'none',\n          position: 'absolute',\n          pointerEvents: 'none',\n          backgroundColor: 'rgba( 0, 0, 0, 0.6 )',\n          color: 'lightgrey',\n          padding: '8px',\n          fontFamily: 'sans-serif',\n        });\n        container.appendChild(tooltip);\n\n        canvasElement.onmousemove = e => {\n          // Get current mouse position\n          const mousePosition = getMousePosition(e);\n          // Set the tooltip text\n          tooltip.innerText = onTooltip(mousePosition);\n          //console.log(xIndex + ',' + yIndex);\n          // Set the tooltip position inside the heatmap\n          tooltip.style.display = 'inline-block';\n          const {\n            x: xTooltipPosition,\n            y: yTooltipPosition,\n          } = setTooltipPosition(\n            container,\n            tooltip,\n            { x: e.clientX, y: e.clientY },\n            3,\n          );\n          tooltip.style.left = xTooltipPosition + 'px';\n          tooltip.style.top = yTooltipPosition + 'px';\n        };\n        canvasElement.onmouseleave = () => {\n          tooltip.style.display = 'none';\n        };\n      }\n\n      // Handle when a cell is clicked\n      if (onClick) {\n        canvasElement.onmousedown = e => {\n          // Get current mouse position\n          const mousePosition = getMousePosition(e);\n          // Call the on click function\n          onClick(mousePosition);\n        };\n      }\n\n      // Record all elements which must be removed manually when re-rendering\n      previousCharts.current = tooltip ? [svg, canvas, tooltip] : [svg, canvas];\n\n      const handleResize = () => {\n        setCurrentWindow({\n          innerWidth: window.innerWidth,\n          innerHeight: window.innerHeight,\n        });\n      };\n      window.addEventListener('resize', handleResize);\n\n      // Cleaning function\n      return () => {\n        window.removeEventListener('resize', handleResize);\n      };\n    }); // This useEffect has no dependencies\n\n    // Finally, render the heatmap\n    return (\n      // It is important to specify a height value\n      // Otherwise canvas and svg may be not coordinated\n      <div\n        className={className}\n        style={className ? undefined : { height: '600px', width: '600px' }}\n      >\n        <div\n          ref={containerRef}\n          id={'container'}\n          // WARNING: This width 100% may seem redundant, but chrome needs it\n          style={{ position: 'relative', width: '100%', height: '100%' }}\n        />\n      </div>\n    );\n  },\n);\n\nexport default D3HeatmapGrid;\n"],"names":["KEYFRAMES","opacity","reducedMotion","transform","ANIMATION_OPTIONS","fill","easing","duration","forwardRef","_ref","ref","overrideComponent","props","containerRef","useRef","useLayoutEffect","node","current","firstElementChild","animate","index","Array","from","document","querySelectorAll","findIndex","section","animation","delay","cancel","Component","Card","_jsx","className","style","children","component","setTooltipPosition","parent","tooltip","reference","offset","arguments","length","undefined","limits","getBoundingClientRect","size","x","Math","abs","left","right","y","top","bottom","floor","String","fromCharCode","inputData","xMaxCells","yMaxCells","onTooltip","onClick","legendTitle","colorPlan","xTitle","yTitle","minValue","customMinValue","maxValue","customMaxValue","data","xLabels","yLabels","xstep","ystep","useMemo","rData","rxLabels","ryLabels","xLength","yLength","forEach","row","Error","summarizedIndexes","round","map","u","yIndex","xIndex","keys","console","error","i","validValues","flat","filter","value","isNaN","min","max","convertMousePosition","_ref2","xAxisValue","yAxisValue","_jsxs","Suspense","fallback","D3HeatmapGrid","xAxisValues","yAxisValues","xAxisLabel","yAxisLabel","e","mousePosition","CardContent","ColorLegend","title","splits","vertical","flip","legendData","legendLabels","values","push","val","decimal","Set","v","reverse","flippedXAxisValues","getTextWidth","text","font","context","canvas","createElement","getContext","measureText","width","getTextSizeDOM","element","content","createTextNode","appendChild","Object","assign","position","visibility","height","body","clientWidth","clientHeight","defaultD3font","titlesD3font","memo","verticalPadding","colorScale","margin","NaNColor","addBorder","log","concat","maxv","minv","xlabs","ylabs","lab","fdata","previousCharts","setCurrentWindow","useState","textHeight","labelsHeight","maxXAxisWidth","label","maxYAxisWidth","xAxisLabelHegiht","yAxisLabelHeight","requiredXOffset","requiredYOffset","useEffect","chart","remove","container","parentElement","bodyWidth","bodyHeight","xSlots","ySlots","ceil","canvasElement","select","attr","canvasContext","svg","append","scaleBand","range","domain","paddingInner","xAxis","call","axisBottom","tickFormat","d","selectAll","padding","axisLeft","myColor","scaleLinear","cellWidth","bandwidth","cellHeight","cy","yPosition","cx","xPosition","fillStyle","fillRect","strokeStyle","lineWidth","strokeRect","getMousePosition","canvasRect","clientX","clientY","step","xLimit","yLimit","display","pointerEvents","backgroundColor","color","fontFamily","onmousemove","innerText","xTooltipPosition","yTooltipPosition","onmouseleave","onmousedown","handleResize","innerWidth","window","innerHeight","addEventListener","removeEventListener","id"],"sourceRoot":""}