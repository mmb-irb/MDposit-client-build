{"version":3,"file":"static/js/5291.bb2520eb.chunk.js","mappings":"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","sources":["../node_modules/lodash-es/flatten.js","../node_modules/lodash-es/uniqueId.js","components/graph/add-text-background/index.js","components/graph/add-masks/index.js","webpack://mdposit/./src/components/graph/style.module.css?7739","webpack://mdposit/./src/components/graph/line-sample/style.module.css?e034","components/graph/line-sample/index.js","components/graph/index.js","utils/document-measurer/index.js","utils/statistics/index.js","../node_modules/@mui/material/internal/svg-icons/CheckBoxOutlineBlank.js","../node_modules/@mui/material/internal/svg-icons/CheckBox.js","../node_modules/@mui/material/internal/svg-icons/IndeterminateCheckBox.js","../node_modules/@mui/material/Checkbox/checkboxClasses.js","../node_modules/@mui/material/Checkbox/Checkbox.js","../node_modules/lodash-es/_arrayMap.js","../node_modules/lodash-es/_isFlattenable.js","../node_modules/lodash-es/_baseFlatten.js","../node_modules/lodash-es/noop.js","../node_modules/lodash-es/_baseToString.js","../node_modules/lodash-es/toString.js"],"sourcesContent":["import baseFlatten from './_baseFlatten.js';\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nexport default flatten;\n","import toString from './toString.js';\n\n/** Used to generate unique IDs. */\nvar idCounter = 0;\n\n/**\n * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {string} [prefix=''] The value to prefix the ID with.\n * @returns {string} Returns the unique ID.\n * @example\n *\n * _.uniqueId('contact_');\n * // => 'contact_104'\n *\n * _.uniqueId();\n * // => '105'\n */\nfunction uniqueId(prefix) {\n  var id = ++idCounter;\n  return toString(prefix) + id;\n}\n\nexport default uniqueId;\n","import { uniqueId } from 'lodash-es';\n\nconst addTextBackground = defs => {\n  const id = uniqueId('background-');\n\n  const filter = defs\n    .append('filter')\n    .attr('x', 0)\n    .attr('y', 0)\n    .attr('width', 1)\n    .attr('height', 1)\n    .attr('id', id);\n  filter.append('feFlood').attr('flood-color', 'white');\n  filter.append('feComposite').attr('in', 'SourceGraphic');\n  return `url(#${id})`;\n};\n\nexport default addTextBackground;\n","import { uniqueId } from 'lodash-es';\n\nconst addMasks = defs => {\n  const idStart = uniqueId('gradient-start-');\n  const idEnd = uniqueId('gradient-end-');\n  const startMaskGradient = defs.append('linearGradient').attr('id', idStart);\n  startMaskGradient\n    .append('stop')\n    .attr('offset', '0%')\n    .style('stop-color', 'white')\n    .style('stop-opacity', '1');\n  startMaskGradient\n    .append('stop')\n    .attr('offset', '100%')\n    .style('stop-color', 'white')\n    .style('stop-opacity', '0');\n  const endMaskGradient = defs.append('linearGradient').attr('id', idEnd);\n  endMaskGradient\n    .append('stop')\n    .attr('offset', '0%')\n    .style('stop-color', 'white')\n    .style('stop-opacity', '0');\n  endMaskGradient\n    .append('stop')\n    .attr('offset', '100%')\n    .style('stop-color', 'white')\n    .style('stop-opacity', '1');\n  return [`url(#${idStart})`, `url(#${idEnd})`];\n};\n\nexport default addMasks;\n","// extracted by mini-css-extract-plugin\nexport default {\"default\":\"style_default__PoK16\",\"flexible\":\"style_flexible__UEdHy\",\"graph-container\":\"style_graph-container__j1+gF\",\"graph-legend\":\"style_graph-legend__z5iWz\",\"graph-display-legend\":\"style_graph-display-legend__zhM2L\",\"line-sample\":\"style_line-sample__1vgXB\"};","// extracted by mini-css-extract-plugin\nexport default {\"default\":\"style_default__IVrx2\"};","import React, { useRef, useEffect } from 'react';\nimport { select } from 'd3';\n\nimport style from './style.module.css';\n\nconst LineSample = ({ color, dash, className }) => {\n  // Referenced document element where d3 is rendered\n  const containerRef = useRef(null);\n\n  // This useEffect must be run only once\n  useEffect(() => {\n    const graph = select(containerRef.current);\n    graph.attr('width', 50).attr('height', 5);\n    graph\n      .append('line')\n      .style('stroke', color)\n      .style('stroke-dasharray', dash)\n      .style('stroke-width', 3)\n      .attr('x1', 0)\n      .attr('y1', 0)\n      .attr('x2', 50)\n      .attr('y2', 0);\n  }, []);\n  // Maybe might need to double-check that and remove the exception\n\n  return (\n    <svg ref={containerRef} className={className ? className : style.default} />\n  );\n};\n\nexport default LineSample;\n","import React, {\n  useState,\n  useCallback,\n  useRef,\n  useEffect,\n  useMemo,\n  forwardRef,\n  useImperativeHandle,\n} from 'react';\nimport { noop, flatten } from 'lodash-es';\nimport {\n  select,\n  scaleLinear,\n  scaleLog,\n  axisBottom,\n  axisLeft,\n  extent,\n  line,\n  mouse,\n  zoom,\n  event,\n} from 'd3';\n\nimport { FormControlLabel, Checkbox } from '@mui/material';\n\nimport { NICE_NAMES } from '../../utils/constants';\n\nimport addTextBackground from './add-text-background';\nimport addMasks from './add-masks';\n\nimport { getTextWidth, getTextSizeDOM } from '../../utils/document-measurer';\n\nimport { getMean, getMeanAndStdv } from '../../utils/statistics';\n\nimport style from './style.module.css';\n\nimport LineSample from './line-sample';\n\n// Number of data points to be represented at the same time FOR EACH dataset\n// WARNING: The component would support quite more points with good performace\n// WARNING: However, more points would make the visualization less 'comfortable'\n// This is the minimum number of data points to be shown at maximum zoom (i.e. maximum precision)\n// Thus it limits how much the graph can be zoomed\n// At the same time, it is the maximum number of points to be shown at minimum zoom\n// Thus it limits the precision at minimum zoom\n// DANI: Hay algunas escalas del d3 que no llegué a comprender bien\n// DANI: Puede que el número no se respete del todo\nconst NUMBER_OF_DATA_POINTS_ON_SCREEN = 100; // i.e. minimum number of points in screen\n\n// Set the separation between text labels which appear when we hover data points\nconst HOVER_TEXT_SEPARATION = 25;\n\n// Set a small offset to be added between normal labels and 90 degrees rotated labels\n// This offset is added between the y labels (normal) and the y title (rotated)\n// This offset is added between the x labels (rotated) and the x title (normal)\nconst roatatedTextOffset = 9; // In px\n\n// Set a small offset to keep away the axis labels and the axis values\n// They are very close to the axis values by default\nconst axisLabelsOffset = 9; // In px\n\n// Set the default dot radius and thus calculate the default dot area\nconst DEFAULT_DOT_RADIUS = 3;\nconst DEFAULT_DOT_AREA = Math.PI * DEFAULT_DOT_RADIUS ** 2;\n\nconst dPR = window.devicePixelRatio || 1;\n\n// According to d3 documentation\nconst defaultD3font = 'normal 10px sans-serif';\n// Experimentally verfied\nconst titlesD3font = 'normal 14px sans-serif';\n\nconst yDataPlaceholder = { placeholder: { data: [0] } };\nconst defaultMargins = { top: 10, right: 10, bottom: 10, left: 10 };\n\n// This function is a workaround to calculate maximum values from an array without spread syntax\n// Some browsers (e.g. Chrome) do not support large amount of arguments in a function\n// For this reason, Math.max(...values) will fail if the 'values' array is long enough\n// The returned error is “RangeError: Maximum call stack size exceeded”\nconst steppedMax = values => {\n  let max = Number.NEGATIVE_INFINITY;\n  values.forEach(value => {\n    max = Math.max(value, max);\n  });\n  return max;\n};\n\n// Create an object with all specified keys and all values as true\nconst trueEntries = keys => {\n  const object = {};\n  keys.forEach(key => (object[key] = true));\n  return object;\n};\n\nconst isCanvasPowered = type => type === 'dash' || type === 'dots';\n\n// The expected input data (y) is:\n// {\n//    dataset1:{\n//      data: [... the main data ...]\n//      average: float,\n//      color: 'red',\n//      dash: \"5, 5\",\n//    }\n//    dataset2:{...}\n// }\n\nconst Graph = forwardRef(({ // The main data\n  yData, xAxisValues, step = 1, title, xAxisLabel, yAxisLabel, xScaleFactor = 1, xColors, xWeights, xTooltip, type = 'line', onHover, onSelect, selfLegend = false, displayLegend = false, dataDisplay, setDataDisplay, mean = false, standardDeviation = false, margin = defaultMargins, flippedXAxisValues = false, fullPrecision = false, className, marks }, ref) => { // Note that this is only compatible with dash/dots types, not line // Thea main data to be represented // Optional x tags // not sure // Graph title // The x axis label text // The y axis label text // The difference beyween x values // Color each different dot in the graph dependeing on its x index\n  // Define the weights for each x value. This is only compatible with type = 'dots' and makes dots bigger // The function to set what to show on the tooltip based in the x value where the mouse is hovering // Set the type of graph to render. Accepted values: line, dash // Object with each dataset name and a value of true/false to set which data is displayed // dataDisplay setter // Display the mean line in the graph // Display the standard deviation area in the graph // Set an extra margin around the graph // Set if values in x axis is horizontal (false) or vertical (true) // If true, draw all points in the graph no matter how many points are there // Force a classname for the overall component element // Mark x values by displaying a vertical line in their positions\n  // -  style: object with all the style names (keys) and their values according to d3\n  // -  attr: object with all the attribute names (keys) and their values according to d3\n  // -  x: the position of the mark according to the x axis\n  // Set a fake dataset to allow the graph to work when no data is passed\n  if (!yData || Object.keys(yData).length === 0) yData = yDataPlaceholder;\n\n  // Referenced document element where d3 is rendered\n  const containerRef = useRef(null);\n  // Referenced function which allows to update the cart without having to remake it\n  const drawRef = useRef(noop);\n  const onSelectRef = useRef(noop);\n  const marksRef = useRef(noop);\n  const hoveredRef = useRef(noop);\n\n  // Get each dataset\n  const { yEntries, yKeys } = useMemo(() => {\n    const yEntries = Object.entries(yData);\n    const yKeys = yEntries.map(([key]) => key);\n    return { yEntries, yKeys };\n  }, [yData]);\n\n  // ----------------------------------------------------------------------------------------\n\n  // OFFSETS: Estimate the space needed for all the labels and titles to not overlap\n  // DANI: Toda esta parte no se actualiza en el drawRef en caso de que los valores de las labels cambien\n  // DANI: Esto da problemas si queremos cargar un graph sin data para luego ir metiendo data\n  // DANI: El graph se creará sin margen para las labels y cuando introduzcamos data habrá un overlap\n  const {\n    offset,\n    labelsHeight,\n    requiredBottomOffset,\n    yAxisLabelHegiht,\n  } = useMemo(() => {\n    // Set the yAxisValues by adding all dataset 'data' values\n    let yAxisValues = yEntries\n      .map(([, dataset]) => dataset.data)\n      .reduce((cv, nv) => cv.concat(nv));\n    // Round values if they are numeric, since labels just reach x.00\n    yAxisValues = yAxisValues.map(v => Math.round(v * 100) / 100);\n\n    // Measure the height of normal and text and labels\n    const textHeight = getTextSizeDOM('|', defaultD3font).height;\n    const labelsHeight =\n      getTextSizeDOM('|', titlesD3font).height + axisLabelsOffset;\n\n    // Get the calculated widths of all y labels and select the maximum\n    // In addition, add a small offset between labels and the axis which is added further\n    // This offset is only in x axes, which are rotated 90 degrees and end too much close to the axis\n    const maxXAxisWidth = xAxisValues\n      ? steppedMax(\n          xAxisValues.map(label => getTextWidth(label, defaultD3font)),\n        ) + roatatedTextOffset\n      : 10;\n    // Get the calculated widths of all y labels and select the maximum\n    const maxYAxisWidth = steppedMax(\n      yAxisValues.map(label => getTextWidth(label, defaultD3font)),\n    );\n\n    // In addition, add a small offset between labels and the axis which is added further\n    // This offset is only in x axes, which are rotated 90 degrees and end too much close to the axis\n    const xAxisLabelHegiht = xAxisLabel ? labelsHeight : 0;\n    const yAxisLabelHegiht = yAxisLabel ? labelsHeight + roatatedTextOffset : 0;\n\n    // Finally, estimate the space needed by axes, titles, etc.\n    const requiredTopOffset = title ? labelsHeight + axisLabelsOffset : 0;\n    const requiredBottomOffset = flippedXAxisValues\n      ? maxXAxisWidth + xAxisLabelHegiht\n      : textHeight + xAxisLabelHegiht;\n    const requiredLeftOffset =\n      yAxisValues.length === 1 && yData !== yDataPlaceholder\n        ? Math.max(maxYAxisWidth, getTextWidth(yAxisLabel, titlesD3font))\n        : maxYAxisWidth + yAxisLabelHegiht;\n\n    // Set the dimensions and offsets of the graph\n    const offset = {\n      top: requiredTopOffset + margin.top,\n      right: margin.right,\n      bottom: requiredBottomOffset + margin.bottom,\n      left: requiredLeftOffset + margin.left,\n    };\n    return { offset, labelsHeight, requiredBottomOffset, yAxisLabelHegiht };\n  }, [\n    flippedXAxisValues,\n    margin,\n    title,\n    xAxisLabel,\n    xAxisValues,\n    yAxisLabel,\n    yData,\n    yEntries,\n  ]);\n\n  // ----------------------------------------------------------------------------------------\n\n  // Object with entries defining which data is displayed (true) or hidden (false)\n  // Each entry has the same key that its corresponding dataset\n  // First set a defualt internal state for cases where it is not passed with the arguments\n  const [internalDataDisplay, setInternalDataDisplay] = useState(\n    trueEntries(yKeys),\n  );\n  // Update the internal data display when data changes\n  useEffect(() => {\n    setInternalDataDisplay(trueEntries(yKeys));\n  }, [yKeys]);\n\n  // If the data display state was passed then use it\n  // Otherwise, use the internal state\n  const [lab, setLab] = dataDisplay\n    ? [dataDisplay, setDataDisplay]\n    : [internalDataDisplay, setInternalDataDisplay];\n\n  const previousValues = useRef({\n    data: yDataPlaceholder,\n    labels: lab,\n    currentZoom: { k: 1, x: 0, rescaleX: scale => scale },\n    xAxisLabel,\n    yAxisLabel,\n    xAxisValues,\n    onSelect,\n    step,\n    marks,\n  });\n\n  // This useEffect must be run only once\n  // The graph content is updated through the 'drawRef' referenced function\n  useEffect(() => {\n    // Set the d3 base\n    // Use canvas to display the dash blocks since d3 is not as efficient\n    let canvas;\n    let canvasContext;\n    if (isCanvasPowered(type)) {\n      canvas = select(containerRef.current).append('canvas');\n      canvasContext = canvas\n        .node()\n        .getContext('2d' /*, {desynchronized: true}*/);\n    }\n    const graph = select(containerRef.current).append('svg');\n    // 'defs' is an element used to store graphical data which is not rendered directly\n    // Graphics in defs are displayed later by refering them\n    const defs = graph.append('defs');\n    // text background\n    const textBackgroundURL = addTextBackground(defs);\n\n    // mask opacity\n    const [startMaskURL, endMaskURL] = addMasks(defs);\n\n    // Set the marks node now, so they are not placed over the graph\n    const marksNode = graph.append('g');\n\n    const main = graph.append('g');\n\n    // Set the dots in the graph\n    const allDotGroups = main.append('g');\n\n    // order is important, everything before that will be hidden by masks\n    // masks\n    graph\n      .append('rect')\n      .attr('x', 0)\n      .attr('y', 0)\n      .attr('width', offset.left)\n      .attr('height', '100%')\n      .style('fill', startMaskURL);\n    const maskEnd = graph\n      .append('rect')\n      .attr('y', 0)\n      .attr('height', '100%')\n      .style('fill', endMaskURL);\n\n    // axes\n    const axes = {\n      x: graph.append('g'),\n      y: graph.append('g'),\n    };\n\n    // Set an independent dot which is in the x axis and holds the x tooltip\n    const xDot = graph.append('g');\n\n    // This ref allows to update the graph without having to remake the whole graph\n    drawRef.current = ({\n      data = previousValues.current.data,\n      labels = previousValues.current.labels,\n      step = previousValues.current.step,\n      xAxisLabel = previousValues.current.xAxisLabel,\n      yAxisLabel = previousValues.current.yAxisLabel,\n      currentZoom = previousValues.current.currentZoom,\n      xAxisValues = previousValues.current.xAxisValues,\n      onSelect = previousValues.current.onSelect,\n      marks = previousValues.current.marks,\n      offset = previousValues.current.offset,\n      labelsHeight = previousValues.current.labelsHeight,\n      requiredBottomOffset = previousValues.current.requiredBottomOffset,\n      yAxisLabelHegiht = previousValues.current.yAxisLabelHegiht,\n      xColors = previousValues.current.xColors,\n      xNormalizedWeights = previousValues.current.xNormalizedWeights,\n      xTooltip = previousValues.current.xTooltip,\n    } = {}) => {\n      // Change the graph size according to the left offset\n      graph.attr('width', offset.left);\n\n      // Save a few values for further reference\n      // These values must be saved at frist since other noop references read them from the reference\n      previousValues.current.step = step;\n      previousValues.current.xAxisValues = xAxisValues;\n\n      // container size\n      const { clientWidth: width, clientHeight: height } = containerRef.current;\n\n      const dataEntries = Object.entries(data);\n      const dataKeys = dataEntries.map(([key]) => key);\n\n      // ----------------------------------------------------------------------------\n\n      // ZOOM\n\n      // The minimum and default zoom value is 1\n      const minZoomExtent = 1;\n\n      //   make zoom extent dynamic depending on number of data points\n      //   ↳ results in similar precision at maximum zoom regardless of data size\n      const maxZoomExtent =\n        dataEntries[0][1].data.length / NUMBER_OF_DATA_POINTS_ON_SCREEN;\n\n      // Set the number of points to be represented\n      // The maximum precision is always 1\n      // i.e. When zoom is at maximum value all points in the window range must be shown\n      const precisionScale = scaleLog().range(\n        fullPrecision ? [1, 1] : [Math.ceil(maxZoomExtent), minZoomExtent],\n      );\n\n      precisionScale.domain([minZoomExtent, maxZoomExtent]);\n\n      // Get the precision to be used according to the zoom value\n      // The zoom value is a numeric value which ranges from minZoomExtent (default) to maxZoomExtent\n      const getZoomPrecision = k =>\n        2 ** Math.floor(Math.log2(precisionScale(k)));\n\n      const graphZoom = zoom().scaleExtent([minZoomExtent, maxZoomExtent]);\n      // By default, the zoom in/out event of d3 prevents the verticall scroll on mouse wheel\n      // However, when zoom has reached the maximum or minimum limit, the scroll is re-established\n      // The 'on wheel' eventdown here prevents that furtive scroll\n      graph.call(graphZoom).on('wheel', () => event.preventDefault());\n      // Update precision and rescaleX on zoom (i.e. on mouse wheel)\n      graphZoom.on('zoom', () => {\n        drawRef.current({\n          currentZoom: event.transform,\n        });\n      });\n\n      // Get the the current zoom 'k' value\n      // If it is bigger thant the maximum extent then use the maximum extent instead\n      // This may happen when the dataset is changed while the zoom is in the maximum\n      const k = Math.min(currentZoom.k, maxZoomExtent);\n      const zoomPrecision = getZoomPrecision(k);\n      const precision = isCanvasPowered(type) ? 1 : zoomPrecision;\n      const rescaleX = currentZoom.rescaleX.bind(currentZoom);\n\n      // Save precision for further reference\n      previousValues.current.precision = precision;\n\n      // ----------------------------------------------------------------------------\n\n      // DANI: Esto es mio (experimental)\n      const bodyWidth = width - offset.left - offset.right;\n      const bodyHeight = height - offset.top - offset.bottom;\n\n      graph.attr('width', width).attr('height', height);\n      if (canvas) {\n        canvas.attr('width', width * dPR).attr('height', height * dPR);\n        canvas.style('width', `${width}px`).style('height', `${height}px`);\n      }\n\n      maskEnd.attr('x', width - offset.right).attr('width', offset.right);\n\n      // Draw the title over the graph\n      if (title) {\n        // Remove the previous title\n        graph.select('#title').remove();\n        axes.title = graph\n          .append('text')\n          .attr('id', 'title')\n          .attr('class', 'title')\n          .style('text-anchor', 'middle')\n          .attr('x', width / 2)\n          .attr('y', margin.top + labelsHeight)\n          .text(title);\n      }\n\n      // Set the x minimum and maximum limits\n      const xMin = 0;\n      const xMax = dataEntries[0][1].data.length * step;\n\n      // Save this values to further reference\n      previousValues.current.xMin = xMin;\n      previousValues.current.xMax = xMax;\n\n      // Set a function which calculates de x position in screen\n      // Note that values from this function change when you grab/scroll in the graph\n      const x = rescaleX(\n        scaleLinear()\n          .domain([xMin, xMax])\n          .range([offset.left, width - offset.right]),\n      );\n      previousValues.current.x = x;\n\n      const xAxis = g =>\n        g.attr('transform', `translate(0, ${height - offset.bottom})`).call(\n          // DANI: Estos ticks los he puesto a mano tras comprobar que quedaban bien\n          axisBottom(x)\n            .ticks(7, '.2f')\n            .tickFormat(d => (xAxisValues ? xAxisValues[d] : d)),\n        );\n      axes.x.call(xAxis);\n\n      // Set the x axis label\n      if (xAxisLabel) {\n        // Remove the previous label\n        graph.select('#xlab').remove();\n        axes.xAxisLabel = graph\n          .append('text')\n          .attr('id', 'xlab')\n          .attr('class', 'x label')\n          .attr('text-anchor', 'middle')\n          .attr('x', offset.left + bodyWidth / 2)\n          .attr('y', offset.top + bodyHeight + requiredBottomOffset)\n          .text(xAxisLabel);\n      }\n\n      // y axis/axes\n      const y = scaleLinear()\n        .domain(\n          extent(\n            flatten(\n              dataEntries\n                .filter(([key]) => labels[key])\n                .map(([, { data }]) => extent(data)),\n            ),\n          ),\n        )\n        .nice()\n        .range([height - offset.bottom, offset.top]);\n\n      const yAxis = g =>\n        g\n          .attr('transform', `translate(${offset.left}, 0)`)\n          .transition()\n          .call(axisLeft(y));\n      //.call(axisLeft(y).ticks(8, '.2f')); // Use this to force the number of decimals in labels\n      axes.y.call(yAxis);\n\n      // Set the y axis label\n      if (yAxisLabel) {\n        graph.select('#ylab').remove();\n        axes.yAxisLabel = graph\n          .append('text')\n          .attr('id', 'ylab')\n          .attr('class', 'y label')\n          .attr('text-anchor', 'middle')\n          .attr('x', -(offset.top + bodyHeight / 2))\n          .attr(\n            'y',\n            margin.left +\n              yAxisLabelHegiht -\n              roatatedTextOffset -\n              axisLabelsOffset,\n          )\n          .attr('transform', 'rotate(-90)')\n          .text(yAxisLabel);\n      }\n\n      // mean line\n      if (mean) {\n        // Represent a line with this average value along the whole graph\n        const meanLines = main.selectAll('line.mean').data(dataKeys);\n        meanLines\n          .enter()\n          .append('line')\n          .attr('class', 'mean')\n          .merge(meanLines)\n          .attr('stroke', d => (data[d] && data[d].color) || 'black')\n          .attr('x1', x(xMin))\n          .attr('x2', x(xMax))\n          .attr('y1', d => y(getMean(data[d].data)))\n          .attr('y2', d => y(getMean(data[d].data)))\n          .transition()\n          .attr('opacity', d => (labels[d] ? 0.5 : 0));\n        meanLines.exit().remove();\n      }\n      // mean ± 1σ area\n      if (standardDeviation) {\n        for (const [, dataset] of dataEntries) {\n          const data = dataset.data;\n          if (!data) continue;\n          const sum = data.reduce((pv, cv) => pv + cv, 0);\n          const n = data.length;\n          const mean = sum / n;\n          dataset.stddev = Math.sqrt(\n            data.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n,\n          );\n        }\n        const sdRects = main.selectAll('rect.sd').data(dataKeys);\n        sdRects\n          .enter()\n          .append('rect')\n          .attr('class', 'sd')\n          .merge(sdRects)\n          .attr('fill', d => (data[d] && data[d].color) || 'black')\n          .attr('x', x(xMin))\n          .attr('width', x(xMax) - x(xMin))\n          .attr('y', d => {\n            const { mean, stdv } = getMeanAndStdv(data[d].data);\n            return y(mean + stdv);\n          })\n          .attr('height', d => {\n            const { mean, stdv } = getMeanAndStdv(data[d].data);\n            return y(mean - stdv) - y(mean + stdv);\n          })\n          .transition()\n          .attr('opacity', d => (labels[d] ? 0.1 : 0));\n        sdRects.exit().remove();\n      }\n      const minIndex = Math.floor(x.invert(0) / step / precision);\n      const maxIndex = Math.ceil(x.invert(width) / step / precision);\n      // In case it is a classical line graph\n      if (type === 'line') {\n        // Define the data line positions\n        const lineFn = line()\n          .defined((_, i) => i >= minIndex && i <= maxIndex)\n          .x((_, i) => x(i * step * precision))\n          .y(d => y(d));\n\n        // Draw the data lines\n        // First set the lines/data mapping\n        const linesData = main.selectAll('path.line').data(dataKeys);\n        // Add as many lines as required according to the mapped data\n        linesData\n          .enter()\n          .append('path')\n          .attr('class', 'line')\n          .attr('fill', 'none')\n          // Update existing lines with the mapped data\n          .merge(linesData)\n          .attr('stroke', d => data[d].color || 'black')\n          .style('stroke-dasharray', d =>\n            data[d].dash ? data[d].dash : undefined,\n          )\n          .attr('stroke-linejoin', 'round')\n          .attr('stroke-linecap', 'round')\n          .attr('d', d =>\n            lineFn(data[d].data.filter((_, i) => i % precision === 0)),\n          )\n          .transition()\n          .attr('opacity', d => (labels[d] ? 1 : 0))\n          .attr('stroke-width', 1.5);\n        // Remove lines which are not required anymore according to the mapped data\n        linesData.exit().remove();\n        // Save this node for further reference\n        previousValues.current.linesData = linesData;\n      }\n      // NEVER FORGET: We do not use d3 dots since they are way less efficient than canvas\n      // In case it is a dash graph\n      else if (isCanvasPowered(type) && canvasContext) {\n        // For the dash\n        const dashWidth = Math.max(1, x(1) - x(0));\n        const dashHeight = 5;\n        // For the dots\n        const startAngle = 0;\n        const endAngle = 2 * Math.PI;\n        canvasContext.clearRect(0, 0, width, height);\n        for (const [key, { data: values, color }] of Object.entries(data)) {\n          if (!labels[key]) continue;\n          canvasContext.fillStyle = color || '#000000';\n          const maxInView = Math.min(values.length - 1, maxIndex);\n          // each atom in view\n          for (\n            let index = Math.max(0, minIndex);\n            index <= maxInView;\n            index += 1\n          ) {\n            // Skip the follwoing dot if the zoom precision says so\n            if (index % zoomPrecision !== 0) continue;\n            // Color the rectangle according to the equivalent atom element\n            if (xColors) {\n              const atomColor = xColors[index];\n              // If the color is white (i.e. it is an hydrogen) then paint it slightly grey\n              // The background is white so a white rectangle would be not visible\n              canvasContext.fillStyle =\n                atomColor === 'white' ? '#eeeeee' : atomColor;\n            }\n            // Draw a rectangle\n            if (type === 'dash') {\n              canvasContext.fillRect(\n                (x(index * step * precision) - dashWidth / 2) * dPR,\n                (y(values[index]) - dashHeight / 2) * dPR,\n                dashWidth * dPR,\n                dashHeight * dPR,\n              );\n            }\n            // Draw a circle\n            if (type === 'dots') {\n              // Set the x y positions\n              const xPosition =\n                (x(index * step * precision) - dashWidth / 2) * dPR;\n              const yPosition = (y(values[index]) - dashHeight / 2) * dPR;\n              // Set the radius, which may be affected by the x weights, when passed\n              let radius = DEFAULT_DOT_RADIUS; // Its 3\n              if (xNormalizedWeights) {\n                const weight = xNormalizedWeights[index];\n                const area = DEFAULT_DOT_AREA * weight;\n                radius = Math.sqrt(area / Math.PI);\n              }\n              // Draw the circle\n              canvasContext.beginPath();\n              canvasContext.arc(\n                xPosition,\n                yPosition,\n                radius,\n                startAngle,\n                endAngle,\n              );\n              canvasContext.fill();\n            }\n          }\n        }\n      }\n\n      // Calculate the width of a vertical lines used to highlight specific x values\n      const xUnitWidth = Math.max(1, x(zoomPrecision * step) - x(0));\n      previousValues.current.xUnitWidth = xUnitWidth;\n      // Place vertical lines for specified marks\n      marksRef.current({ marks });\n\n      // dots over the selected vertical line\n      // Here we just delete previous dots and start again instead of updating them\n      allDotGroups.selectAll('g.dot-group').remove();\n      const dotGroups = allDotGroups\n        .selectAll('g.dot-group')\n        .data([...dataKeys])\n        .enter()\n        .append('g')\n        .attr('class', 'dot-group')\n        .attr('opacity', 0);\n      dotGroups\n        .append('circle')\n        .attr('cx', 0)\n        .attr('cy', 0)\n        .attr('r', 5)\n        .attr('fill', d => (data[d] && data[d].color) || 'black');\n      dotGroups\n        .append('text')\n        .style('text-anchor', 'middle')\n        .style('font-weight', 'bold')\n        .style('paint-order', 'stroke')\n        .attr('y', '-5px')\n        .attr('fill', d => (data[d] && data[d].color) || 'black')\n        .attr('stroke', 'rgba(255, 255, 255, 0.5)')\n        .attr('stroke-width', 5)\n        .attr('filter', textBackgroundURL);\n\n      // Set the dot over the x axis and the label highlighting the selected x value\n      xDot.selectAll('g').remove();\n      const actualXDot = xDot.append('g')\n        .attr('opacity', 0);\n      actualXDot\n        .append('circle')\n        .attr('cx', 0)\n        .attr('cy', 0)\n        .attr('r', 5)\n        .attr('fill', 'black');\n      actualXDot\n        .append('text')\n        .style('text-anchor', 'middle')\n        .style('font-weight', 'bold')\n        .style('paint-order', 'stroke')\n        .attr('y', '-5px')\n        .attr('fill', 'black')\n        .attr('stroke', 'rgba(255, 255, 255, 0.5)')\n        .attr('stroke-width', 5)\n        .attr('filter', textBackgroundURL);\n\n      // mouse move handler\n      graph.on('mousemove', (_, index, nodes) => {\n        // 'nodes' contain the mouse position data\n        // 'index' is apparently always 0\n        const [xValue] = mouse(nodes[index]);\n        // Get the closest x axis index to the current mouse position\n        const closestIndex =\n          Math.round(x.invert(xValue) / zoomPrecision / step) * zoomPrecision;\n        // Track the implicit position of all hovering dots\n        // This is useful to know if dot texts would overlap\n        const dotDownOffsets = {};\n        allDotGroups\n          // Set the x position of the dot\n          .attr('transform', `translate(${x(closestIndex * step)}, 0)`)\n          // Dots become invisible if the closest index is not between the minimum and the maximum\n          .attr(\n            'opacity',\n            closestIndex * step >= xMin && closestIndex * step < xMax ? 1 : 0,\n          );\n        allDotGroups\n          .selectAll('g.dot-group')\n          // Set the y position of the dot\n          .attr('transform', d => {\n            if (!labels[d]) return;\n            // Just over the correspondong line for other values\n            const offsetDown = (y(data[d].data[closestIndex]) || 0) + 2.5;\n            // Record the current offset down\n            dotDownOffsets[d] = offsetDown;\n            return `translate(0, ${offsetDown})`;\n          })\n          .attr('opacity', d => (d === 'x' || labels[d] ? 1 : 0))\n          .selectAll('text')\n          .attr('transform', d => {\n            if (!labels[d]) return;\n            // Find if an offset is too close to others and then move it to a better place (above)\n            let dotDownOffset = dotDownOffsets[d];\n            let extra = 0;\n            // Sort other offsets from more (below) to less (above)\n            const sortedOffsets = [];\n            for (const [key, value] of Object.entries(dotDownOffsets)) {\n              if (key !== d) sortedOffsets.push(value);\n            }\n            sortedOffsets.sort((a, b) => b - a);\n            // For each other offset, check if we are closer to it than the margin\n            // If so, we move our offset over the other as much as the margin needs\n            for (const offset of sortedOffsets) {\n              const difference = Math.abs(dotDownOffset + extra - offset);\n              if (difference > HOVER_TEXT_SEPARATION - 1) continue;\n              extra = offset - HOVER_TEXT_SEPARATION - dotDownOffset;\n            }\n            // In case the new offset is over the top limit we must relocate it below\n            if (dotDownOffset + extra < offset.top) {\n              extra = offset.top - dotDownOffset;\n              sortedOffsets.sort((a, b) => a - b);\n              // For each other offset, check if we are closer to it than the margin\n              // If so, we move our offset below the other as much as the margin needs\n              for (const offset of sortedOffsets) {\n                const difference = Math.abs(dotDownOffset + extra - offset);\n                if (difference > HOVER_TEXT_SEPARATION - 1) continue;\n                extra = offset + HOVER_TEXT_SEPARATION - dotDownOffset;\n              }\n            }\n            dotDownOffsets[d] = dotDownOffset + extra;\n            // Add the offset + a small margin\n            return `translate(0, ${extra - 3})`;\n          })\n          // Set the dot text in the x axis\n          .text(d => Math.round(data[d].data[closestIndex] * 100) / 100);\n        xDot\n          // Set the x position of the dot\n          .attr('transform', `translate(${x(closestIndex * step)}, 0)`)\n          // Dots become invisible if the closest index is not between the minimum and the maximum\n          .attr('opacity', closestIndex * step >= xMin && closestIndex * step < xMax ? 1 : 0);\n        actualXDot\n          // Set the y position of the dot\n          .attr('transform', `translate(0, ${height - offset.bottom})`)\n          .attr('opacity', 1)\n          .selectAll('text')\n          // Set the y position of the text under the dot\n          // This text size is similar to graph labels size so this is good enough\n          .attr('transform', `translate(0, ${labelsHeight})`)\n          // Set the dot text in the x axis\n          .text(() => {\n            const number = closestIndex * step * xScaleFactor;\n            if (number < 0) return;\n            return xTooltip && xTooltip(number, closestIndex);\n          });\n\n        if (onHover) {\n          onHover(\n            closestIndex * step >= xMin && closestIndex * step < xMax\n              ? closestIndex\n              : null,\n          );\n        }\n      });\n      // When click in the graph\n      onSelectRef.current({ onSelect });\n\n      graph.on('mouseout', () => {\n        allDotGroups.selectAll('g.dot-group').attr('opacity', 0);\n        actualXDot.attr('opacity', 0);\n        if (onHover) onHover(null);\n      });\n\n      // Save current values for further reference\n      previousValues.current.data = data;\n      previousValues.current.labels = labels;\n      previousValues.current.xAxisLabel = xAxisLabel;\n      previousValues.current.yAxisLabel = yAxisLabel;\n      previousValues.current.currentZoom = currentZoom;\n      previousValues.current.offset = offset;\n      previousValues.current.labelsHeight = labelsHeight;\n      previousValues.current.requiredBottomOffset = requiredBottomOffset;\n      previousValues.current.yAxisLabelHegiht = yAxisLabelHegiht;\n      previousValues.current.xColors = xColors;\n      previousValues.current.xNormalizedWeights = xNormalizedWeights;\n      previousValues.current.xTooltip = xTooltip;\n    };\n\n    onSelectRef.current = ({ onSelect } = {}) => {\n      // Get some reference values\n      const x = previousValues.current.x;\n      const precision = previousValues.current.precision;\n      const step = previousValues.current.step;\n      const xMin = previousValues.current.xMin;\n      const xMax = previousValues.current.xMax;\n      const xAxisValues = previousValues.current.xAxisValues;\n      // In case we dont have the previous values yet we stop here\n      if (x === undefined) return;\n      // If there is no 'onSelect' function then return here\n      if (!onSelect) return;\n      // When click in the graph\n      graph.on('click', (_, index, nodes) => {\n        const [xValue] = mouse(nodes[index]);\n        // Get the closest x axis index to the current mouse position\n        const closestIndex =\n          Math.round(x.invert(xValue) / precision / step) * precision;\n        if (closestIndex * step < xMin || closestIndex * step >= xMax) {\n          return;\n        }\n        onSelect(closestIndex, xAxisValues ? xAxisValues[closestIndex] : null);\n      });\n      // Update previous refs\n      previousValues.current.onSelect = onSelect;\n      previousValues.current.precision = precision;\n    };\n\n    // Place marks in the graph\n    marksRef.current = ({ marks } = {}) => {\n      // Get some reference values\n      const x = previousValues.current.x;\n      const xUnitWidth = previousValues.current.xUnitWidth;\n      const step = previousValues.current.step;\n      // In case we dont have all the arguments yet we stop here\n      if (x === undefined) return;\n      // Remove previous marks\n      if (previousValues.current.marks)\n        previousValues.current.marks.forEach(prevMark =>\n          marksNode.select('#mark' + prevMark.x).remove(),\n        );\n      // If there are no new marks then return here\n      if (!marks) return;\n      // Add a vertical band for each mark\n      marks.forEach(mark => {\n        const markRect = marksNode\n          .append('rect')\n          .attr('id', 'mark' + mark.x)\n          .attr('x', () =>\n            Number.isInteger(mark.x) ? x(mark.x * step) - xUnitWidth / 2 : 0,\n          )\n          .attr('y', 0)\n          .attr('height', '100%')\n          .attr('width', () => xUnitWidth);\n        if (mark.attr)\n          Object.entries(mark.attr).forEach(([key, value]) => {\n            markRect.attr(key, value);\n          });\n        if (mark.style)\n          Object.entries(mark.style).forEach(([key, value]) => {\n            markRect.style(key, value);\n          });\n      });\n      // Update previous refs\n      previousValues.current.marks = marks;\n    };\n\n    hoveredRef.current = ({ hovered } = {}) => {\n      // Get some reference values\n      const linesData = previousValues.current.linesData;\n      // Change the whole dataset line stroke width\n      linesData\n        .transition()\n        .attr('stroke-width', d => (hovered === d ? 3 : 1.5));\n      // Update previous refs\n      previousValues.current.hovered = hovered;\n    };\n\n    window.addEventListener('resize', drawRef.current);\n\n    return () => window.removeEventListener('resize', drawRef.current);\n  }, []); // DANI: eslint ahora se queja, peor antes aquí había esto: // eslint-disable-line react-hooks/exhaustive-deps\n  // Maybe might need to double-check that and remove the exception\n\n  // Handle when the 'onSelect' function changes\n  useEffect(() => {\n    onSelectRef.current({ onSelect });\n  }, [onSelect]);\n\n  // Handle when marks change\n  useEffect(() => {\n    marksRef.current({ marks });\n  }, [marks]);\n\n  // Handle when some parameter change requires a whole re-draw of the graph\n  useEffect(() => {\n    drawRef.current({\n      data: yData,\n      step,\n      xAxisLabel,\n      yAxisLabel,\n      xAxisValues,\n      labels: lab,\n      offset,\n      labelsHeight,\n      requiredBottomOffset,\n      yAxisLabelHegiht,\n      xColors,\n      xTooltip,\n    });\n  }, [\n    yData,\n    step,\n    xAxisLabel,\n    yAxisLabel,\n    xAxisValues,\n    lab,\n    offset,\n    labelsHeight,\n    requiredBottomOffset,\n    yAxisLabelHegiht,\n    xColors,\n    xTooltip,\n  ]);\n\n  // Handle when weights change apart, since they must be normalized\n  useEffect(() => {\n    // Normalize xWeigths, when passed, so that the minimum values are 1\n    if (!xWeights) return;\n    // Check weights and data to match in the number of values\n    const expectedCount = xWeights.length;\n    Object.values(yData).forEach(value => {\n      const currentCount = value.data.length;\n      if (currentCount !== expectedCount)\n        throw new Error(\n          `Graph data values count (${currentCount}) does not match the weigths values count (${expectedCount})`,\n        );\n    });\n    // Find the minimum and maximum values in the weights array\n    // NEVER FORGET: do not use Math.min and Math.max for long arrays\n    const minimum = xWeights.reduce((cv, nv) => {\n      return Math.min(cv, nv);\n    }, Infinity);\n    const maximum = xWeights.reduce((cv, nv) => {\n      return Math.max(cv, nv);\n    }, -Infinity);\n    // Set the normalized minimum and maximum radius values\n    // This in the graph is equivalent to 'times the default area'\n    const normalizedMinimum = 1;\n    const normalizedMaximum = 10;\n    // Set a function to interpolate values\n    const normalizer =\n      (normalizedMaximum - normalizedMinimum) / (maximum - minimum);\n    const interpolate = weight =>\n      normalizedMinimum + (weight - minimum) * normalizer;\n    // Recalculate weights using the minimum values (equal to 1) as reference\n    const xNormalizedWeights = xWeights.map(weight => interpolate(weight));\n    drawRef.current({ xNormalizedWeights });\n  }, [xWeights, yData]);\n\n  // Handle when user clicks on legend checkboxes\n  const handleChange = useCallback(\n    ({\n      target: {\n        dataset: { key },\n      },\n    }) => {\n      if (!key) return;\n      if (!setLab) return;\n      setLab(previous => {\n        const nextLabels = { ...previous, [key]: !previous[key] };\n        // Check if any value is true before returning the labels\n        // This way, the user can not uncheck the last active checkbox\n        if (Object.values(nextLabels).some(Boolean)) return nextLabels;\n        // If all of the values would be false, keep the previous\n        return previous;\n      });\n    },\n    [setLab],\n  );\n\n  const handleMouseOver = useCallback(\n    ({\n      target: {\n        dataset: { key },\n      },\n    }) => {\n      if (!key || !lab[key] || isCanvasPowered(type)) return;\n      hoveredRef.current({ hovered: key });\n    },\n    [lab, type],\n  );\n\n  const handleMouseOut = useCallback(\n    ({\n      target: {\n        dataset: { key },\n      },\n    }) => {\n      if (!key || !lab[key] || isCanvasPowered(type)) return;\n      hoveredRef.current({ hovered: null });\n    },\n    [lab, type],\n  );\n\n  // Expose public methods and getters/setters\n  useImperativeHandle(\n    ref,\n    () => ({\n      set marks(value) {\n        marksRef.current({ marks: value });\n      },\n    }),\n    [],\n  );\n\n  return (\n    <div className={className ? className : style.default}>\n      <div className={style.flexible}>\n        <div className={style['graph-container']} ref={containerRef} />\n        {selfLegend && (\n          <div className={style['graph-legend']}>\n            {yEntries.map(([key]) => (\n              <FormControlLabel\n                data-key={key}\n                key={key}\n                onChange={handleChange}\n                onMouseOver={handleMouseOver}\n                onMouseOut={handleMouseOut}\n                control={\n                  <Checkbox\n                    checked={lab[key]}\n                    style={{ color: yData[key].color || 'black' }}\n                    inputProps={{ 'data-key': key }}\n                  />\n                }\n                label={NICE_NAMES.get(key) || key}\n              />\n            ))}\n          </div>\n        )}\n        {displayLegend && (\n          <div className={style['graph-display-legend']}>\n            {yEntries.map(([key, dataset], i) => {\n              if (lab[key] === false) return null;\n              return (\n                <div key={key} className={style['line-sample']}>\n                  {key}\n                  <LineSample color={dataset.color} dash={dataset.dash} />\n                </div>\n              );\n            })}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n});\n\nexport default Graph;\n","// Function involved in getting text pixels width\n// WARNING: These functions do not work properly in Chrome (not an easy problem)\n\n// This function allows to calculate the width of a given string text\n// The font for the calculation in the d3 default font\nexport const getTextWidth = (text, font = 'bold 10px sans-serif') => {\n  const canvas =\n    getTextWidth.canvas ||\n    (getTextWidth.canvas = document.createElement('canvas'));\n  const context = canvas.getContext('2d');\n  context.font = font;\n  const metrics = context.measureText(text);\n  return metrics.width;\n};\n\n// Alternative way to obtain text width\n// Probably the only way to obtain text height\nexport const getTextSizeDOM = (text, font = 'bold 10px sans-serif') => {\n  const element = document.createElement('div');\n  const content = document.createTextNode(text);\n  element.appendChild(content);\n  Object.assign(element.style, {\n    font: font,\n    position: 'absolute',\n    visibility: 'hidden',\n    height: 'auto',\n    width: 'auto',\n    'white-space': 'nowrap',\n  });\n  document.body.appendChild(element);\n  return { width: element.clientWidth, height: element.clientHeight };\n};\n\n// Get the whole body width\nexport const getBodyWidth = () => {\n  return Math.max(\n    document.body.scrollWidth,\n    document.documentElement.scrollWidth,\n    document.body.offsetWidth,\n    document.documentElement.offsetWidth,\n    document.documentElement.clientWidth,\n  );\n};\n\n// Get the whole body height\nexport const getBodyHeight = () => {\n  return Math.max(\n    document.body.scrollHeight,\n    document.documentElement.scrollHeight,\n    document.body.offsetHeight,\n    document.documentElement.offsetHeight,\n    document.documentElement.clientHeight,\n  );\n};\n","// Statistics\n// Provide some usual statistics functions\n\n// Set a function which returns just the average\nexport const getMean = data => {\n  if (!data) return;\n  const sum = data.reduce((pv, cv) => pv + cv, 0);\n  const n = data.length;\n  return sum / n;\n};\n\n// Set a function which returns the average and standard deviation from a numeric array\nexport const getMeanAndStdv = data => {\n  if (!data) return;\n  const sum = data.reduce((pv, cv) => pv + cv, 0);\n  const n = data.length;\n  const mean = sum / n;\n  const stdv = Math.sqrt(\n    data.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n,\n  );\n  return { mean, stdv };\n};\n","'use client';\n\nimport * as React from 'react';\nimport createSvgIcon from '../../utils/createSvgIcon';\n\n/**\n * @ignore - internal component.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z\"\n}), 'CheckBoxOutlineBlank');","'use client';\n\nimport * as React from 'react';\nimport createSvgIcon from '../../utils/createSvgIcon';\n\n/**\n * @ignore - internal component.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"\n}), 'CheckBox');","'use client';\n\nimport * as React from 'react';\nimport createSvgIcon from '../../utils/createSvgIcon';\n\n/**\n * @ignore - internal component.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z\"\n}), 'IndeterminateCheckBox');","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getCheckboxUtilityClass(slot) {\n  return generateUtilityClass('MuiCheckbox', slot);\n}\nconst checkboxClasses = generateUtilityClasses('MuiCheckbox', ['root', 'checked', 'disabled', 'indeterminate', 'colorPrimary', 'colorSecondary', 'sizeSmall', 'sizeMedium']);\nexport default checkboxClasses;","'use client';\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"checkedIcon\", \"color\", \"icon\", \"indeterminate\", \"indeterminateIcon\", \"inputProps\", \"size\", \"className\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport refType from '@mui/utils/refType';\nimport composeClasses from '@mui/utils/composeClasses';\nimport { alpha } from '@mui/system/colorManipulator';\nimport SwitchBase from '../internal/SwitchBase';\nimport CheckBoxOutlineBlankIcon from '../internal/svg-icons/CheckBoxOutlineBlank';\nimport CheckBoxIcon from '../internal/svg-icons/CheckBox';\nimport IndeterminateCheckBoxIcon from '../internal/svg-icons/IndeterminateCheckBox';\nimport capitalize from '../utils/capitalize';\nimport { useDefaultProps } from '../DefaultPropsProvider';\nimport styled, { rootShouldForwardProp } from '../styles/styled';\nimport checkboxClasses, { getCheckboxUtilityClass } from './checkboxClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    classes,\n    indeterminate,\n    color,\n    size\n  } = ownerState;\n  const slots = {\n    root: ['root', indeterminate && 'indeterminate', `color${capitalize(color)}`, `size${capitalize(size)}`]\n  };\n  const composedClasses = composeClasses(slots, getCheckboxUtilityClass, classes);\n  return _extends({}, classes, composedClasses);\n};\nconst CheckboxRoot = styled(SwitchBase, {\n  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',\n  name: 'MuiCheckbox',\n  slot: 'Root',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, ownerState.indeterminate && styles.indeterminate, styles[`size${capitalize(ownerState.size)}`], ownerState.color !== 'default' && styles[`color${capitalize(ownerState.color)}`]];\n  }\n})(({\n  theme,\n  ownerState\n}) => _extends({\n  color: (theme.vars || theme).palette.text.secondary\n}, !ownerState.disableRipple && {\n  '&:hover': {\n    backgroundColor: theme.vars ? `rgba(${ownerState.color === 'default' ? theme.vars.palette.action.activeChannel : theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(ownerState.color === 'default' ? theme.palette.action.active : theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),\n    // Reset on touch devices, it doesn't add specificity\n    '@media (hover: none)': {\n      backgroundColor: 'transparent'\n    }\n  }\n}, ownerState.color !== 'default' && {\n  [`&.${checkboxClasses.checked}, &.${checkboxClasses.indeterminate}`]: {\n    color: (theme.vars || theme).palette[ownerState.color].main\n  },\n  [`&.${checkboxClasses.disabled}`]: {\n    color: (theme.vars || theme).palette.action.disabled\n  }\n}));\nconst defaultCheckedIcon = /*#__PURE__*/_jsx(CheckBoxIcon, {});\nconst defaultIcon = /*#__PURE__*/_jsx(CheckBoxOutlineBlankIcon, {});\nconst defaultIndeterminateIcon = /*#__PURE__*/_jsx(IndeterminateCheckBoxIcon, {});\nconst Checkbox = /*#__PURE__*/React.forwardRef(function Checkbox(inProps, ref) {\n  var _icon$props$fontSize, _indeterminateIcon$pr;\n  const props = useDefaultProps({\n    props: inProps,\n    name: 'MuiCheckbox'\n  });\n  const {\n      checkedIcon = defaultCheckedIcon,\n      color = 'primary',\n      icon: iconProp = defaultIcon,\n      indeterminate = false,\n      indeterminateIcon: indeterminateIconProp = defaultIndeterminateIcon,\n      inputProps,\n      size = 'medium',\n      className\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const icon = indeterminate ? indeterminateIconProp : iconProp;\n  const indeterminateIcon = indeterminate ? indeterminateIconProp : checkedIcon;\n  const ownerState = _extends({}, props, {\n    color,\n    indeterminate,\n    size\n  });\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(CheckboxRoot, _extends({\n    type: \"checkbox\",\n    inputProps: _extends({\n      'data-indeterminate': indeterminate\n    }, inputProps),\n    icon: /*#__PURE__*/React.cloneElement(icon, {\n      fontSize: (_icon$props$fontSize = icon.props.fontSize) != null ? _icon$props$fontSize : size\n    }),\n    checkedIcon: /*#__PURE__*/React.cloneElement(indeterminateIcon, {\n      fontSize: (_indeterminateIcon$pr = indeterminateIcon.props.fontSize) != null ? _indeterminateIcon$pr : size\n    }),\n    ownerState: ownerState,\n    ref: ref,\n    className: clsx(classes.root, className)\n  }, other, {\n    classes: classes\n  }));\n});\nprocess.env.NODE_ENV !== \"production\" ? Checkbox.propTypes /* remove-proptypes */ = {\n  // ┌────────────────────────────── Warning ──────────────────────────────┐\n  // │ These PropTypes are generated from the TypeScript type definitions. │\n  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │\n  // └─────────────────────────────────────────────────────────────────────┘\n  /**\n   * If `true`, the component is checked.\n   */\n  checked: PropTypes.bool,\n  /**\n   * The icon to display when the component is checked.\n   * @default <CheckBoxIcon />\n   */\n  checkedIcon: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'primary'\n   */\n  color: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['default', 'primary', 'secondary', 'error', 'info', 'success', 'warning']), PropTypes.string]),\n  /**\n   * The default checked state. Use when the component is not controlled.\n   */\n  defaultChecked: PropTypes.bool,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: PropTypes.bool,\n  /**\n   * If `true`, the ripple effect is disabled.\n   * @default false\n   */\n  disableRipple: PropTypes.bool,\n  /**\n   * The icon to display when the component is unchecked.\n   * @default <CheckBoxOutlineBlankIcon />\n   */\n  icon: PropTypes.node,\n  /**\n   * The id of the `input` element.\n   */\n  id: PropTypes.string,\n  /**\n   * If `true`, the component appears indeterminate.\n   * This does not set the native input element to indeterminate due\n   * to inconsistent behavior across browsers.\n   * However, we set a `data-indeterminate` attribute on the `input`.\n   * @default false\n   */\n  indeterminate: PropTypes.bool,\n  /**\n   * The icon to display when the component is indeterminate.\n   * @default <IndeterminateCheckBoxIcon />\n   */\n  indeterminateIcon: PropTypes.node,\n  /**\n   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.\n   */\n  inputProps: PropTypes.object,\n  /**\n   * Pass a ref to the `input` element.\n   */\n  inputRef: refType,\n  /**\n   * Callback fired when the state is changed.\n   *\n   * @param {React.ChangeEvent<HTMLInputElement>} event The event source of the callback.\n   * You can pull out the new checked state by accessing `event.target.checked` (boolean).\n   */\n  onChange: PropTypes.func,\n  /**\n   * If `true`, the `input` element is required.\n   * @default false\n   */\n  required: PropTypes.bool,\n  /**\n   * The size of the component.\n   * `small` is equivalent to the dense checkbox styling.\n   * @default 'medium'\n   */\n  size: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['medium', 'small']), PropTypes.string]),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n  /**\n   * The value of the component. The DOM API casts this to a string.\n   * The browser uses \"on\" as the default value.\n   */\n  value: PropTypes.any\n} : void 0;\nexport default Checkbox;","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nexport default arrayMap;\n","import Symbol from './_Symbol.js';\nimport isArguments from './isArguments.js';\nimport isArray from './isArray.js';\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nexport default isFlattenable;\n","import arrayPush from './_arrayPush.js';\nimport isFlattenable from './_isFlattenable.js';\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nexport default baseFlatten;\n","/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nexport default noop;\n","import Symbol from './_Symbol.js';\nimport arrayMap from './_arrayMap.js';\nimport isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default baseToString;\n","import baseToString from './_baseToString.js';\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nexport default toString;\n"],"names":["array","length","baseFlatten","idCounter","prefix","id","toString","defs","uniqueId","filter","append","attr","concat","idStart","idEnd","startMaskGradient","style","endMaskGradient","_ref","color","dash","className","containerRef","useRef","useEffect","graph","select","current","_jsx","ref","DEFAULT_DOT_AREA","DEFAULT_DOT_RADIUS","Math","PI","dPR","window","devicePixelRatio","defaultD3font","titlesD3font","yDataPlaceholder","placeholder","data","defaultMargins","top","right","bottom","left","steppedMax","values","max","Number","NEGATIVE_INFINITY","forEach","value","trueEntries","keys","object","key","isCanvasPowered","type","Graph","forwardRef","yData","xAxisValues","step","title","xAxisLabel","yAxisLabel","xScaleFactor","xColors","xWeights","xTooltip","onHover","onSelect","selfLegend","displayLegend","dataDisplay","setDataDisplay","mean","standardDeviation","margin","flippedXAxisValues","fullPrecision","marks","Object","drawRef","noop","onSelectRef","marksRef","hoveredRef","yEntries","yKeys","useMemo","entries","map","_ref2","offset","labelsHeight","requiredBottomOffset","yAxisLabelHegiht","yAxisValues","_ref3","dataset","reduce","cv","nv","v","round","textHeight","getTextSizeDOM","height","maxXAxisWidth","label","getTextWidth","maxYAxisWidth","xAxisLabelHegiht","requiredTopOffset","requiredLeftOffset","internalDataDisplay","setInternalDataDisplay","useState","lab","setLab","previousValues","labels","currentZoom","k","x","rescaleX","scale","canvas","canvasContext","node","getContext","textBackgroundURL","addTextBackground","startMaskURL","endMaskURL","addMasks","marksNode","main","allDotGroups","maskEnd","axes","y","xDot","xNormalizedWeights","arguments","undefined","clientWidth","width","clientHeight","dataEntries","dataKeys","_ref4","maxZoomExtent","precisionScale","scaleLog","range","ceil","domain","graphZoom","zoom","scaleExtent","call","on","event","preventDefault","transform","zoomPrecision","floor","log2","getZoomPrecision","min","precision","bind","bodyWidth","bodyHeight","remove","text","xMax","xMin","scaleLinear","g","axisBottom","ticks","tickFormat","d","extent","flatten","_ref5","_ref6","nice","transition","axisLeft","meanLines","selectAll","enter","merge","getMean","exit","sum","pv","n","stddev","sqrt","pow","a","b","sdRects","stdv","getMeanAndStdv","minIndex","invert","maxIndex","lineFn","line","defined","_","i","linesData","dashWidth","dashHeight","startAngle","endAngle","clearRect","fillStyle","maxInView","index","atomColor","fillRect","xPosition","yPosition","radius","weight","area","beginPath","arc","fill","xUnitWidth","dotGroups","actualXDot","nodes","xValue","mouse","closestIndex","dotDownOffsets","offsetDown","dotDownOffset","extra","sortedOffsets","push","sort","abs","HOVER_TEXT_SEPARATION","number","prevMark","mark","markRect","isInteger","_ref7","_ref8","hovered","addEventListener","removeEventListener","expectedCount","currentCount","Error","minimum","Infinity","maximum","normalizer","interpolate","handleChange","useCallback","_ref9","target","previous","nextLabels","some","Boolean","handleMouseOver","_ref10","handleMouseOut","_ref11","useImperativeHandle","children","_jsxs","_ref12","FormControlLabel","onChange","onMouseOver","onMouseOut","control","Checkbox","checked","inputProps","NICE_NAMES","get","_ref13","LineSample","font","context","document","createElement","measureText","element","content","createTextNode","appendChild","assign","position","visibility","body","createSvgIcon","getCheckboxUtilityClass","slot","generateUtilityClass","generateUtilityClasses","_excluded","CheckboxRoot","styled","SwitchBase","shouldForwardProp","prop","rootShouldForwardProp","name","overridesResolver","props","styles","ownerState","root","indeterminate","capitalize","size","theme","_extends","vars","palette","secondary","disableRipple","backgroundColor","action","activeChannel","mainChannel","hoverOpacity","alpha","active","checkboxClasses","disabled","defaultCheckedIcon","CheckBoxIcon","defaultIcon","CheckBoxOutlineBlankIcon","defaultIndeterminateIcon","IndeterminateCheckBoxIcon","React","inProps","_icon$props$fontSize","_indeterminateIcon$pr","useDefaultProps","checkedIcon","icon","iconProp","indeterminateIcon","indeterminateIconProp","other","_objectWithoutPropertiesLoose","classes","slots","composedClasses","composeClasses","useUtilityClasses","fontSize","clsx","iteratee","result","Array","spreadableSymbol","Symbol","isConcatSpreadable","isArray","isArguments","depth","predicate","isStrict","isFlattenable","arrayPush","symbolProto","prototype","symbolToString","baseToString","arrayMap","isSymbol"],"sourceRoot":""}