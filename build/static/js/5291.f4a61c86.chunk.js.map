{"version":3,"file":"static/js/5291.f4a61c86.chunk.js","mappings":"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","sources":["../node_modules/lodash-es/_baseToString.js","../node_modules/lodash-es/toString.js","../node_modules/lodash-es/_isFlattenable.js","../node_modules/lodash-es/_baseFlatten.js","../node_modules/lodash-es/_arrayMap.js","../node_modules/lodash-es/noop.js","utils/statistics/index.js","../node_modules/@mui/material/internal/svg-icons/CheckBoxOutlineBlank.js","../node_modules/@mui/material/internal/svg-icons/CheckBox.js","../node_modules/@mui/material/internal/svg-icons/IndeterminateCheckBox.js","../node_modules/@mui/material/Checkbox/checkboxClasses.js","../node_modules/@mui/material/Checkbox/Checkbox.js","../node_modules/lodash-es/flatten.js","../node_modules/lodash-es/uniqueId.js","components/graph/add-text-background/index.js","components/graph/add-masks/index.js","webpack://mdposit/./src/components/graph/style.module.css?7739","webpack://mdposit/./src/components/graph/line-sample/style.module.css?e034","components/graph/line-sample/index.js","components/graph/index.js","utils/document-measurer/index.js"],"sourcesContent":["import Symbol from './_Symbol.js';\nimport arrayMap from './_arrayMap.js';\nimport isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default baseToString;\n","import baseToString from './_baseToString.js';\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nexport default toString;\n","import Symbol from './_Symbol.js';\nimport isArguments from './isArguments.js';\nimport isArray from './isArray.js';\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nexport default isFlattenable;\n","import arrayPush from './_arrayPush.js';\nimport isFlattenable from './_isFlattenable.js';\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nexport default baseFlatten;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nexport default arrayMap;\n","/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nexport default noop;\n","// Statistics\n// Provide some usual statistics functions\n\n// Set a function which returns just the average\nexport const getMean = data => {\n  if (!data) return;\n  const sum = data.reduce((pv, cv) => pv + cv, 0);\n  const n = data.length;\n  return sum / n;\n};\n\n// Set a function which returns the average and standard deviation from a numeric array\nexport const getMeanAndStdv = data => {\n  if (!data) return;\n  const sum = data.reduce((pv, cv) => pv + cv, 0);\n  const n = data.length;\n  const mean = sum / n;\n  const stdv = Math.sqrt(\n    data.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n,\n  );\n  return { mean, stdv };\n};\n","'use client';\n\nimport * as React from 'react';\nimport createSvgIcon from '../../utils/createSvgIcon';\n\n/**\n * @ignore - internal component.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z\"\n}), 'CheckBoxOutlineBlank');","'use client';\n\nimport * as React from 'react';\nimport createSvgIcon from '../../utils/createSvgIcon';\n\n/**\n * @ignore - internal component.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"\n}), 'CheckBox');","'use client';\n\nimport * as React from 'react';\nimport createSvgIcon from '../../utils/createSvgIcon';\n\n/**\n * @ignore - internal component.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z\"\n}), 'IndeterminateCheckBox');","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getCheckboxUtilityClass(slot) {\n  return generateUtilityClass('MuiCheckbox', slot);\n}\nconst checkboxClasses = generateUtilityClasses('MuiCheckbox', ['root', 'checked', 'disabled', 'indeterminate', 'colorPrimary', 'colorSecondary', 'sizeSmall', 'sizeMedium']);\nexport default checkboxClasses;","'use client';\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"checkedIcon\", \"color\", \"icon\", \"indeterminate\", \"indeterminateIcon\", \"inputProps\", \"size\", \"className\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport refType from '@mui/utils/refType';\nimport composeClasses from '@mui/utils/composeClasses';\nimport { alpha } from '@mui/system/colorManipulator';\nimport SwitchBase from '../internal/SwitchBase';\nimport CheckBoxOutlineBlankIcon from '../internal/svg-icons/CheckBoxOutlineBlank';\nimport CheckBoxIcon from '../internal/svg-icons/CheckBox';\nimport IndeterminateCheckBoxIcon from '../internal/svg-icons/IndeterminateCheckBox';\nimport capitalize from '../utils/capitalize';\nimport { useDefaultProps } from '../DefaultPropsProvider';\nimport styled, { rootShouldForwardProp } from '../styles/styled';\nimport checkboxClasses, { getCheckboxUtilityClass } from './checkboxClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    classes,\n    indeterminate,\n    color,\n    size\n  } = ownerState;\n  const slots = {\n    root: ['root', indeterminate && 'indeterminate', `color${capitalize(color)}`, `size${capitalize(size)}`]\n  };\n  const composedClasses = composeClasses(slots, getCheckboxUtilityClass, classes);\n  return _extends({}, classes, composedClasses);\n};\nconst CheckboxRoot = styled(SwitchBase, {\n  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',\n  name: 'MuiCheckbox',\n  slot: 'Root',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, ownerState.indeterminate && styles.indeterminate, styles[`size${capitalize(ownerState.size)}`], ownerState.color !== 'default' && styles[`color${capitalize(ownerState.color)}`]];\n  }\n})(({\n  theme,\n  ownerState\n}) => _extends({\n  color: (theme.vars || theme).palette.text.secondary\n}, !ownerState.disableRipple && {\n  '&:hover': {\n    backgroundColor: theme.vars ? `rgba(${ownerState.color === 'default' ? theme.vars.palette.action.activeChannel : theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(ownerState.color === 'default' ? theme.palette.action.active : theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),\n    // Reset on touch devices, it doesn't add specificity\n    '@media (hover: none)': {\n      backgroundColor: 'transparent'\n    }\n  }\n}, ownerState.color !== 'default' && {\n  [`&.${checkboxClasses.checked}, &.${checkboxClasses.indeterminate}`]: {\n    color: (theme.vars || theme).palette[ownerState.color].main\n  },\n  [`&.${checkboxClasses.disabled}`]: {\n    color: (theme.vars || theme).palette.action.disabled\n  }\n}));\nconst defaultCheckedIcon = /*#__PURE__*/_jsx(CheckBoxIcon, {});\nconst defaultIcon = /*#__PURE__*/_jsx(CheckBoxOutlineBlankIcon, {});\nconst defaultIndeterminateIcon = /*#__PURE__*/_jsx(IndeterminateCheckBoxIcon, {});\nconst Checkbox = /*#__PURE__*/React.forwardRef(function Checkbox(inProps, ref) {\n  var _icon$props$fontSize, _indeterminateIcon$pr;\n  const props = useDefaultProps({\n    props: inProps,\n    name: 'MuiCheckbox'\n  });\n  const {\n      checkedIcon = defaultCheckedIcon,\n      color = 'primary',\n      icon: iconProp = defaultIcon,\n      indeterminate = false,\n      indeterminateIcon: indeterminateIconProp = defaultIndeterminateIcon,\n      inputProps,\n      size = 'medium',\n      className\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const icon = indeterminate ? indeterminateIconProp : iconProp;\n  const indeterminateIcon = indeterminate ? indeterminateIconProp : checkedIcon;\n  const ownerState = _extends({}, props, {\n    color,\n    indeterminate,\n    size\n  });\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(CheckboxRoot, _extends({\n    type: \"checkbox\",\n    inputProps: _extends({\n      'data-indeterminate': indeterminate\n    }, inputProps),\n    icon: /*#__PURE__*/React.cloneElement(icon, {\n      fontSize: (_icon$props$fontSize = icon.props.fontSize) != null ? _icon$props$fontSize : size\n    }),\n    checkedIcon: /*#__PURE__*/React.cloneElement(indeterminateIcon, {\n      fontSize: (_indeterminateIcon$pr = indeterminateIcon.props.fontSize) != null ? _indeterminateIcon$pr : size\n    }),\n    ownerState: ownerState,\n    ref: ref,\n    className: clsx(classes.root, className)\n  }, other, {\n    classes: classes\n  }));\n});\nprocess.env.NODE_ENV !== \"production\" ? Checkbox.propTypes /* remove-proptypes */ = {\n  // ┌────────────────────────────── Warning ──────────────────────────────┐\n  // │ These PropTypes are generated from the TypeScript type definitions. │\n  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │\n  // └─────────────────────────────────────────────────────────────────────┘\n  /**\n   * If `true`, the component is checked.\n   */\n  checked: PropTypes.bool,\n  /**\n   * The icon to display when the component is checked.\n   * @default <CheckBoxIcon />\n   */\n  checkedIcon: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'primary'\n   */\n  color: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['default', 'primary', 'secondary', 'error', 'info', 'success', 'warning']), PropTypes.string]),\n  /**\n   * The default checked state. Use when the component is not controlled.\n   */\n  defaultChecked: PropTypes.bool,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: PropTypes.bool,\n  /**\n   * If `true`, the ripple effect is disabled.\n   * @default false\n   */\n  disableRipple: PropTypes.bool,\n  /**\n   * The icon to display when the component is unchecked.\n   * @default <CheckBoxOutlineBlankIcon />\n   */\n  icon: PropTypes.node,\n  /**\n   * The id of the `input` element.\n   */\n  id: PropTypes.string,\n  /**\n   * If `true`, the component appears indeterminate.\n   * This does not set the native input element to indeterminate due\n   * to inconsistent behavior across browsers.\n   * However, we set a `data-indeterminate` attribute on the `input`.\n   * @default false\n   */\n  indeterminate: PropTypes.bool,\n  /**\n   * The icon to display when the component is indeterminate.\n   * @default <IndeterminateCheckBoxIcon />\n   */\n  indeterminateIcon: PropTypes.node,\n  /**\n   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.\n   */\n  inputProps: PropTypes.object,\n  /**\n   * Pass a ref to the `input` element.\n   */\n  inputRef: refType,\n  /**\n   * Callback fired when the state is changed.\n   *\n   * @param {React.ChangeEvent<HTMLInputElement>} event The event source of the callback.\n   * You can pull out the new checked state by accessing `event.target.checked` (boolean).\n   */\n  onChange: PropTypes.func,\n  /**\n   * If `true`, the `input` element is required.\n   * @default false\n   */\n  required: PropTypes.bool,\n  /**\n   * The size of the component.\n   * `small` is equivalent to the dense checkbox styling.\n   * @default 'medium'\n   */\n  size: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['medium', 'small']), PropTypes.string]),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n  /**\n   * The value of the component. The DOM API casts this to a string.\n   * The browser uses \"on\" as the default value.\n   */\n  value: PropTypes.any\n} : void 0;\nexport default Checkbox;","import baseFlatten from './_baseFlatten.js';\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nexport default flatten;\n","import toString from './toString.js';\n\n/** Used to generate unique IDs. */\nvar idCounter = 0;\n\n/**\n * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {string} [prefix=''] The value to prefix the ID with.\n * @returns {string} Returns the unique ID.\n * @example\n *\n * _.uniqueId('contact_');\n * // => 'contact_104'\n *\n * _.uniqueId();\n * // => '105'\n */\nfunction uniqueId(prefix) {\n  var id = ++idCounter;\n  return toString(prefix) + id;\n}\n\nexport default uniqueId;\n","import { uniqueId } from 'lodash-es';\n\nconst addTextBackground = defs => {\n  const id = uniqueId('background-');\n\n  const filter = defs\n    .append('filter')\n    .attr('x', 0)\n    .attr('y', 0)\n    .attr('width', 1)\n    .attr('height', 1)\n    .attr('id', id);\n  filter.append('feFlood').attr('flood-color', 'white');\n  filter.append('feComposite').attr('in', 'SourceGraphic');\n  return `url(#${id})`;\n};\n\nexport default addTextBackground;\n","import { uniqueId } from 'lodash-es';\n\nconst addMasks = defs => {\n  const idStart = uniqueId('gradient-start-');\n  const idEnd = uniqueId('gradient-end-');\n  const startMaskGradient = defs.append('linearGradient').attr('id', idStart);\n  startMaskGradient\n    .append('stop')\n    .attr('offset', '0%')\n    .style('stop-color', 'white')\n    .style('stop-opacity', '1');\n  startMaskGradient\n    .append('stop')\n    .attr('offset', '100%')\n    .style('stop-color', 'white')\n    .style('stop-opacity', '0');\n  const endMaskGradient = defs.append('linearGradient').attr('id', idEnd);\n  endMaskGradient\n    .append('stop')\n    .attr('offset', '0%')\n    .style('stop-color', 'white')\n    .style('stop-opacity', '0');\n  endMaskGradient\n    .append('stop')\n    .attr('offset', '100%')\n    .style('stop-color', 'white')\n    .style('stop-opacity', '1');\n  return [`url(#${idStart})`, `url(#${idEnd})`];\n};\n\nexport default addMasks;\n","// extracted by mini-css-extract-plugin\nexport default {\"default\":\"style_default__PoK16\",\"flexible\":\"style_flexible__UEdHy\",\"graph-container\":\"style_graph-container__j1+gF\",\"graph-legend\":\"style_graph-legend__z5iWz\",\"graph-display-legend\":\"style_graph-display-legend__zhM2L\",\"line-sample\":\"style_line-sample__1vgXB\"};","// extracted by mini-css-extract-plugin\nexport default {\"default\":\"style_default__IVrx2\"};","import React, { useRef, useEffect } from 'react';\nimport { select } from 'd3';\n\nimport style from './style.module.css';\n\nconst LineSample = ({ color, dash, className }) => {\n  // Referenced document element where d3 is rendered\n  const containerRef = useRef(null);\n\n  // This useEffect must be run only once\n  useEffect(() => {\n    const graph = select(containerRef.current);\n    graph.attr('width', 50).attr('height', 5);\n    graph\n      .append('line')\n      .style('stroke', color)\n      .style('stroke-dasharray', dash)\n      .style('stroke-width', 3)\n      .attr('x1', 0)\n      .attr('y1', 0)\n      .attr('x2', 50)\n      .attr('y2', 0);\n  }, []);\n  // Maybe might need to double-check that and remove the exception\n\n  return (\n    <svg ref={containerRef} className={className ? className : style.default} />\n  );\n};\n\nexport default LineSample;\n","import React, {\n  useState,\n  useCallback,\n  useRef,\n  useEffect,\n  useMemo,\n  forwardRef,\n  useImperativeHandle,\n} from 'react';\nimport { noop, flatten } from 'lodash-es';\nimport {\n  select,\n  scaleLinear,\n  scaleLog,\n  axisBottom,\n  axisLeft,\n  extent,\n  line,\n  mouse,\n  zoom,\n  event,\n  area,\n} from 'd3';\n\nimport { FormControlLabel, Checkbox } from '@mui/material';\n\nimport { NICE_NAMES } from '../../utils/constants';\n\nimport addTextBackground from './add-text-background';\nimport addMasks from './add-masks';\n\nimport { getTextWidth, getTextSizeDOM } from '../../utils/document-measurer';\n\nimport { getMean, getMeanAndStdv } from '../../utils/statistics';\n\nimport style from './style.module.css';\n\nimport LineSample from './line-sample';\n\n// Number of data points to be represented at the same time FOR EACH dataset\n// WARNING: The component would support quite more points with good performace\n// WARNING: However, more points would make the visualization less 'comfortable'\n// This is the minimum number of data points to be shown at maximum zoom (i.e. maximum precision)\n// Thus it limits how much the graph can be zoomed\n// At the same time, it is the maximum number of points to be shown at minimum zoom\n// Thus it limits the precision at minimum zoom\n// DANI: Hay algunas escalas del d3 que no llegué a comprender bien\n// DANI: Puede que el número no se respete del todo\nconst NUMBER_OF_DATA_POINTS_ON_SCREEN = 100; // i.e. minimum number of points in screen\n\n// Set the separation between text labels which appear when we hover data points\nconst HOVER_TEXT_SEPARATION = 25;\n\n// Set a small offset to be added between normal labels and 90 degrees rotated labels\n// This offset is added between the y labels (normal) and the y title (rotated)\n// This offset is added between the x labels (rotated) and the x title (normal)\nconst roatatedTextOffset = 9; // In px\n\n// Set a small offset to keep away the axis labels and the axis values\n// They are very close to the axis values by default\nconst axisLabelsOffset = 9; // In px\n\n// Set the default dot radius and thus calculate the default dot area\nconst DEFAULT_DOT_RADIUS = 3;\nconst DEFAULT_DOT_AREA = Math.PI * DEFAULT_DOT_RADIUS ** 2;\n\nconst dPR = window.devicePixelRatio || 1;\n\n// According to d3 documentation\nconst defaultD3font = 'normal 10px sans-serif';\n// Experimentally verfied\nconst titlesD3font = 'normal 14px sans-serif';\n\nconst yDataPlaceholder = { placeholder: { data: [0] } };\nconst defaultMargins = { top: 10, right: 10, bottom: 10, left: 10 };\n\n// This function is a workaround to calculate maximum values from an array without spread syntax\n// Some browsers (e.g. Chrome) do not support large amount of arguments in a function\n// For this reason, Math.max(...values) will fail if the 'values' array is long enough\n// The returned error is “RangeError: Maximum call stack size exceeded”\nconst steppedMax = values => {\n  let max = Number.NEGATIVE_INFINITY;\n  values.forEach(value => {\n    max = Math.max(value, max);\n  });\n  return max;\n};\n\n// Create an object with all specified keys and all values as true\nconst trueEntries = keys => {\n  const object = {};\n  keys.forEach(key => (object[key] = true));\n  return object;\n};\n\nconst isCanvasPowered = type => type === 'dash' || type === 'dots';\n\n// The expected input data (y) is:\n// {\n//    dataset1:{\n//      data: [... the main data ...]\n//      average: float,\n//      color: 'red',\n//      dash: \"5, 5\",\n//    }\n//    dataset2:{...}\n// }\n\nconst Graph = forwardRef(({ \n  yData,                      // The main data\n  xAxisValues,                // The main data to be represented \n  step = 1, \n  title,                      // Graph title \n  xAxisLabel,                 // The x axis label text\n  yAxisLabel,                 // The y axis label text \n  xScaleFactor = 1,           // The difference between x values\n  xColors,                    // Color each different dot in the graph dependeing on its x index\n  xWeights,                   // Define the weights for each x value. This is only compatible with type = 'dots' and makes dots bigger \n  xTooltip,                   // The function to set what to show on the tooltip based in the x value where the mouse is hovering\n  yPadding = 0,               // Add a padding to the y axis range\n  type = 'line',              // Set the type of graph to render. Accepted values: line, dash, dots\n  onHover,  \n  labelsOnHover = false,      // Set the labels to be shown when hovering the graph                   \n  onSelect,                   \n  selfLegend = false,         \n  displayLegend = false,      \n  dataDisplay,                // Object with each dataset name and a value of true/false to set which data is displayed \n  setDataDisplay,             // dataDisplay setter    \n  mean = false,               // Display the mean line in the graph \n  standardDeviation = false,  // Display the standard deviation area in the graph\n  margin = defaultMargins,    // Set an extra margin around the graph\n  flippedXAxisValues = false, // Set if values in x axis is horizontal (false) or vertical (true) \n  fullPrecision = false,      // If true, draw all points in the graph no matter how many points are there \n  className,                  // Force a classname for the overall component element\n  marks,                      // Mark x values by displaying a vertical line in their positions\n  areaStdDev = false,          // Display the standard deviation area per point\n  zeroLine = false,            // Draw a line at y=0\n}, \n  ref) => { \n  // -  style: object with all the style names (keys) and their values according to d3\n  // -  attr: object with all the attribute names (keys) and their values according to d3\n  // -  x: the position of the mark according to the x axis\n  // Set a fake dataset to allow the graph to work when no data is passed\n  if (!yData || Object.keys(yData).length === 0) yData = yDataPlaceholder;\n\n  // Referenced document element where d3 is rendered\n  const containerRef = useRef(null);\n  // Referenced function which allows to update the cart without having to remake it\n  const drawRef = useRef(noop);\n  const onSelectRef = useRef(noop);\n  const marksRef = useRef(noop);\n  const hoveredRef = useRef(noop);\n\n  // Get each dataset\n  const { yEntries, yKeys } = useMemo(() => {\n    const yEntries = Object.entries(yData);\n    const yKeys = yEntries.map(([key]) => key);\n    return { yEntries, yKeys };\n  }, [yData]);\n\n  // ----------------------------------------------------------------------------------------\n\n  // OFFSETS: Estimate the space needed for all the labels and titles to not overlap\n  // DANI: Toda esta parte no se actualiza en el drawRef en caso de que los valores de las labels cambien\n  // DANI: Esto da problemas si queremos cargar un graph sin data para luego ir metiendo data\n  // DANI: El graph se creará sin margen para las labels y cuando introduzcamos data habrá un overlap\n  const {\n    offset,\n    labelsHeight,\n    requiredBottomOffset,\n    yAxisLabelHeight,\n  } = useMemo(() => {\n    // Set the yAxisValues by adding all dataset 'data' values\n    let yAxisValues = yEntries\n      .map(([, dataset]) => dataset.data)\n      .reduce((cv, nv) => cv.concat(nv));\n    // Round values if they are numeric, since labels just reach x.00\n    yAxisValues = yAxisValues.map(v => Math.round(v * 100) / 100);\n\n    // Measure the height of normal and text and labels\n    const textHeight = getTextSizeDOM('|', defaultD3font).height;\n    const labelsHeight =\n      getTextSizeDOM('|', titlesD3font).height + axisLabelsOffset;\n\n    // Get the calculated widths of all y labels and select the maximum\n    // In addition, add a small offset between labels and the axis which is added further\n    // This offset is only in x axes, which are rotated 90 degrees and end too much close to the axis\n    const maxXAxisWidth = xAxisValues\n      ? steppedMax(\n          xAxisValues.map(label => getTextWidth(label, defaultD3font)),\n        ) + roatatedTextOffset\n      : 10;\n    // Get the calculated widths of all y labels and select the maximum\n    const maxYAxisWidth = steppedMax(\n      yAxisValues.map(label => getTextWidth(label, defaultD3font)),\n    );\n\n    // In addition, add a small offset between labels and the axis which is added further\n    // This offset is only in x axes, which are rotated 90 degrees and end too much close to the axis\n    const xAxisLabelHegiht = xAxisLabel ? labelsHeight : 0;\n    const yAxisLabelHeight = yAxisLabel ? labelsHeight + roatatedTextOffset : 0;\n\n    // Finally, estimate the space needed by axes, titles, etc.\n    const requiredTopOffset = title ? labelsHeight + axisLabelsOffset : 0;\n    const requiredBottomOffset = flippedXAxisValues\n      ? maxXAxisWidth + xAxisLabelHegiht\n      : textHeight + xAxisLabelHegiht;\n    const requiredLeftOffset =\n      yAxisValues.length === 1 && yData !== yDataPlaceholder\n        ? Math.max(maxYAxisWidth, getTextWidth(yAxisLabel, titlesD3font))\n        : maxYAxisWidth + yAxisLabelHeight;\n\n    // Set the dimensions and offsets of the graph\n    const offset = {\n      top: requiredTopOffset + margin.top,\n      right: margin.right,\n      bottom: requiredBottomOffset + margin.bottom,\n      left: requiredLeftOffset + margin.left,\n    };\n    return { offset, labelsHeight, requiredBottomOffset, yAxisLabelHeight };\n  }, [\n    flippedXAxisValues,\n    margin,\n    title,\n    xAxisLabel,\n    xAxisValues,\n    yAxisLabel,\n    yData,\n    yEntries,\n  ]);\n\n  // ----------------------------------------------------------------------------------------\n\n  // Object with entries defining which data is displayed (true) or hidden (false)\n  // Each entry has the same key that its corresponding dataset\n  // First set a defualt internal state for cases where it is not passed with the arguments\n  const [internalDataDisplay, setInternalDataDisplay] = useState(\n    trueEntries(yKeys),\n  );\n  // Update the internal data display when data changes\n  useEffect(() => {\n    setInternalDataDisplay(trueEntries(yKeys));\n  }, [yKeys]);\n\n  // If the data display state was passed then use it\n  // Otherwise, use the internal state\n  const [lab, setLab] = dataDisplay\n    ? [dataDisplay, setDataDisplay]\n    : [internalDataDisplay, setInternalDataDisplay];\n\n  const previousValues = useRef({\n    data: yDataPlaceholder,\n    labels: lab,\n    currentZoom: { k: 1, x: 0, rescaleX: scale => scale },\n    xAxisLabel,\n    yAxisLabel,\n    xAxisValues,\n    onSelect,\n    step,\n    marks,\n    areaStdDev:areaStdDev,\n    yPadding: yPadding\n  });\n\n  // This useEffect must be run only once\n  // The graph content is updated through the 'drawRef' referenced function\n  useEffect(() => {\n    // Set the d3 base\n    // Use canvas to display the dash blocks since d3 is not as efficient\n    let canvas;\n    let canvasContext;\n    if (isCanvasPowered(type)) {\n      canvas = select(containerRef.current).append('canvas');\n      canvasContext = canvas\n        .node()\n        .getContext('2d' /*, {desynchronized: true}*/);\n    }\n    const graph = select(containerRef.current).append('svg');\n    // 'defs' is an element used to store graphical data which is not rendered directly\n    // Graphics in defs are displayed later by refering them\n    const defs = graph.append('defs');\n    // text background\n    const textBackgroundURL = addTextBackground(defs);\n\n    // mask opacity\n    const [startMaskURL, endMaskURL] = addMasks(defs);\n\n    // Set the marks node now, so they are not placed over the graph\n    const marksNode = graph.append('g');\n\n    const main = graph.append('g');\n\n    // Set the dots in the graph\n    const allDotGroups = main.append('g');\n\n    // order is important, everything before that will be hidden by masks\n    // masks\n    graph\n      .append('rect')\n      .attr('x', 0)\n      .attr('y', 0)\n      .attr('width', offset.left)\n      .attr('height', '100%')\n      .style('fill', startMaskURL);\n    const maskEnd = graph\n      .append('rect')\n      .attr('y', 0)\n      .attr('height', '100%')\n      .style('fill', endMaskURL);\n\n    // axes\n    const axes = {\n      x: graph.append('g'),\n      y: graph.append('g'),\n    };\n\n    // Set an independent dot which is in the x axis and holds the x tooltip\n    const xDot = graph.append('g');\n\n    // This ref allows to update the graph without having to remake the whole graph\n    drawRef.current = ({\n      data = previousValues.current.data,\n      labels = previousValues.current.labels,\n      step = previousValues.current.step,\n      xAxisLabel = previousValues.current.xAxisLabel,\n      yAxisLabel = previousValues.current.yAxisLabel,\n      currentZoom = previousValues.current.currentZoom,\n      xAxisValues = previousValues.current.xAxisValues,\n      onSelect = previousValues.current.onSelect,\n      marks = previousValues.current.marks,\n      offset = previousValues.current.offset,\n      labelsHeight = previousValues.current.labelsHeight,\n      requiredBottomOffset = previousValues.current.requiredBottomOffset,\n      yAxisLabelHeight = previousValues.current.yAxisLabelHeight,\n      xColors = previousValues.current.xColors,\n      xNormalizedWeights = previousValues.current.xNormalizedWeights,\n      xTooltip = previousValues.current.xTooltip,\n      areaStdDev = previousValues.current.areaStdDev,\n      yPadding = previousValues.current.yPadding,\n    } = {}) => {\n      // Change the graph size according to the left offset\n      graph.attr('width', offset.left);\n\n      // Save a few values for further reference\n      // These values must be saved at frist since other noop references read them from the reference\n      previousValues.current.step = step;\n      previousValues.current.xAxisValues = xAxisValues;\n\n      // container size\n      const { clientWidth: width, clientHeight: height } = containerRef.current;\n\n      const dataEntries = Object.entries(data);\n      const dataKeys = dataEntries.map(([key]) => key);\n\n      // ----------------------------------------------------------------------------\n\n      // ZOOM\n\n      // The minimum and default zoom value is 1\n      const minZoomExtent = 1;\n\n      //   make zoom extent dynamic depending on number of data points\n      //   ↳ results in similar precision at maximum zoom regardless of data size\n      const maxZoomExtent =\n        dataEntries[0][1].data.length / NUMBER_OF_DATA_POINTS_ON_SCREEN;\n\n      // Set the number of points to be represented\n      // The maximum precision is always 1\n      // i.e. When zoom is at maximum value all points in the window range must be shown\n      const precisionScale = scaleLog().range(\n        fullPrecision ? [1, 1] : [Math.ceil(maxZoomExtent), minZoomExtent],\n      );\n\n      precisionScale.domain([minZoomExtent, maxZoomExtent]);\n\n      // Get the precision to be used according to the zoom value\n      // The zoom value is a numeric value which ranges from minZoomExtent (default) to maxZoomExtent\n      const getZoomPrecision = k =>\n        2 ** Math.floor(Math.log2(precisionScale(k)));\n\n      // Set up zoom behavior with translation extent to prevent panning beyond data boundaries\n      const graphZoom = zoom()\n        .scaleExtent([minZoomExtent, maxZoomExtent])\n        .translateExtent([\n          [0, 0],           // Left limit at the minimum x value\n          [width, height]   // Right/bottom boundaries\n        ]);\n\n      // By default, the zoom in/out event of d3 prevents the verticall scroll on mouse wheel\n      // However, when zoom has reached the maximum or minimum limit, the scroll is re-established\n      // The 'on wheel' eventdown here prevents that furtive scroll\n      graph.call(graphZoom).on('wheel', () => event.preventDefault());\n      // Update precision and rescaleX on zoom (i.e. on mouse wheel)\n      graphZoom.on('zoom', () => {\n        drawRef.current({\n          currentZoom: event.transform,\n        });\n      });\n\n      // Get the the current zoom 'k' value\n      // If it is bigger thant the maximum extent then use the maximum extent instead\n      // This may happen when the dataset is changed while the zoom is in the maximum\n      const k = Math.min(currentZoom.k, maxZoomExtent);\n      const zoomPrecision = getZoomPrecision(k);\n      const precision = isCanvasPowered(type) ? 1 : zoomPrecision;\n      const rescaleX = currentZoom.rescaleX.bind(currentZoom);\n\n      // Save precision for further reference\n      previousValues.current.precision = precision;\n\n      // ----------------------------------------------------------------------------\n\n      // DANI: Esto es mio (experimental)\n      const bodyWidth = width - offset.left - offset.right;\n      const bodyHeight = height - offset.top - offset.bottom;\n\n      graph.attr('width', width).attr('height', height);\n      if (canvas) {\n        canvas.attr('width', width * dPR).attr('height', height * dPR);\n        canvas.style('width', `${width}px`).style('height', `${height}px`);\n      }\n\n      maskEnd.attr('x', width - offset.right).attr('width', offset.right);\n\n      // Draw the title over the graph\n      if (title) {\n        // Remove the previous title\n        graph.select('#title').remove();\n        axes.title = graph\n          .append('text')\n          .attr('id', 'title')\n          .attr('class', 'title')\n          .style('text-anchor', 'middle')\n          .attr('x', width / 2)\n          .attr('y', margin.top + labelsHeight)\n          .text(title);\n      }\n\n      // Set the maximum x index\n      const xMaxIndex = dataEntries[0][1].data.length;\n\n      // Set the x minimum and maximum limits\n      const xMin = 0;\n      const xMax = xMaxIndex * step;\n\n      // Save this values to further reference\n      previousValues.current.xMin = xMin;\n      previousValues.current.xMax = xMax;\n\n      // Set a function which calculates the x position in screen\n      // Note that values from this function change when you grab/scroll in the graph\n      const x = rescaleX(\n        scaleLinear()\n          .domain([xMin, xMax])\n          .range([offset.left, width - offset.right]),\n      );\n      previousValues.current.x = x;\n\n      const xAxis = g =>\n        g.attr('transform', `translate(0, ${height - offset.bottom})`).call(\n          // DANI: Estos ticks los he puesto a mano tras comprobar que quedaban bien\n          axisBottom(x)\n            .ticks(7, '.2f')\n            .tickFormat(d => (xAxisValues ? xAxisValues[d] : d)),\n        );\n      axes.x.call(xAxis);\n\n      // Set the x axis label\n      if (xAxisLabel) {\n        // Remove the previous label\n        graph.select('#xlab').remove();\n        axes.xAxisLabel = graph\n          .append('text')\n          .attr('id', 'xlab')\n          .attr('class', 'x label')\n          .attr('text-anchor', 'middle')\n          .attr('x', offset.left + bodyWidth / 2)\n          .attr('y', offset.top + bodyHeight + requiredBottomOffset)\n          .text(xAxisLabel);\n      }\n\n      // y axis/axes\n      const yExtent = extent(\n        flatten(\n          dataEntries\n            .filter(([key]) => labels[key])\n            .map(([, { data }]) => extent(data)),\n        ),\n      );\n      \n      // Add padding to the y-axis range\n      const y = scaleLinear()\n        .domain([yExtent[0] - yPadding, yExtent[1] + yPadding])\n        .nice()\n        .range([height - offset.bottom, offset.top]);\n\n      const yAxis = g =>\n        g\n          .attr('transform', `translate(${offset.left}, 0)`)\n          .transition()\n          .call(axisLeft(y));\n      //.call(axisLeft(y).ticks(8, '.2f')); // Use this to force the number of decimals in labels\n      axes.y.call(yAxis);\n\n      // Set the y axis label\n      if (yAxisLabel) {\n        graph.select('#ylab').remove();\n        axes.yAxisLabel = graph\n          .append('text')\n          .attr('id', 'ylab')\n          .attr('class', 'y label')\n          .attr('text-anchor', 'middle')\n          .attr('x', -(offset.top + bodyHeight / 2))\n          .attr(\n            'y',\n            margin.left +\n              yAxisLabelHeight -\n              roatatedTextOffset -\n              axisLabelsOffset,\n          )\n          .attr('transform', 'rotate(-90)')\n          .text(yAxisLabel);\n      }\n\n      // Add zero line if requested\n      if (zeroLine) {\n        const zeroLineEl = main.selectAll('line.zero').data([0]);\n        zeroLineEl\n          .enter()\n          .append('line')\n          .attr('class', 'zero')\n          .merge(zeroLineEl)\n          .attr('stroke', '#000000')\n          .attr('stroke-width', 1)\n          .attr('stroke-dasharray', '5,5')\n          .attr('x1', x(xMin))\n          .attr('x2', x(xMax))\n          .attr('y1', y(0))\n          .attr('y2', y(0))\n          .attr('opacity', 0.3);\n        zeroLineEl.exit().remove();\n      }\n\n      // mean line\n      if (mean) {\n        // Represent a line with this average value along the whole graph\n        const meanLines = main.selectAll('line.mean').data(dataKeys);\n        meanLines\n          .enter()\n          .append('line')\n          .attr('class', 'mean')\n          .merge(meanLines)\n          .attr('stroke', d => (data[d] && data[d].color) || 'black')\n          .attr('x1', x(xMin))\n          .attr('x2', x(xMax))\n          .attr('y1', d => y(getMean(data[d].data)))\n          .attr('y2', d => y(getMean(data[d].data)))\n          .transition()\n          .attr('opacity', d => (labels[d] ? 0.5 : 0));\n        meanLines.exit().remove();\n      }\n      // mean ± 1σ area\n      if (standardDeviation) {\n        for (const [, dataset] of dataEntries) {\n          const data = dataset.data;\n          if (!data) continue;\n          const sum = data.reduce((pv, cv) => pv + cv, 0);\n          const n = data.length;\n          const mean = sum / n;\n          dataset.stddev = Math.sqrt(\n            data.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n,\n          );\n        }\n        const sdRects = main.selectAll('rect.sd').data(dataKeys);\n        sdRects\n          .enter()\n          .append('rect')\n          .attr('class', 'sd')\n          .merge(sdRects)\n          .attr('fill', d => (data[d] && data[d].color) || 'black')\n          .attr('x', x(xMin))\n          .attr('width', x(xMax) - x(xMin))\n          .attr('y', d => {\n            const { mean, stdv } = getMeanAndStdv(data[d].data);\n            return y(mean + stdv);\n          })\n          .attr('height', d => {\n            const { mean, stdv } = getMeanAndStdv(data[d].data);\n            return y(mean - stdv) - y(mean + stdv);\n          })\n          .transition()\n          .attr('opacity', d => (labels[d] ? 0.1 : 0));\n        sdRects.exit().remove();\n      }\n      if (previousValues && previousValues.current.areaStdDev !== areaStdDev) {\n        // Remove area if areaStdDev changes\n        main.selectAll('path.density-sd').remove();\n      }\n      if (areaStdDev) {\n        // Create area generator for the standard deviation bands\n        const areaGenerator = area()\n          .x(d => x(d.x))\n          .y0(d => y(d.value - d.stddev))\n          .y1(d => y(d.value + d.stddev));\n\n        const sdAreas = main.selectAll('path.density-sd').data(dataKeys);\n        sdAreas\n          .enter()\n          .append('path')\n          .attr('class', 'density-sd')\n          .merge(sdAreas)\n          .attr('fill', d => (data[d] && data[d].color) || 'black')\n          .attr('d', d => {\n            if (!data[d] || !data[d].data || !data[d].areaStdDev) return null;\n            \n            // Create array of points with their standard deviations\n            // Filter points based on precision just like the line drawing\n            const points = data[d].data\n              .filter((_, i) => i % precision === 0)\n              .map((value, i) => ({\n                x: i * step * precision,\n                value: value,\n                stddev: data[d].areaStdDev[i * precision]\n              }));\n            \n            return areaGenerator(points);\n          })\n          .transition()\n          .attr('opacity', d => (labels[d] ? 0.35 : 0.0));\n        sdAreas.exit().remove();\n      }\n      const minIndex = Math.floor(x.invert(0) / step / precision);\n      const maxIndex = Math.ceil(x.invert(width) / step / precision);\n      // In case it is a classical line graph\n      if (type === 'line') {\n        // Define the data line positions\n        const lineFn = line()\n          .defined((_, i) => i >= minIndex && i <= maxIndex)\n          .x((_, i) => x(i * step * precision))\n          .y(d => y(d));\n\n        // Draw the data lines\n        // First set the lines/data mapping\n        const linesData = main.selectAll('path.line').data(dataKeys);\n        // Add as many lines as required according to the mapped data\n        linesData\n          .enter()\n          .append('path')\n          .attr('class', 'line')\n          .attr('fill', 'none')\n          // Update existing lines with the mapped data\n          .merge(linesData)\n          .attr('stroke', d => data[d].color || 'black')\n          .style('stroke-dasharray', d =>\n            data[d].dash ? data[d].dash : undefined,\n          )\n          .attr('stroke-linejoin', 'round')\n          .attr('stroke-linecap', 'round')\n          .attr('d', d =>\n            lineFn(data[d].data.filter((_, i) => i % precision === 0)),\n          )\n          .transition()\n          .attr('opacity', d => (labels[d] ? 1 : 0))\n          .attr('stroke-width', 1.5);\n        // Remove lines which are not required anymore according to the mapped data\n        linesData.exit().remove();\n        // Save this node for further reference\n        previousValues.current.linesData = linesData;\n      }\n      // NEVER FORGET: We do not use d3 dots since they are way less efficient than canvas\n      // In case it is a dash graph\n      else if (isCanvasPowered(type) && canvasContext) {\n        // For the dash\n        const dashWidth = Math.max(1, x(1) - x(0));\n        const dashHeight = 5;\n        // For the dots\n        const startAngle = 0;\n        const endAngle = 2 * Math.PI;\n        canvasContext.clearRect(0, 0, width, height);\n        for (const [key, { data: values, color }] of Object.entries(data)) {\n          if (!labels[key]) continue;\n          canvasContext.fillStyle = color || '#000000';\n          const maxInView = Math.min(values.length - 1, maxIndex);\n          // each atom in view\n          for (\n            let index = Math.max(0, minIndex);\n            index <= maxInView;\n            index += 1\n          ) {\n            // Skip the follwoing dot if the zoom precision says so\n            if (index % zoomPrecision !== 0) continue;\n            // Color the rectangle according to the equivalent atom element\n            if (xColors) {\n              const atomColor = xColors[index];\n              // If the color is white (i.e. it is an hydrogen) then paint it slightly grey\n              // The background is white so a white rectangle would be not visible\n              canvasContext.fillStyle =\n                atomColor === 'white' ? '#eeeeee' : atomColor;\n            }\n            // Draw a rectangle\n            if (type === 'dash') {\n              canvasContext.fillRect(\n                (x(index * step * precision) - dashWidth / 2) * dPR,\n                (y(values[index]) - dashHeight / 2) * dPR,\n                dashWidth * dPR,\n                dashHeight * dPR,\n              );\n            }\n            // Draw a circle\n            if (type === 'dots') {\n              // Set the x y positions\n              const xPosition =\n                (x(index * step * precision) - dashWidth / 2) * dPR;\n              const yPosition = (y(values[index]) - dashHeight / 2) * dPR;\n              // Set the radius, which may be affected by the x weights, when passed\n              let radius = DEFAULT_DOT_RADIUS; // Its 3\n              if (xNormalizedWeights) {\n                const weight = xNormalizedWeights[index];\n                const area = DEFAULT_DOT_AREA * weight;\n                radius = Math.sqrt(area / Math.PI);\n              }\n              // Draw the circle\n              canvasContext.beginPath();\n              canvasContext.arc(\n                xPosition,\n                yPosition,\n                radius,\n                startAngle,\n                endAngle,\n              );\n              canvasContext.fill();\n            }\n          }\n        }\n      }\n\n      // Calculate the width of a vertical lines used to highlight specific x values\n      const xUnitWidth = Math.max(1, x(zoomPrecision * step) - x(0));\n      previousValues.current.xUnitWidth = xUnitWidth;\n      // Place vertical lines for specified marks\n      marksRef.current({ marks });\n\n      // dots over the selected vertical line\n      // Here we just delete previous dots and start again instead of updating them\n      allDotGroups.selectAll('g.dot-group').remove();\n      const dotGroups = allDotGroups\n        .selectAll('g.dot-group')\n        .data([...dataKeys])\n        .enter()\n        .append('g')\n        .attr('class', 'dot-group')\n        .attr('opacity', 0);\n      dotGroups\n        .append('circle')\n        .attr('cx', 0)\n        .attr('cy', 0)\n        .attr('r', 5)\n        .attr('fill', d => (data[d] && data[d].color) || 'black');\n      dotGroups\n        .append('text')\n        .style('text-anchor', 'middle')\n        .style('font-weight', 'bold')\n        .style('paint-order', 'stroke')\n        .attr('y', '-5px')\n        .attr('fill', d => (data[d] && data[d].color) || 'black')\n        .attr('stroke', 'rgba(255, 255, 255, 0.5)')\n        .attr('stroke-width', 5)\n        .attr('filter', textBackgroundURL);\n\n      // Set the dot over the x axis and the label highlighting the selected x value\n      xDot.selectAll('g').remove();\n      const actualXDot = xDot.append('g')\n        .attr('opacity', 0);\n      actualXDot\n        .append('circle')\n        .attr('cx', 0)\n        .attr('cy', 0)\n        .attr('r', 5)\n        .attr('fill', 'black');\n      actualXDot\n        .append('text')\n        .style('text-anchor', 'middle')\n        .style('font-weight', 'bold')\n        .style('paint-order', 'stroke')\n        .attr('y', '-5px')\n        .attr('fill', 'black')\n        .attr('stroke', 'rgba(255, 255, 255, 0.5)')\n        .attr('stroke-width', 5)\n        .attr('filter', textBackgroundURL);\n\n      // mouse move handler\n      graph.on('mousemove', (_, index, nodes) => {\n        // 'nodes' contain the mouse position data\n        // 'index' is apparently always 0\n        const [xValue] = mouse(nodes[index]);\n        // Get the closest x axis index to the current mouse position\n        const closestIndex =\n          Math.round(x.invert(xValue) / zoomPrecision / step) * zoomPrecision;\n        // If the closest index is out of range then there is no tooltip to show\n        if (closestIndex < 0 || closestIndex > xMaxIndex) return;\n        // Track the implicit position of all hovering dots\n        // This is useful to know if dot texts would overlap\n        const dotDownOffsets = {};\n        allDotGroups\n          // Set the x position of the dot\n          .attr('transform', `translate(${x(closestIndex * step)}, 0)`)\n          // Dots become invisible if the closest index is not between the minimum and the maximum\n          .attr(\n            'opacity',\n            closestIndex * step >= xMin && closestIndex * step < xMax ? 1 : 0,\n          );\n        allDotGroups\n          .selectAll('g.dot-group')\n          // Set the y position of the dot\n          .attr('transform', d => {\n            if (!labels[d]) return;\n            // Just over the correspondong line for other values\n            const offsetDown = (y(data[d].data[closestIndex]) || 0) + 2.5;\n            // Record the current offset down\n            dotDownOffsets[d] = offsetDown;\n            return `translate(0, ${offsetDown})`;\n          })\n          .attr('opacity', d => (d === 'x' || labels[d] && data[d].data[closestIndex]? 1 : 0))\n          .selectAll('text')\n          .attr('transform', d => {\n            if (!labels[d]) return;\n            // Find if an offset is too close to others and then move it to a better place (above)\n            let dotDownOffset = dotDownOffsets[d];\n            let extra = 0;\n            // Sort other offsets from more (below) to less (above)\n            const sortedOffsets = [];\n            for (const [key, value] of Object.entries(dotDownOffsets)) {\n              if (key !== d) sortedOffsets.push(value);\n            }\n            sortedOffsets.sort((a, b) => b - a);\n            // For each other offset, check if we are closer to it than the margin\n            // If so, we move our offset over the other as much as the margin needs\n            for (const offset of sortedOffsets) {\n              const difference = Math.abs(dotDownOffset + extra - offset);\n              if (difference > HOVER_TEXT_SEPARATION - 1) continue;\n              extra = offset - HOVER_TEXT_SEPARATION - dotDownOffset;\n            }\n            // In case the new offset is over the top limit we must relocate it below\n            if (dotDownOffset + extra < offset.top) {\n              extra = offset.top - dotDownOffset;\n              sortedOffsets.sort((a, b) => a - b);\n              // For each other offset, check if we are closer to it than the margin\n              // If so, we move our offset below the other as much as the margin needs\n              for (const offset of sortedOffsets) {\n                const difference = Math.abs(dotDownOffset + extra - offset);\n                if (difference > HOVER_TEXT_SEPARATION - 1) continue;\n                extra = offset + HOVER_TEXT_SEPARATION - dotDownOffset;\n              }\n            }\n            dotDownOffsets[d] = dotDownOffset + extra;\n            // Add the offset + a small margin\n            return `translate(0, ${extra - 3})`;\n          })\n          // Set the dot text in the x axis\n          .text(d => {\n            if (labelsOnHover) {\n              return `${Math.round(data[d].data[closestIndex] * 100) / 100} (${data[d].labels[closestIndex]})`;\n            } else {\n              return Math.round(data[d].data[closestIndex] * 100) / 100;\n            }\n          });\n        xDot\n          // Set the x position of the dot\n          .attr('transform', `translate(${x(closestIndex * step)}, 0)`)\n          // Dots become invisible if the closest index is not between the minimum and the maximum\n          .attr('opacity', closestIndex * step >= xMin && closestIndex * step < xMax ? 1 : 0);\n        actualXDot\n          // Set the y position of the dot\n          .attr('transform', `translate(0, ${height - offset.bottom})`)\n          .attr('opacity', 1)\n          .selectAll('text')\n          // Set the y position of the text under the dot\n          // This text size is similar to graph labels size so this is good enough\n          .attr('transform', `translate(0, ${labelsHeight})`)\n          // Set the dot text in the x axis\n          .text(() => {\n            const number = closestIndex * step * xScaleFactor;\n            if (number < 0) return;\n            return xTooltip && xTooltip(number, closestIndex);\n          });\n\n        if (onHover) {\n          onHover(\n            closestIndex * step >= xMin && closestIndex * step < xMax\n              ? closestIndex\n              : null,\n          );\n        }\n      });\n      // When click in the graph\n      onSelectRef.current({ onSelect });\n\n      graph.on('mouseout', () => {\n        allDotGroups.selectAll('g.dot-group').attr('opacity', 0);\n        actualXDot.attr('opacity', 0);\n        if (onHover) onHover(null);\n      });\n\n      // Save current values for further reference\n      previousValues.current.data = data;\n      previousValues.current.labels = labels;\n      previousValues.current.xAxisLabel = xAxisLabel;\n      previousValues.current.yAxisLabel = yAxisLabel;\n      previousValues.current.currentZoom = currentZoom;\n      previousValues.current.offset = offset;\n      previousValues.current.labelsHeight = labelsHeight;\n      previousValues.current.requiredBottomOffset = requiredBottomOffset;\n      previousValues.current.yAxisLabelHeight = yAxisLabelHeight;\n      previousValues.current.xColors = xColors;\n      previousValues.current.xNormalizedWeights = xNormalizedWeights;\n      previousValues.current.xTooltip = xTooltip;\n      previousValues.current.areaStdDev = areaStdDev;\n      previousValues.current.yPadding = yPadding;\n    };\n\n    onSelectRef.current = ({ onSelect } = {}) => {\n      // Get some reference values\n      const x = previousValues.current.x;\n      const precision = previousValues.current.precision;\n      const step = previousValues.current.step;\n      const xMin = previousValues.current.xMin;\n      const xMax = previousValues.current.xMax;\n      const xAxisValues = previousValues.current.xAxisValues;\n      // In case we dont have the previous values yet we stop here\n      if (x === undefined) return;\n      // If there is no 'onSelect' function then return here\n      if (!onSelect) return;\n      // When click in the graph\n      graph.on('click', (_, index, nodes) => {\n        const [xValue] = mouse(nodes[index]);\n        // Get the closest x axis index to the current mouse position\n        const closestIndex =\n          Math.round(x.invert(xValue) / precision / step) * precision;\n        if (closestIndex * step < xMin || closestIndex * step >= xMax) {\n          return;\n        }\n        onSelect(closestIndex, xAxisValues ? xAxisValues[closestIndex] : null);\n      });\n      // Update previous refs\n      previousValues.current.onSelect = onSelect;\n      previousValues.current.precision = precision;\n    };\n\n    // Place marks in the graph\n    marksRef.current = ({ marks } = {}) => {\n      // Get some reference values\n      const x = previousValues.current.x;\n      const xUnitWidth = previousValues.current.xUnitWidth;\n      const step = previousValues.current.step;\n      // In case we dont have all the arguments yet we stop here\n      if (x === undefined) return;\n\n      // Get the container height since we need it for proper mark positioning\n      const { clientHeight: height } = containerRef.current;\n      const { top: offsetTop, bottom: offsetBottom } = offset;\n\n      // Remove previous marks\n      if (previousValues.current.marks)\n        previousValues.current.marks.forEach(prevMark =>\n          marksNode.select('#mark' + prevMark.x).remove(),\n        );\n      // If there are no new marks then return here\n      if (!marks) return;\n      // Add a vertical band for each mark\n      marks.forEach(mark => {\n        if (!Number.isInteger(mark.x)) return; // Skip invalid marks\n        const markRect = marksNode\n          .append('rect')\n          .attr('id', 'mark' + mark.x)\n          .attr('x', () =>\n            Number.isInteger(mark.x) ? x(mark.x * step) - xUnitWidth / 2 : 0,\n          )\n          .attr('y', offsetTop)  // Start from top offset\n          .attr('height', height - offsetTop - offsetBottom)  // Use container height minus offsets\n          .attr('width', () => xUnitWidth);\n        if (mark.attr)\n          Object.entries(mark.attr).forEach(([key, value]) => {\n            markRect.attr(key, value);\n          });\n        if (mark.style)\n          Object.entries(mark.style).forEach(([key, value]) => {\n            markRect.style(key, value);\n          });\n      });\n      // Update previous refs\n      previousValues.current.marks = marks;\n    };\n\n    hoveredRef.current = ({ hovered } = {}) => {\n      // Get some reference values\n      const linesData = previousValues.current.linesData;\n      // Change the whole dataset line stroke width\n      linesData\n        .transition()\n        .attr('stroke-width', d => (hovered === d ? 3 : 1.5));\n      // Update previous refs\n      previousValues.current.hovered = hovered;\n    };\n\n    window.addEventListener('resize', drawRef.current);\n\n    return () => window.removeEventListener('resize', drawRef.current);\n  }, []); // DANI: eslint ahora se queja, peor antes aquí había esto: // eslint-disable-line react-hooks/exhaustive-deps\n  // Maybe might need to double-check that and remove the exception\n\n  // Handle when the 'onSelect' function changes\n  useEffect(() => {\n    onSelectRef.current({ onSelect });\n  }, [onSelect]);\n\n  // Handle when marks change\n  useEffect(() => {\n    marksRef.current({ marks });\n  }, [marks]);\n\n  // Handle when some parameter change requires a whole re-draw of the graph\n  useEffect(() => {\n    drawRef.current({\n      data: yData,\n      step,\n      xAxisLabel,\n      yAxisLabel,\n      xAxisValues,\n      labels: lab,\n      offset,\n      labelsHeight,\n      requiredBottomOffset,\n      yAxisLabelHeight,\n      xColors,\n      xTooltip,\n      areaStdDev,\n      yPadding\n    });\n  }, [\n    yData,\n    step,\n    xAxisLabel,\n    yAxisLabel,\n    xAxisValues,\n    lab,\n    offset,\n    labelsHeight,\n    requiredBottomOffset,\n    yAxisLabelHeight,\n    xColors,\n    xTooltip,\n    areaStdDev,\n    yPadding\n  ]);\n\n  // Handle when weights change apart, since they must be normalized\n  useEffect(() => {\n    // Normalize xWeigths, when passed, so that the minimum values are 1\n    if (!xWeights) return;\n    // Check weights and data to match in the number of values\n    const expectedCount = xWeights.length;\n    Object.values(yData).forEach(value => {\n      const currentCount = value.data.length;\n      if (currentCount !== expectedCount)\n        throw new Error(\n          `Graph data values count (${currentCount}) does not match the weigths values count (${expectedCount})`,\n        );\n    });\n    // Find the minimum and maximum values in the weights array\n    // NEVER FORGET: do not use Math.min and Math.max for long arrays\n    const minimum = xWeights.reduce((cv, nv) => {\n      return Math.min(cv, nv);\n    }, Infinity);\n    const maximum = xWeights.reduce((cv, nv) => {\n      return Math.max(cv, nv);\n    }, -Infinity);\n    // Set the normalized minimum and maximum radius values\n    // This in the graph is equivalent to 'times the default area'\n    const normalizedMinimum = 1;\n    const normalizedMaximum = 10;\n    // Set a function to interpolate values\n    const normalizer =\n      (normalizedMaximum - normalizedMinimum) / (maximum - minimum);\n    const interpolate = weight =>\n      normalizedMinimum + (weight - minimum) * normalizer;\n    // Recalculate weights using the minimum values (equal to 1) as reference\n    const xNormalizedWeights = xWeights.map(weight => interpolate(weight));\n    drawRef.current({ xNormalizedWeights });\n  }, [xWeights, yData]);\n\n  // Handle when user clicks on legend checkboxes\n  const handleChange = useCallback(\n    ({\n      target: {\n        dataset: { key },\n      },\n    }) => {\n      if (!key) return;\n      if (!setLab) return;\n      setLab(previous => {\n        const nextLabels = { ...previous, [key]: !previous[key] };\n        // Check if any value is true before returning the labels\n        // This way, the user can not uncheck the last active checkbox\n        if (Object.values(nextLabels).some(Boolean)) return nextLabels;\n        // If all of the values would be false, keep the previous\n        return previous;\n      });\n    },\n    [setLab],\n  );\n\n  const handleMouseOver = useCallback(\n    ({\n      target: {\n        dataset: { key },\n      },\n    }) => {\n      if (!key || !lab[key] || isCanvasPowered(type)) return;\n      hoveredRef.current({ hovered: key });\n    },\n    [lab, type],\n  );\n\n  const handleMouseOut = useCallback(\n    ({\n      target: {\n        dataset: { key },\n      },\n    }) => {\n      if (!key || !lab[key] || isCanvasPowered(type)) return;\n      hoveredRef.current({ hovered: null });\n    },\n    [lab, type],\n  );\n\n  // Expose public methods and getters/setters\n  useImperativeHandle(\n    ref,\n    () => ({\n      set marks(value) {\n        marksRef.current({ marks: value });\n      },\n    }),\n    [],\n  );\n\n  return (\n    <div className={className ? className : style.default}>\n      <div className={style.flexible}>\n        <div className={style['graph-container']} ref={containerRef} />\n        {selfLegend && (\n          <div className={style['graph-legend']}>\n            {yEntries.map(([key]) => (\n              <FormControlLabel\n                data-key={key}\n                key={key}\n                onChange={handleChange}\n                onMouseOver={handleMouseOver}\n                onMouseOut={handleMouseOut}\n                control={\n                  <Checkbox\n                    checked={lab[key]}\n                    style={{ color: yData[key].color || 'black' }}\n                    inputProps={{ 'data-key': key }}\n                  />\n                }\n                label={NICE_NAMES.get(key) || key}\n              />\n            ))}\n          </div>\n        )}\n        {displayLegend && (\n          <div className={style['graph-display-legend']}>\n            {yEntries.map(([key, dataset], i) => {\n              if (lab[key] === false) return null;\n              return (\n                <div key={key} className={style['line-sample']}>\n                  {key}\n                  <LineSample color={dataset.color} dash={dataset.dash} />\n                </div>\n              );\n            })}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n});\n\nexport default Graph;\n","// Function involved in getting text pixels width\n// WARNING: These functions do not work properly in Chrome (not an easy problem)\n\n// This function allows to calculate the width of a given string text\n// The font for the calculation in the d3 default font\nexport const getTextWidth = (text, font = 'bold 10px sans-serif') => {\n  const canvas =\n    getTextWidth.canvas ||\n    (getTextWidth.canvas = document.createElement('canvas'));\n  const context = canvas.getContext('2d');\n  context.font = font;\n  const metrics = context.measureText(text);\n  return metrics.width;\n};\n\n// Alternative way to obtain text width\n// Probably the only way to obtain text height\nexport const getTextSizeDOM = (text, font = 'bold 10px sans-serif') => {\n  const element = document.createElement('div');\n  const content = document.createTextNode(text);\n  element.appendChild(content);\n  Object.assign(element.style, {\n    font: font,\n    position: 'absolute',\n    visibility: 'hidden',\n    height: 'auto',\n    width: 'auto',\n    'white-space': 'nowrap',\n  });\n  document.body.appendChild(element);\n  return { width: element.clientWidth, height: element.clientHeight };\n};\n\n// Get the whole body width\nexport const getBodyWidth = () => {\n  return Math.max(\n    document.body.scrollWidth,\n    document.documentElement.scrollWidth,\n    document.body.offsetWidth,\n    document.documentElement.offsetWidth,\n    document.documentElement.clientWidth,\n  );\n};\n\n// Get the whole body height\nexport const getBodyHeight = () => {\n  return Math.max(\n    document.body.scrollHeight,\n    document.documentElement.scrollHeight,\n    document.body.offsetHeight,\n    document.documentElement.offsetHeight,\n    document.documentElement.clientHeight,\n  );\n};\n"],"names":["symbolProto","Symbol","prototype","undefined","symbolToString","toString","baseToString","value","isArray","arrayMap","isSymbol","call","result","spreadableSymbol","isConcatSpreadable","isArguments","baseFlatten","array","depth","predicate","isStrict","index","length","isFlattenable","arrayPush","iteratee","Array","getMean","data","reduce","pv","cv","getMeanAndStdv","sum","n","mean","stdv","Math","sqrt","map","x","pow","a","b","createSvgIcon","_jsx","d","getCheckboxUtilityClass","slot","generateUtilityClass","generateUtilityClasses","_excluded","CheckboxRoot","styled","SwitchBase","shouldForwardProp","prop","rootShouldForwardProp","name","overridesResolver","props","styles","ownerState","root","indeterminate","capitalize","size","color","_ref","theme","_extends","vars","palette","text","secondary","disableRipple","backgroundColor","action","activeChannel","mainChannel","hoverOpacity","alpha","active","main","checkboxClasses","checked","disabled","defaultCheckedIcon","CheckBoxIcon","defaultIcon","CheckBoxOutlineBlankIcon","defaultIndeterminateIcon","IndeterminateCheckBoxIcon","React","inProps","ref","_icon$props$fontSize","_indeterminateIcon$pr","useDefaultProps","checkedIcon","icon","iconProp","indeterminateIcon","indeterminateIconProp","inputProps","className","other","_objectWithoutPropertiesLoose","classes","slots","composedClasses","composeClasses","useUtilityClasses","type","fontSize","clsx","idCounter","prefix","id","defs","uniqueId","filter","append","attr","idStart","idEnd","startMaskGradient","style","endMaskGradient","dash","containerRef","useRef","useEffect","graph","select","current","DEFAULT_DOT_AREA","DEFAULT_DOT_RADIUS","PI","dPR","window","devicePixelRatio","defaultD3font","titlesD3font","yDataPlaceholder","placeholder","defaultMargins","top","right","bottom","left","steppedMax","values","max","Number","NEGATIVE_INFINITY","forEach","trueEntries","keys","object","key","isCanvasPowered","Graph","forwardRef","yData","xAxisValues","step","title","xAxisLabel","yAxisLabel","xScaleFactor","xColors","xWeights","xTooltip","yPadding","onHover","labelsOnHover","onSelect","selfLegend","displayLegend","dataDisplay","setDataDisplay","standardDeviation","margin","flippedXAxisValues","fullPrecision","marks","areaStdDev","zeroLine","Object","drawRef","noop","onSelectRef","marksRef","hoveredRef","yEntries","yKeys","useMemo","entries","_ref2","offset","labelsHeight","requiredBottomOffset","yAxisLabelHeight","yAxisValues","_ref3","dataset","nv","concat","v","round","textHeight","getTextSizeDOM","height","maxXAxisWidth","label","getTextWidth","maxYAxisWidth","xAxisLabelHegiht","requiredTopOffset","requiredLeftOffset","internalDataDisplay","setInternalDataDisplay","useState","lab","setLab","previousValues","labels","currentZoom","k","rescaleX","scale","canvas","canvasContext","node","getContext","textBackgroundURL","addTextBackground","startMaskURL","endMaskURL","addMasks","marksNode","allDotGroups","maskEnd","axes","y","xDot","xNormalizedWeights","arguments","clientWidth","width","clientHeight","dataEntries","dataKeys","_ref4","maxZoomExtent","precisionScale","scaleLog","range","ceil","domain","graphZoom","zoom","scaleExtent","translateExtent","on","event","preventDefault","transform","zoomPrecision","floor","log2","getZoomPrecision","min","precision","bind","bodyWidth","bodyHeight","remove","xMaxIndex","xMax","xMin","scaleLinear","g","axisBottom","ticks","tickFormat","yExtent","extent","flatten","_ref5","_ref6","nice","transition","axisLeft","zeroLineEl","selectAll","enter","merge","exit","meanLines","stddev","sdRects","areaGenerator","area","y0","y1","sdAreas","points","_","i","minIndex","invert","maxIndex","lineFn","line","defined","linesData","dashWidth","dashHeight","startAngle","endAngle","clearRect","fillStyle","maxInView","atomColor","fillRect","xPosition","yPosition","radius","weight","beginPath","arc","fill","xUnitWidth","dotGroups","actualXDot","nodes","xValue","mouse","closestIndex","dotDownOffsets","offsetDown","dotDownOffset","extra","sortedOffsets","push","sort","abs","HOVER_TEXT_SEPARATION","number","offsetTop","offsetBottom","prevMark","mark","isInteger","markRect","_ref7","_ref8","hovered","addEventListener","removeEventListener","expectedCount","currentCount","Error","minimum","Infinity","maximum","normalizer","interpolate","handleChange","useCallback","_ref9","target","previous","nextLabels","some","Boolean","handleMouseOver","_ref0","handleMouseOut","_ref1","useImperativeHandle","children","_jsxs","_ref10","FormControlLabel","onChange","onMouseOver","onMouseOut","control","Checkbox","NICE_NAMES","get","_ref11","LineSample","font","context","document","createElement","measureText","element","content","createTextNode","appendChild","assign","position","visibility","body"],"sourceRoot":""}