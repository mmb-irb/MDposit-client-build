{"version":3,"file":"static/js/6463.9ad99030.chunk.js","mappings":"yJACA,QAA4B,yB,eCM5B,MAAMA,EAAY,CAAEC,QAAS,CAAC,EAAG,KAE5BC,EAAAA,EAAAA,OACHF,EAAUG,UAAY,CAAC,mBAAoB,kBAG7C,MAAMC,EAAoB,CACxBC,KAAM,OACNC,OAAQ,iCACRC,SAAU,KAgCZ,GA5BqBC,EAAAA,EAAAA,YAAW,CAAAC,EAAkCC,KAAS,IAA1C,kBAAEC,KAAsBC,GAAOH,EAC9D,MAAMI,GAAeC,EAAAA,EAAAA,QAAO,OAE5BC,EAAAA,EAAAA,iBAAgB,KACd,MAAMC,EAAOH,EAAaI,SAAWJ,EAAaI,QAAQC,kBAC1D,IAAMF,IAAQA,EAAKG,QAAU,OAE7B,MAAMC,EAAQC,MAAMC,KAClBC,SAASC,iBAAiB,iBAC1BC,UAAUC,GAAWV,IAASU,GAE1BC,EAAYX,EAAKG,QAAQnB,EAAW,IACrCI,EACHwB,MAAe,IAARR,IAGT,MAAO,IAAMO,EAAUE,UACtB,IAEH,MAAMC,EAAYnB,EAAoB,UAAYoB,EAAAA,EAElD,OACEC,EAAAA,EAAAA,KAAA,OAAKtB,IAAKG,EAAcoB,UAAWC,EAAgBC,UACjDH,EAAAA,EAAAA,KAACF,EAAS,CAACM,UAAU,aAAcxB,EAAOF,IAAKA,O,qJCzC9C,SAAS2B,EAAoBC,GAClC,OAAOC,EAAAA,EAAAA,IAAqB,UAAWD,EACzC,EACoBE,EAAAA,EAAAA,GAAuB,UAAW,CAAC,S,eCDvD,MAAMC,EAAY,CAAC,YAAa,UAoB1BC,GAAWC,EAAAA,EAAAA,IAAOC,EAAAA,EAAO,CAC7BC,KAAM,UACNP,KAAM,OACNQ,kBAAmBA,CAAClC,EAAOmC,IAAWA,EAAOC,MAH9BL,CAId,KACM,CACLM,SAAU,YAwDd,EArD0BC,EAAAA,WAAiB,SAAcC,EAASzC,GAChE,MAAME,GAAQwC,EAAAA,EAAAA,GAAgB,CAC5BxC,MAAOuC,EACPN,KAAM,aAEF,UACFZ,EAAS,OACToB,GAAS,GACPzC,EACJ0C,GAAQC,EAAAA,EAAAA,GAA8B3C,EAAO6B,GACzCe,GAAaC,EAAAA,EAAAA,GAAS,CAAC,EAAG7C,EAAO,CACrCyC,WAEIK,EA/BkBF,KACxB,MAAM,QACJE,GACEF,EAIJ,OAAOG,EAAAA,EAAAA,GAHO,CACZX,KAAM,CAAC,SAEoBX,EAAqBqB,IAwBlCE,CAAkBJ,GAClC,OAAoBxB,EAAAA,EAAAA,KAAKU,GAAUe,EAAAA,EAAAA,GAAS,CAC1CxB,WAAW4B,EAAAA,EAAAA,GAAKH,EAAQV,KAAMf,GAC9B6B,UAAWT,EAAS,OAAIU,EACxBrD,IAAKA,EACL8C,WAAYA,GACXF,GACL,E,gDCpDA,SAAgB,KAAO,oBAAoB,KAAO,oBAAoB,QAAU,uBAAuB,UAAY,yBAAyB,iBAAmB,gCAAgC,OAAS,sB,6DCAxM,QAA6B,0BAA7B,EAAkE,wBAAlE,EAA+G,kCAA/G,EAAoK,gC,0BCQpK,MAuEA,EAvEoB7C,IAeb,IAfc,MAEnBuD,EAAQ,GAAE,SAEVC,EAAW,EAAC,SACZC,EAAW,EAAC,UAEZC,EAAS,OAETC,EAAS,GAAE,SAEXC,GAAW,EAAK,KAChBC,GAAO,EAAK,UAEZrC,GACDxB,EAEC,MAAM,WAAE8D,EAAU,aAAEC,IAAiBC,EAAAA,EAAAA,SAAQ,KAG3C,MAAMC,EAAS,GAEf,GAAIR,IAAaD,EAAUS,EAAOC,KAAKT,QAGlC,IAAK,IAAIU,EAAIV,EAAUU,GAAKX,EAAUW,IAAMX,EAAWC,GAAYE,EACtEM,EAAOC,KAAKC,GAGd,IAAIJ,EAAeE,EAAOG,IAAIC,GAAOC,KAAKC,MAAMF,IAGhD,GAAIN,EAAaS,OAAS,EAExB,IAAK,IAAIC,EAAU,EAAG,IAAIC,IAAIX,GAAcY,KAAOZ,EAAaS,OAAQC,IACtEV,EAAeE,EAAOG,IAAIC,GAAOC,KAAKC,MAAMF,EAAM,IAAMI,GAAW,IAAMA,GAI7E,MAAMX,EAAaF,EAAWK,EAAOG,IAAIQ,GAAK,CAACA,IAAM,CAACX,GAOtD,OANIJ,IAEFC,EAAWe,UACXd,EAAac,WAGR,CAAEf,aAAYC,iBACpB,CAACP,EAAUC,EAAUE,EAAQC,IAGhC,OACEkB,EAAAA,EAAAA,MAACC,EAAAA,EAAW,CACVvD,UACEA,IAAwBoC,EAAWnC,EAAiBA,GACrDC,SAAA,CAEA6B,GACDhC,EAAAA,EAAAA,KAACyD,EAAAA,EAAa,CACZC,KAAMnB,EACNoB,YAAatB,EAAW,CAAC,IAAMG,EAC/BoB,YAAavB,EAAWG,EAAe,CAAC,IACxCL,UAAWA,EACX0B,oBAAoB,EACpB5D,UACEoC,EAAWnC,EAA4BA,O,6CCpE1C,MAAM4D,EAAe,SAACC,GAAyC,IAAnCC,EAAIC,UAAAhB,OAAA,QAAAlB,IAAAkC,UAAA,GAAAA,UAAA,GAAG,uBACxC,MAGMC,GAFJJ,EAAaK,SACZL,EAAaK,OAAS5E,SAAS6E,cAAc,YACzBC,WAAW,MAClCH,EAAQF,KAAOA,EAEf,OADgBE,EAAQI,YAAYP,GACrBQ,KACjB,EAIaC,EAAiB,SAACT,GAAyC,IAAnCC,EAAIC,UAAAhB,OAAA,QAAAlB,IAAAkC,UAAA,GAAAA,UAAA,GAAG,uBAC1C,MAAMQ,EAAUlF,SAAS6E,cAAc,OACjCM,EAAUnF,SAASoF,eAAeZ,GAWxC,OAVAU,EAAQG,YAAYF,GACpBG,OAAOC,OAAOL,EAAQvE,MAAO,CAC3B8D,KAAMA,EACNe,SAAU,WACVC,WAAY,SACZC,OAAQ,OACRV,MAAO,OACP,cAAe,WAEjBhF,SAAS2F,KAAKN,YAAYH,GACnB,CAAEF,MAAOE,EAAQU,YAAaF,OAAQR,EAAQW,aACvD,C,8FCtBA,MAAMC,EAAgB,yBAEhBC,EAAe,yBA2ZrB,GApZsBC,EAAAA,EAAAA,MACpB9G,IAkBO,IAlBN,KACCiF,EAAI,YACJC,EAAc,GAAE,YAChBC,EAAc,GAAE,WAChB4B,EAAU,WACVC,EAAU,gBACVC,EAAkB,EAAC,UACnBvD,EAAY,CAAC,MAAO,QAAS,QAAO,WACpCwD,EAAU,UACVC,EAAS,QACTC,EAAO,mBACPhC,GAAqB,EAAI,OACzBiC,EAAS,CAAEC,IAAK,GAAIC,MAAO,GAAIC,OAAQ,GAAIC,KAAM,IAAI,UACrDjG,EAAS,SACTkG,EAAW,UAAS,SACpBjE,EAAQ,SACRD,EAAQ,UACRmE,GAAY,GACb3H,EACC,IAAKiF,EACH,MAAM,IAAI2C,MACR,qEAIJ,GAAI1C,EAAYV,SAAW,IAAIE,IAAIQ,GAAaP,KAE9C,MADAkD,QAAQC,IAAI5C,GACN,IAAI0C,MAAM,qDAElB,GAAIzC,EAAYX,SAAW,IAAIE,IAAIS,GAAaR,KAE9C,MADAkD,QAAQC,IAAI3C,GACN,IAAIyC,MAAM,qDAIS,IAAvB1C,EAAYV,SACdU,EAActE,MAAMC,KAAKD,MAAMqE,EAAK,GAAGT,QAAQuD,SACtB,IAAvB5C,EAAYX,SACdW,EAAcvE,MAAMC,KAAKD,MAAMqE,EAAK,GAAGT,QAAQuD,SAKjD,MAAM9D,EAAS,GAAG+D,UAAU/C,GAEtBgD,EAAchE,EAAOiE,OAAOC,IAAUC,MAAMD,IAC5CE,EAAe,OAAR7E,QAAQ,IAARA,EAAAA,EAAYc,KAAKgE,OAAOL,GAC/BM,EAAe,OAAR9E,QAAQ,IAARA,EAAAA,EAAYa,KAAKkE,OAAOP,GAE/BQ,EAAQ,GAAGT,UAAUpH,MAAMqE,EAAKT,QAAQ5E,KAAKsF,IAE7CwD,EAAQ,GACd,IAAK,MAAMC,KAAOxD,EAChBuD,EAAMxE,QAAQtD,MAAMsE,EAAYV,QAAQ5E,KAAK+I,IAE/C,MAAMC,EAAQ,GACd,IAAK,MAAMzE,KAAKF,EACd2E,EAAM1E,KAAK,CAAEU,EAAGX,EAAOE,GAAI0E,EAAGJ,EAAMtE,GAAI2E,EAAGJ,EAAMvE,KAInD,MAAM/D,GAAeC,EAAAA,EAAAA,QAAO,MAEtB0I,GAAiB1I,EAAAA,EAAAA,QAAO,OAGvB,CAAE2I,IAAoBC,EAAAA,EAAAA,UAAS,MAgBhCC,GAAanD,EAAAA,EAAAA,IAAe,IAAKa,GAAeJ,OAChD2C,GACJpD,EAAAA,EAAAA,IAAe,IAAKc,GAAcL,OALX,EAUnB4C,EACJ9E,KAAKgE,OACApD,EAAYd,IAAIiF,IAAShE,EAAAA,EAAAA,IAAagE,EAAOzC,KAhBzB,EAmBrB0C,EAAgBhF,KAAKgE,OACtBnD,EAAYf,IAAIiF,IAAShE,EAAAA,EAAAA,IAAagE,EAAOzC,KAK5C2C,EAAmBxC,EAAaoC,EAAe,EAC/CK,EAAmBxC,EAAamC,EA1BX,EA0B+C,EAGpEM,EAAkBrE,EACpBgE,EAAgBG,EAChBL,EAAaK,EACXG,EACmB,IAAvBvE,EAAYX,OACRF,KAAKgE,IAAIgB,GAAejE,EAAAA,EAAAA,IAAa2B,EAAYH,IACjDyC,EAAgBE,EAGhBG,EAAS,CACbrC,IAAKD,EAAOC,IACZC,MAAOF,EAAOE,MACdC,OAAQiC,EAAkBpC,EAAOG,OACjCC,KAAMiC,EAAkBrC,EAAOI,MA4QjC,OArQAmC,EAAAA,EAAAA,WAAU,KAIJb,EAAevI,SACjBuI,EAAevI,QAAQqJ,QAAQC,GAASA,EAAMC,UAGhD,MAAMC,EAAY5J,EAAaI,SAG7BkG,YAAaZ,EACba,aAAcH,GACZwD,EAAUC,cAGRC,EAAYpE,EAAQ6D,EAAOlC,KAAOkC,EAAOpC,MACzC4C,EAAa3D,EAASmD,EAAOrC,IAAMqC,EAAOnC,OAK1C4C,EACJF,GAAiE,MAAnD9E,EAAqB8D,EAAaE,IAC5CiB,EAASF,GAA2B,KAAbjB,GAGvBoB,EAAQhG,KAAKiG,KAAKrF,EAAYV,OAAS4F,GACvCI,EAAQlG,KAAKiG,KAAKpF,EAAYX,OAAS6F,GAMvCI,EAAgB3J,SAAS6E,cAAc,WAC7C+E,EAAAA,EAAAA,KAAOV,GACJzJ,OACA4F,YAAYsE,GACf,MAAM/E,GAASgF,EAAAA,EAAAA,KAAOD,GACnBE,KAAK,KAAM,UACXA,KAAK,QAAST,GACdS,KAAK,SAAUR,GACf1I,MAAM,WAAY,YAClBA,MAAM,MAAOkI,EAAOrC,IAAM,MAC1B7F,MAAM,OAAQkI,EAAOlC,KAAO,MAC5BhG,MAAM,SAAU2F,EAAU,eAAY9D,GACnCsH,EAAgBlF,EACnBnF,OACAqF,WAAW,MAGRiF,GAAMH,EAAAA,EAAAA,KAAOV,GAChBc,OAAO,OACPH,KAAK,KAAM,OACXA,KAAK,UAAW,CAAC,EAAG,EAAG7E,EAAOU,IAG3BqC,GAAIkC,EAAAA,EAAAA,MACPC,MAAM,CAACrB,EAAOlC,KAAMyC,EAAYP,EAAOlC,OACvCwD,OAAO/F,GACPgG,aAAa,GAEVC,EAAQN,EACXC,OAAO,KACPH,KAAK,YAAa,gBAAkBR,EAAaR,EAAOrC,KAAO,KAC/D8D,MACCC,EAAAA,EAAAA,KAAWxC,GAAGyC,WAAW,CAACC,EAAGpH,IACvBA,EAAImG,IAAU,EAAUiB,EAChB,KAGfC,UAAU,QAETpG,GACF+F,EACG1J,MAAM,cAAe,OACrBkJ,KAAK,KAAM,QACXA,KAAK,KAAM,QACXA,KAAK,YAAa,eAIvBE,EACGC,OAAO,QACPH,KAAK,QAAS,WACdA,KAAK,cAAe,UACpBA,KAAK,IAAKhB,EAAOlC,KAAOyC,EAAY,GACpCS,KAAK,IAAKhB,EAAOrC,IAAM6C,EAAaV,GACpCnE,KAAKyB,GAGR,MAAM+B,GAAIiC,EAAAA,EAAAA,MACPE,OAAO9F,GACP6F,MAAM,CAACrB,EAAOrC,IAAK6C,EAAaR,EAAOrC,MACvCmE,QAAQxE,GAEX4D,EACGC,OAAO,KACPH,KAAK,YAAa,aAAehB,EAAOlC,KAAO,QAC/C2D,MACCM,EAAAA,EAAAA,KAAS5C,GAAGwC,WAAW,CAACC,EAAGpH,IACrBA,EAAIqG,IAAU,EAAUe,EAChB,KAKS,IAAvBpG,EAAYX,OACdqG,EACGC,OAAO,QACPH,KAAK,QAAS,WACdA,KAAK,cAAe,SACpBA,KAAK,IAAK,GACVA,KAAK,IAAKtD,EAAOC,IAAM6C,GACvB7E,KAAK0B,GAER6D,EACGC,OAAO,QACPH,KAAK,QAAS,WACdA,KAAK,cAAe,UACpBA,KAAK,MAAOhB,EAAOrC,IAAM6C,EAAa,IACtCQ,KACC,IACAtD,EAAOI,KACL+B,EA7KiB,EAIF,GA6KlBmB,KAAK,YAAa,eAClBrF,KAAK0B,GAIV,MAAM2E,EAAUxD,IACd,GAAIC,MAAMD,GACR,OAAOT,EAST,OANoBR,IAEhB0E,EAAAA,EAAAA,OACGZ,MAAMtH,GACNuH,OAAO,CAAC1C,GAAOA,EAAOF,GAAQ,EAAGA,KAErBF,IAIf0D,EAAYhD,EAAEiD,YACdC,EAAajD,EAAEgD,YAGrB7G,EAAK4E,QAAQ,CAACmC,EAAKC,KACjB,MAAMC,EAAYpD,EAAE3D,EAAY8G,IAAOtC,EAAOrC,IAC9C0E,EAAInC,QAAQ,CAAC1B,EAAOgE,KAClB,MAAMC,EAAYvD,EAAE3D,EAAYiH,IAAOxC,EAAOlC,KAC9CmD,EAAcyB,UAAYV,EAAQxD,GAClCyC,EAAc0B,SAASF,EAAWF,EAAWL,EAAWE,GAEtDpE,IAEFiD,EAAc2B,YAAcZ,EAAQxD,GACpCyC,EAAc4B,UAAY,EAC1B5B,EAAc6B,WAAWL,EAAWF,EAAWL,EAAWE,QAK9D,MAAMW,EAAmBC,IAGvB,MAAMC,EAAanC,EAAcoC,wBAE3BT,EAAYO,EAAEG,QAAUF,EAAWnF,KACnCyE,EAAYS,EAAEI,QAAUH,EAAWtF,IAEzC,IAAI0F,EAAS1I,KAAK2I,MAAMb,EAAYvD,EAAEqE,QAClCC,EAAS7I,KAAK2I,MAAMf,EAAYpD,EAAEoE,QAEtC,MAAME,EAASnI,EAAK,GAAGT,OAAS,EAC5BwI,EAAS,IAAGA,EAAS,GACrBA,EAASI,IAAQJ,EAASI,GAC9B,MAAMC,EAASpI,EAAKT,OAAS,EACzB2I,EAAS,IAAGA,EAAS,GACrBA,EAASE,IAAQF,EAASE,GAE9B,MAAMC,EAAapI,EAAY8H,GACzBO,EAAapI,EAAYgI,GAE/B,MAAO,CAAEH,SAAQG,SAAQhF,MADXlD,EAAKkI,GAAQH,GACKM,aAAYC,eAI9C,IAAIC,EACArG,IAEFqG,EAAU1M,SAAS6E,cAAc,OACjCS,OAAOC,OAAOmH,EAAQ/L,MAAO,CAC3BgM,QAAS,OACTnH,SAAU,WACVoH,cAAe,OACfC,gBAAiB,uBACjBC,MAAO,YACPnC,QAAS,MACToC,WAAY,eAEd7D,EAAU7D,YAAYqH,GAEtB/C,EAAcqD,YAAcnB,IAE1B,MAAMoB,EAAgBrB,EAAiBC,GAEvCa,EAAQQ,UAAY7G,EAAU4G,GAG9BP,EAAQ/L,MAAMgM,QAAU,eACxB,MACE5E,EAAGoF,EACHnF,EAAGoF,IACDC,EAAAA,EAAAA,GACFnE,EACAwD,EACA,CAAE3E,EAAG8D,EAAEG,QAAShE,EAAG6D,EAAEI,SACrB,GAEFS,EAAQ/L,MAAMgG,KAAOwG,EAAmB,KACxCT,EAAQ/L,MAAM6F,IAAM4G,EAAmB,MAEzCzD,EAAc2D,aAAe,KAC3BZ,EAAQ/L,MAAMgM,QAAU,SAKxBrG,IACFqD,EAAc4D,YAAc1B,IAE1B,MAAMoB,EAAgBrB,EAAiBC,GAEvCvF,EAAQ2G,KAKZhF,EAAevI,QAAUgN,EAAU,CAAC3C,EAAKnF,EAAQ8H,GAAW,CAAC3C,EAAKnF,GAElE,MAAM4I,EAAeA,KACnBtF,EAAiB,CACfuF,WAAYC,OAAOD,WACnBE,YAAaD,OAAOC,eAMxB,OAHAD,OAAOE,iBAAiB,SAAUJ,GAG3B,KACLE,OAAOG,oBAAoB,SAAUL,OAQvC/M,EAAAA,EAAAA,KAAA,OACEC,UAAWA,EACXC,MAAOD,OAAY8B,EAAY,CAAEkD,OAAQ,QAASV,MAAO,SAAUpE,UAEnEH,EAAAA,EAAAA,KAAA,OACEtB,IAAKG,EACLwO,GAAI,YAEJnN,MAAO,CAAE6E,SAAU,WAAYR,MAAO,OAAQU,OAAQ,a,mOCjYhE,MAAMqI,EAAmB,CAAEC,aAAa,EAAMC,WAAY,SAgO1D,EA9N0BC,KACxB,MAAM,qBAAEC,EAAoB,SAAEC,EAAQ,mBAAEC,IAAuBC,EAAAA,EAAAA,YAAWC,EAAAA,IACnEC,EAAQC,IAAgBC,EAAAA,EAAAA,IAAUX,GACnCY,GAAYpP,EAAAA,EAAAA,QAAO,MAGnBqP,EAAyBR,GAAYA,EAASQ,wBAIlDC,QAASC,EACTC,QAASC,EACTC,MAAOC,IACLC,EAAAA,EAAAA,GAAO,GAAGC,EAAAA,MAAsBjB,4BAG7BkB,EAAeC,IAAoBnH,EAAAA,EAAAA,UAAS,OAC5CoH,EAAiBC,IAAsBrH,EAAAA,EAAAA,UAAS,MACjDsH,GAAUlQ,EAAAA,EAAAA,QAAO,CAAC,GAClBmQ,GAAenQ,EAAAA,EAAAA,QAAO,CAAC,GAGvBoQ,GAAazM,EAAAA,EAAAA,SAAQ,IACpB8L,GAAwBA,EAAoB7K,KAG1CmB,OAAO2B,KAAK+H,EAAoB7K,MAAMiD,OAAOwI,GAAe,oBAARA,GAHG,GAI7D,CAACZ,KAGJ9L,EAAAA,EAAAA,SAAQ,KACFyM,EAAWjM,SAAW2L,GACxBC,EAAiBK,EAAW,IAG9BD,EAAahQ,QAAUiQ,EAAWE,OAAO,CAACC,EAAKC,KAC7CD,EAAIC,GAASvM,KAAKgE,OAAOwH,EAAoB7K,KAAK4L,IAC3CD,GACN,CAAC,GACJJ,EAAahQ,QAAU8D,KAAKgE,OAAOlC,OAAOnC,OAAOuM,EAAahQ,WAC7D,CAACiQ,EAAYN,IAGhB,MAAMW,GAAa9M,EAAAA,EAAAA,SAAQ,IACpByM,EAAWjM,QAAW2K,EACpBsB,EAAWE,OAAO,CAACC,EAAKC,KAC7B,MAAM5Q,EAAMkP,EAAmB4B,KAAK9Q,GAAOA,EAAI+Q,WAAaH,GAC5D,IAAIzO,EAAM6O,EAAWC,EAWrB,OAVIjR,EAAIkR,UAAUC,UAChBhP,EAAOnC,EAAIkR,UAAU/O,KACrB6O,EAAYhR,EAAIkR,UAAUC,SAASC,MAAM,MAAMC,KAAK,CAACC,EAAGC,IAAMD,EAAE/M,OAASgN,EAAEhN,QAAQ,GACnF0M,EAAWjR,EAAIkR,UAAUM,UAChBxR,EAAIyR,YAAYN,WACzBhP,EAAO6O,EAAYhR,EAAIyR,YAAYN,SAASL,KAAKY,GAAsB,iBAAdA,EAAKC,MAAyBxP,KACvF8O,EAAWjR,EAAIyR,YAAYG,aAE7BhK,QAAQC,IAAI,QAAS+I,EAAO,OAAQzO,EAAM,YAAa6O,EAAW,WAAYC,GAC9EN,EAAIC,GAAS,CAAEzO,OAAM6O,YAAWC,YACzBN,GACN,CAAC,GAfkD,CAAC,EAgBtD,CAACH,EAAYtB,IAGR2C,GAAiB9N,EAAAA,EAAAA,SAAQ,IACxByM,EAAWjM,QAAW0K,EACpBuB,EAAWE,OAAO,CAACC,EAAKC,KAC7B,MAAMkB,EAAa7C,EAAS8C,2BAA2BnB,GACjDoB,EAAiB,MAAM/C,EAASgD,oBAAoBH,GAAYI,KAAK,SAE3E,OADAvB,EAAIC,GAASoB,EACNrB,GACN,CAAC,GANwC,CAAC,EAO5C,CAACH,EAAYvB,IAGZkD,EAAkBvB,GACjBf,GAAwBA,EAAoB7K,MAAS4L,EACnDwB,EAAAA,GAAmBC,UAAU,SAAUC,GAC5CC,KAAKC,UAAY,SAAUC,GAEzB,MAAMC,EAAS7C,EAAoB7K,KAAK2N,gBAAgBC,QAAQH,EAAKI,cACrE,IAAgB,IAAZH,EAAe,OAAO,SAC1B,MAAMxK,EAAQ2H,EAAoB7K,KAAK4L,GAAO8B,GAGxCI,EAAazO,KAAK0O,KAAK7K,EAAMqI,EAAahQ,SAChD,IACIyS,EAAOC,EAaX,OAXIH,EAAa,IAEjBE,EAAQ,IAAM3O,KAAK2I,MAAM,IAAM8F,EAAa,GAC5CG,EAAO,IAAM5O,KAAK2I,MAAM,IAAM8F,EAAa,KAG3CE,EAAQ,IAAM3O,KAAK2I,MAAM,KAAO8F,EAAa,IAAO,GACpDG,EAAO,GAVG,KAcK,GAAOD,GAAS,EAAKC,CACpC,CACJ,EAAGrC,GA1BqE,KA8D1E,OAxBAjH,EAAAA,EAAAA,WAAU,KACR,IAAK8F,GAA4D,IAAlCA,EAAuBlL,SAAiB2L,EAAe,OACtFT,EAAuB7F,QAAQsJ,IAVNC,MAWjBD,EAAI/Q,KAAKiR,cAAcC,SAAS,YAChCH,EAAIvF,MAAQ,SACZuF,EAAIvB,KAAO,YACXuB,EAAIvF,OAdawF,EAcajD,EAbjCI,EAAQ/P,QAAQ4S,KACnB7C,EAAQ/P,QAAQ4S,GAAahB,EAAegB,IAEvC7C,EAAQ/P,QAAQ4S,IAWfD,EAAII,aAAepD,GACZgD,EAAI/Q,KAAKiR,cAAcC,SAAS,WACvCH,EAAIvF,MAAQ,OACZuF,EAAI3T,QAAU,MAGtB,MAAMgU,EAAW,CACf,KAAQrD,EACR,KAAQ,WACR,MAAS,SACT,QAAW,GACX,UAAa2B,EAAe3B,IAG9BG,EAAmB,IAAIZ,EAAwB8D,KAC9C,CAACrD,EAAeT,IAEfE,GAA4BrO,EAAAA,EAAAA,KAACkS,EAAAA,EAAO,IACpCzD,EAA0BA,EAAkB0D,WAC3C5D,GAGHhL,EAAAA,EAAAA,MAAC6O,EAAAA,SAAQ,CAACC,UAAUrS,EAAAA,EAAAA,KAACkS,EAAAA,EAAO,IAAI/R,SAAA,EAC9BH,EAAAA,EAAAA,KAACD,EAAAA,EAAI,CAACE,UAAWC,EAAAA,QAAMoS,KAAKnS,UAC1BH,EAAAA,EAAAA,KAACwD,EAAAA,EAAW,CAAArD,UACVH,EAAAA,EAAAA,KAACuS,EAAAA,EAAI,CACH3L,MAAOgI,EACP4D,QAAQ,YACRC,eAAe,UACfC,UAAU,UACVC,SAAUA,CAACC,EAAOhM,KAChBiI,EAAiBjI,IAEnB3G,UAAWC,EAAAA,QAAM2S,KAAK1S,SAErB+O,EAAWrM,IAAKyM,GACfC,EAAWD,KAAUtP,EAAAA,EAAAA,KAAC8S,EAAAA,EAAG,CAEvBlM,MAAO0I,EACPxH,OACEvE,EAAAA,EAAAA,MAAA,OAAKrD,MAAO,CAAEgM,QAAS,OAAQ6G,cAAe,SAAUC,WAAY,UAAW7S,SAAA,EAC7EH,EAAAA,EAAAA,KAAA,QAAMgC,MAAO,GAAGuN,EAAWD,GAAOK,WAAWxP,SAC1CoP,EAAWD,GAAOzO,OAEpB0O,EAAWD,GAAOI,YAAcH,EAAWD,GAAOzO,OACjDb,EAAAA,EAAAA,KAACiT,EAAAA,EAAU,CAACT,QAAQ,UAAUnG,MAAM,iBAAiBrK,MAAO,GAAGuN,EAAWD,GAAOK,WAAWxP,SACzFoP,EAAWD,GAAOI,gBATtBJ,WAiDftP,EAAAA,EAAAA,KAACD,EAAAA,EAAI,CAACE,UAAWC,EAAAA,QAAMgT,QAASxU,IAAKqP,EAAO5N,SACzC6N,GACChO,EAAAA,EAAAA,KAACmT,EAAAA,QAAkB,CACjBlT,UAAWC,EAAAA,QAAMuI,UACjB2K,qBAAsB,CAACtE,EAAiBC,GACxCrQ,IAAKwP,EACLmF,SAAS,KAGXrT,EAAAA,EAAAA,KAAA,OAAKE,MAAO,CAAE+E,OAAQ,eA5EG,0D","sources":["webpack://mdposit/./src/components/animated-card/style.module.css?d4d9","components/animated-card/index.js","../node_modules/@mui/material/Card/cardClasses.js","../node_modules/@mui/material/Card/Card.js","webpack://mdposit/./src/pages/accession/lipid-inter/style.module.css?4f5b","webpack://mdposit/./src/components/color-legend/style.module.css?0c39","components/color-legend/index.js","utils/document-measurer/index.js","components/d3-heatmap-grid/index.js","pages/accession/lipid-inter/lipid-inter.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"container\":\"style_container__M9GCG\"};","import React, { useLayoutEffect, useRef, forwardRef } from 'react';\nimport { Card } from '@mui/material';\n\nimport reducedMotion from '../../utils/reduced-motion';\n\nimport style from './style.module.css';\n\nconst KEYFRAMES = { opacity: [0, 1] };\n\nif (!reducedMotion()) {\n  KEYFRAMES.transform = ['translateY(50px)', 'translateY(0)'];\n}\n\nconst ANIMATION_OPTIONS = {\n  fill: 'both',\n  easing: 'cubic-bezier(0, .99, .56, 1.1)',\n  duration: 500,\n};\n\n// Make the card appear and slide softly from down to up when the page is loaded\nconst AnimatedCard = forwardRef(({ overrideComponent, ...props }, ref) => {\n  const containerRef = useRef(null);\n\n  useLayoutEffect(() => {\n    const node = containerRef.current && containerRef.current.firstElementChild;\n    if (!(node && node.animate)) return;\n\n    const index = Array.from(\n      document.querySelectorAll('main section'),\n    ).findIndex(section => node === section);\n\n    const animation = node.animate(KEYFRAMES, {\n      ...ANIMATION_OPTIONS,\n      delay: index * 150,\n    });\n\n    return () => animation.cancel();\n  }, []);\n\n  const Component = overrideComponent ? 'section' : Card;\n\n  return (\n    <div ref={containerRef} className={style.container}>\n      <Component component=\"section\" {...props} ref={ref} />\n    </div>\n  );\n});\n\nexport default AnimatedCard;\n","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getCardUtilityClass(slot) {\n  return generateUtilityClass('MuiCard', slot);\n}\nconst cardClasses = generateUtilityClasses('MuiCard', ['root']);\nexport default cardClasses;","'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"className\", \"raised\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport chainPropTypes from '@mui/utils/chainPropTypes';\nimport composeClasses from '@mui/utils/composeClasses';\nimport styled from '../styles/styled';\nimport { useDefaultProps } from '../DefaultPropsProvider';\nimport Paper from '../Paper';\nimport { getCardUtilityClass } from './cardClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root']\n  };\n  return composeClasses(slots, getCardUtilityClass, classes);\n};\nconst CardRoot = styled(Paper, {\n  name: 'MuiCard',\n  slot: 'Root',\n  overridesResolver: (props, styles) => styles.root\n})(() => {\n  return {\n    overflow: 'hidden'\n  };\n});\nconst Card = /*#__PURE__*/React.forwardRef(function Card(inProps, ref) {\n  const props = useDefaultProps({\n    props: inProps,\n    name: 'MuiCard'\n  });\n  const {\n      className,\n      raised = false\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const ownerState = _extends({}, props, {\n    raised\n  });\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(CardRoot, _extends({\n    className: clsx(classes.root, className),\n    elevation: raised ? 8 : undefined,\n    ref: ref,\n    ownerState: ownerState\n  }, other));\n});\nprocess.env.NODE_ENV !== \"production\" ? Card.propTypes /* remove-proptypes */ = {\n  // ┌────────────────────────────── Warning ──────────────────────────────┐\n  // │ These PropTypes are generated from the TypeScript type definitions. │\n  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │\n  // └─────────────────────────────────────────────────────────────────────┘\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * If `true`, the card will use raised styling.\n   * @default false\n   */\n  raised: chainPropTypes(PropTypes.bool, props => {\n    if (props.raised && props.variant === 'outlined') {\n      return new Error('MUI: Combining `raised={true}` with `variant=\"outlined\"` has no effect.');\n    }\n    return null;\n  }),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])\n} : void 0;\nexport default Card;","// extracted by mini-css-extract-plugin\nexport default {\"card\":\"style_card__pEq-k\",\"tabs\":\"style_tabs__HhB5H\",\"nglcard\":\"style_nglcard__3eXUT\",\"container\":\"style_container__eab4U\",\"legend_container\":\"style_legend_container__swfrT\",\"legend\":\"style_legend__SS-DS\"};","// extracted by mini-css-extract-plugin\nexport default {\"horizontal\":\"style_horizontal__KW-k9\",\"vertical\":\"style_vertical__YKrT2\",\"heatmap-horizontal\":\"style_heatmap-horizontal__HjdIF\",\"heatmap-vertical\":\"style_heatmap-vertical__utgJY\"};","import React, { useMemo } from 'react';\n\nimport { CardContent } from '@mui/material';\n\nimport style from './style.module.css';\n\nimport D3HeatmapGrid from '../d3-heatmap-grid';\n\n// Display a color legend using the d3 heatmap\nconst ColorLegend = ({\n  // Title to be rendered over the legend\n  title = '',\n  // Maximum and minimum possible values\n  maxValue = 1,\n  minValue = 0,\n  // Colors to represent the values range from lower to higher (e.g. ['red', 'white', 'blue'])\n  colorPlan,\n  // Number of cells in the legend heatmap (i.e. how many times we split the color bar)\n  splits = 19,\n  // Set if the color bar must be veritcal\n  vertical = false,\n  flip = false,\n  // Allow to force a custom className from the parent component\n  className,\n}) => {\n  // Create a fake 'data' object for the heatmap\n  const { legendData, legendLabels } = useMemo(() => {\n    // Set the legend, which is another heatmap\n    // Make labels for different value regions\n    const values = [];\n    // If the minimum and maximum are the same then there is only one label to show\n    if (minValue === maxValue) values.push(minValue);\n    // Otherwise make the different regions\n    // WARNING: If we have same minimum and maximum values then the logic below will enter in an infinite loop\n    else for (let i = minValue; i <= maxValue; i += (maxValue - minValue) / splits)\n      values.push(i);\n\n    // Round all values\n    let legendLabels = values.map(val => Math.round(val));\n    // If there is more than 1 label then the make sure all of them are unique\n    // WARNING: If we have a single label  the logic below will enter in an infinite loop\n    if (legendLabels.length > 1)\n      // If there are repeated labels then we round to the next 10 fold lower scale until there are no more duplicates\n      for (let decimal = 1; new Set(legendLabels).size < legendLabels.length; decimal++) {\n        legendLabels = values.map(val => Math.round(val * 10 ** decimal) / 10 ** decimal);\n      }\n\n    // Data must be an array inside an array\n    const legendData = vertical ? values.map(v => [v]) : [values];\n    if (flip) {\n      // Flip the legend data array\n      legendData.reverse();\n      legendLabels.reverse();\n    }\n\n    return { legendData, legendLabels };\n  }, [maxValue, minValue, splits, vertical]);\n\n  // Render\n  return (\n    <CardContent\n      className={\n        className ? className : vertical ? style.vertical : style.horizontal\n      }\n    >\n      {title}\n      <D3HeatmapGrid\n        data={legendData}\n        xAxisValues={vertical ? [''] : legendLabels}\n        yAxisValues={vertical ? legendLabels : ['']}\n        colorPlan={colorPlan}\n        flippedXAxisValues={false}\n        className={\n          vertical ? style['heatmap-vertical'] : style['heatmap-horizontal']\n        }\n      />\n    </CardContent>\n  );\n};\n\nexport default ColorLegend;\n","// Function involved in getting text pixels width\n// WARNING: These functions do not work properly in Chrome (not an easy problem)\n\n// This function allows to calculate the width of a given string text\n// The font for the calculation in the d3 default font\nexport const getTextWidth = (text, font = 'bold 10px sans-serif') => {\n  const canvas =\n    getTextWidth.canvas ||\n    (getTextWidth.canvas = document.createElement('canvas'));\n  const context = canvas.getContext('2d');\n  context.font = font;\n  const metrics = context.measureText(text);\n  return metrics.width;\n};\n\n// Alternative way to obtain text width\n// Probably the only way to obtain text height\nexport const getTextSizeDOM = (text, font = 'bold 10px sans-serif') => {\n  const element = document.createElement('div');\n  const content = document.createTextNode(text);\n  element.appendChild(content);\n  Object.assign(element.style, {\n    font: font,\n    position: 'absolute',\n    visibility: 'hidden',\n    height: 'auto',\n    width: 'auto',\n    'white-space': 'nowrap',\n  });\n  document.body.appendChild(element);\n  return { width: element.clientWidth, height: element.clientHeight };\n};\n\n// Get the whole body width\nexport const getBodyWidth = () => {\n  return Math.max(\n    document.body.scrollWidth,\n    document.documentElement.scrollWidth,\n    document.body.offsetWidth,\n    document.documentElement.offsetWidth,\n    document.documentElement.clientWidth,\n  );\n};\n\n// Get the whole body height\nexport const getBodyHeight = () => {\n  return Math.max(\n    document.body.scrollHeight,\n    document.documentElement.scrollHeight,\n    document.body.offsetHeight,\n    document.documentElement.offsetHeight,\n    document.documentElement.clientHeight,\n  );\n};\n","import React, { useRef, useEffect, useState, memo } from 'react';\n\nimport { getTextWidth, getTextSizeDOM } from '../../utils/document-measurer';\n\nimport { axisBottom, select, scaleLinear, scaleBand, axisLeft } from 'd3';\n\nimport { setTooltipPosition } from '../../utils/tooltip-position-manager';\n\n// According to d3 documentation\nconst defaultD3font = 'normal 10px sans-serif';\n// Experimentally verfied\nconst titlesD3font = 'normal 14px sans-serif';\n\n// DANI: Ni este 'memo' ni el 'useMemo' de dentro funcionan. Siempre se vuelve a calcular\n// Lo óptimo sería que funcionase, ya que cada vez que el ususario hace click todo se vuelve a cargar\n// Hay que construir una 'comparision function': https://reactjs.org/docs/react-api.html#reactmemo\n\n// Input 'data' is expected to be an array of arrays (i.e. a matrix)\nconst D3HeatmapGrid = memo(\n  ({\n    data, // The main values\n    xAxisValues = [], // String labels for the horizontal axis\n    yAxisValues = [], // String labels for the vertical axis\n    xAxisLabel, // String title for the horizontal axis\n    yAxisLabel, // String title for the vertical axis\n    verticalPadding = 0,\n    colorPlan = ['red', 'white', 'blue'],\n    colorScale, // In case a color scale is passed it overrides the max, mid and min colors\n    onTooltip, // Text to be rendered on the tooltip\n    onClick, // Function to be called when clicking on the heatmap\n    flippedXAxisValues = true, // Set if values in x axis is horizontal (false) or vertical (true)\n    margin = { top: 10, right: 10, bottom: 10, left: 10 },\n    className,\n    NaNColor = '#ffffff', // Default black color for NaN\n    minValue,\n    maxValue,\n    addBorder = true, // Add a border to each cell\n  }) => {\n    if (!data)\n      throw new Error(\n        `Data is missing. Data is mandatory for the heatmap representation`,\n      );\n    // Check that there are no duplicates in both x and y axes values\n    // WARNING: Duplicates would not make the heatmap fail, but they will result in overlaps\n    if (xAxisValues.length !== new Set(xAxisValues).size) {\n      console.log(xAxisValues);\n      throw new Error(`Duplicated values in the X axis. See console logs`);\n    }\n    if (yAxisValues.length !== new Set(yAxisValues).size) {\n      console.log(yAxisValues);\n      throw new Error(`Duplicated values in the Y axis. See console logs`);\n    }\n\n    // If any label is empty, fill it with 1-n numbers\n    if (xAxisValues.length === 0)\n      xAxisValues = Array.from(Array(data[0].length).keys());\n    if (yAxisValues.length === 0)\n      yAxisValues = Array.from(Array(data[0].length).keys());\n\n    // Convert data to heatmap friendly format\n\n    // Join all rows into a single array with all values\n    const values = [].concat(...data);\n    // Save the maximum and minimum values - excluding NaN values\n    const validValues = values.filter(value => !isNaN(value));\n    const maxv = maxValue ?? Math.max(...validValues);\n    const minv = minValue ?? Math.min(...validValues);\n    // Repeat the x labels as many times as rows are there\n    const xlabs = [].concat(...Array(data.length).fill(xAxisValues));\n    // Repeat each y label as many times as rows are there\n    const ylabs = [];\n    for (const lab of yAxisValues)\n      ylabs.push(...Array(xAxisValues.length).fill(lab));\n    // Fill an array with an object fo each d, x and y\n    const fdata = [];\n    for (const i in values) {\n      fdata.push({ v: values[i], x: xlabs[i], y: ylabs[i] });\n    }\n\n    // Set the reference to the element where the heatmap will be allocated\n    const containerRef = useRef(null);\n    // Save the previous chart reference so we can remove it before a new render\n    const previousCharts = useRef(null);\n\n    // Use a state as a workaround to force rerenders on window resize\n    const [, setCurrentWindow] = useState(null);\n\n    // ----------------------------------------------------------------------------------------\n\n    // OFFSETS: Estimate the space needed for all the labels and titles to not overlap\n\n    // Set a small offset to be added between normal labels and 90 degrees rotated labels\n    // This offset is added between the y labels (normal) and the y title (rotated)\n    // This offset is added between the x labels (rotated) and the x title (normal)\n    const roatatedTextOffset = 9; // In px\n\n    // Set a small offset to keep away the axis labels and the axis values\n    // They are very close to the axis values by default\n    const axisLabelsOffset = 9; // In px\n\n    // Measure the height of normal and text and labels\n    const textHeight = getTextSizeDOM('|', defaultD3font).height;\n    const labelsHeight =\n      getTextSizeDOM('|', titlesD3font).height + axisLabelsOffset;\n\n    // Get the calculated widths of all y labels and select the maximum\n    // In addition, add a small offset between labels and the axis which is added further\n    // This offset is only in x axes, which are rotated 90 degrees and end too much close to the axis\n    const maxXAxisWidth =\n      Math.max(\n        ...xAxisValues.map(label => getTextWidth(label, defaultD3font)),\n      ) + roatatedTextOffset;\n    // Get the calculated widths of all y labels and select the maximum\n    const maxYAxisWidth = Math.max(\n      ...yAxisValues.map(label => getTextWidth(label, defaultD3font)),\n    );\n\n    // In addition, add a small offset between labels and the axis which is added further\n    // This offset is only in x axes, which are rotated 90 degrees and end too much close to the axis\n    const xAxisLabelHegiht = xAxisLabel ? labelsHeight : 0;\n    const yAxisLabelHeight = yAxisLabel ? labelsHeight + roatatedTextOffset : 0;\n\n    // Finally, estimate the space needed by axes, titles, etc.\n    const requiredXOffset = flippedXAxisValues\n      ? maxXAxisWidth + xAxisLabelHegiht\n      : textHeight + xAxisLabelHegiht;\n    const requiredYOffset =\n      yAxisValues.length === 1\n        ? Math.max(maxYAxisWidth, getTextWidth(yAxisLabel, titlesD3font))\n        : maxYAxisWidth + yAxisLabelHeight;\n\n    // Set the dimensions and offsets of the graph\n    const offset = {\n      top: margin.top,\n      right: margin.right,\n      bottom: requiredXOffset + margin.bottom,\n      left: requiredYOffset + margin.left,\n    };\n\n    // ----------------------------------------------------------------------------------------\n\n    // The chart is assigned to a referenced 'div' which must be rendered first\n    // All this process is runned after the render\n    useEffect(() => {\n      // Reset the chart\n      // WARNING: For some reason, if this part is re-render the original render is not gone\n      // WARNING: We must reset the element manually or infinite elements are rendered and stacked\n      if (previousCharts.current)\n        previousCharts.current.forEach(chart => chart.remove());\n\n      // Get the current element where all this heatmap is placed\n      const container = containerRef.current;\n      // The first render, when there is no reference to the current element yet, we skip the process\n      const {\n        clientWidth: width,\n        clientHeight: height,\n      } = container.parentElement;\n\n      // Calculate the body width and height\n      const bodyWidth = width - offset.left - offset.right;\n      const bodyHeight = height - offset.top - offset.bottom;\n\n      // Calculate how many labels we can show in any axis while avoiding overlapping\n      // Take in count that bottom labels are rotated 90º, so it is their height that counts\n      // The '* 1.05' is to grant a small padding\n      const xSlots =\n        bodyWidth / ((flippedXAxisValues ? textHeight : maxXAxisWidth) * 1.05);\n      const ySlots = bodyHeight / (textHeight * 1.05);\n\n      // Estimate how many labels we must skip to reach the desired number\n      const xstep = Math.ceil(xAxisValues.length / xSlots);\n      const ystep = Math.ceil(yAxisValues.length / ySlots);\n\n      // Use canvas to display the heatmap blocks since d3 is not as efficient\n      // Canvas is set this way so we can access this specific element later\n      // WARNING: Using the 'document.getElementById' is risky since there may be more\n      // WARNING: e.g. the color legend\n      const canvasElement = document.createElement('CANVAS');\n      select(container)\n        .node()\n        .appendChild(canvasElement);\n      const canvas = select(canvasElement)\n        .attr('id', 'canvas')\n        .attr('width', bodyWidth)\n        .attr('height', bodyHeight)\n        .style('position', 'absolute')\n        .style('top', offset.top + 'px')\n        .style('left', offset.left + 'px')\n        .style('cursor', onClick ? 'pointer' : undefined);\n      const canvasContext = canvas\n        .node()\n        .getContext('2d' /*, {desynchronized: true}*/);\n\n      // append the svg object to the body of the page\n      const svg = select(container)\n        .append('svg')\n        .attr('id', 'svg')\n        .attr('viewBox', [0, 0, width, height]);\n\n      // Build X scales and axis:\n      const x = scaleBand()\n        .range([offset.left, bodyWidth + offset.left])\n        .domain(xAxisValues)\n        .paddingInner(0);\n\n      const xAxis = svg\n        .append('g')\n        .attr('transform', 'translate(0,' + (bodyHeight + offset.top) + ')')\n        .call(\n          axisBottom(x).tickFormat((d, i) => {\n            if (i % xstep === 0) return d;\n            else return '';\n          }),\n        )\n        .selectAll('text');\n\n      if (flippedXAxisValues) {\n        xAxis\n          .style('text-anchor', 'end')\n          .attr('dx', -roatatedTextOffset + 'px')\n          .attr('dy', -roatatedTextOffset + 'px')\n          .attr('transform', 'rotate(-90)');\n      }\n\n      // Build the X axis label\n      svg\n        .append('text')\n        .attr('class', 'x label')\n        .attr('text-anchor', 'middle')\n        .attr('x', offset.left + bodyWidth / 2)\n        .attr('y', offset.top + bodyHeight + requiredXOffset)\n        .text(xAxisLabel);\n\n      // Build Y scales and axis:\n      const y = scaleBand()\n        .domain(yAxisValues)\n        .range([offset.top, bodyHeight + offset.top])\n        .padding(verticalPadding);\n\n      svg\n        .append('g')\n        .attr('transform', 'translate(' + offset.left + ', 0)')\n        .call(\n          axisLeft(y).tickFormat((d, i) => {\n            if (i % ystep === 0) return d;\n            else return '';\n          }),\n        );\n\n      // Build the Y axis label\n      if (yAxisValues.length === 1) {\n        svg\n          .append('text')\n          .attr('class', 'y label')\n          .attr('text-anchor', 'start')\n          .attr('x', 0)\n          .attr('y', margin.top + bodyHeight)\n          .text(yAxisLabel);\n      } else {\n        svg\n          .append('text')\n          .attr('class', 'y label')\n          .attr('text-anchor', 'middle')\n          .attr('x', -(offset.top + bodyHeight / 2))\n          .attr(\n            'y',\n            margin.left +\n              yAxisLabelHeight -\n              roatatedTextOffset -\n              axisLabelsOffset,\n          )\n          .attr('transform', 'rotate(-90)')\n          .text(yAxisLabel);\n      }\n\n      // Build color scale\n      const myColor = value => {\n        if (isNaN(value)) {\n          return NaNColor;\n        }\n        \n        const colorMapper = colorScale \n          ? colorScale \n          : scaleLinear()\n              .range(colorPlan)\n              .domain([minv, (minv + maxv) / 2, maxv]);\n              \n        return colorMapper(value);\n      };\n\n      // Get cell size according to d3 scale band\n      const cellWidth = x.bandwidth();\n      const cellHeight = y.bandwidth();\n\n      // Display heatmap cells using canvas\n      data.forEach((row, cy) => {\n        const yPosition = y(yAxisValues[cy]) - offset.top;\n        row.forEach((value, cx) => {\n          const xPosition = x(xAxisValues[cx]) - offset.left;\n          canvasContext.fillStyle = myColor(value);\n          canvasContext.fillRect(xPosition, yPosition, cellWidth, cellHeight);\n        \n        if (addBorder){  \n          // Add border\n          canvasContext.strokeStyle = myColor(value); // Use same color as fill\n          canvasContext.lineWidth = 1;\n          canvasContext.strokeRect(xPosition, yPosition, cellWidth, cellHeight);}\n        });\n      });\n\n      // Get the current mouse position in a standard format\n      const getMousePosition = e => {\n        // Get canvas current position\n        // WARNING: This line must be inside the function since canvas position may change when scrolling\n        const canvasRect = canvasElement.getBoundingClientRect();\n        // Get the exact mouse positions\n        const xPosition = e.clientX - canvasRect.left;\n        const yPosition = e.clientY - canvasRect.top;\n        // Calculate the equivalent x and y indexes\n        let xIndex = Math.floor(xPosition / x.step());\n        let yIndex = Math.floor(yPosition / y.step());\n        // Sometimes it may happend in the borders of the heatmap that ihe index is out of range\n        const xLimit = data[0].length - 1;\n        if (xIndex < 0) xIndex = 0;\n        if (xIndex > xLimit) xIndex = xLimit;\n        const yLimit = data.length - 1;\n        if (yIndex < 0) yIndex = 0;\n        if (yIndex > yLimit) yIndex = yLimit;\n        // Get also the equivalent axis values and the cell value\n        const xAxisValue = xAxisValues[xIndex];\n        const yAxisValue = yAxisValues[yIndex];\n        const value = data[yIndex][xIndex];\n        return { xIndex, yIndex, value, xAxisValue, yAxisValue };\n      };\n\n      // In case there is a tooltip, handle how to show it\n      let tooltip;\n      if (onTooltip) {\n        // Set up the tooltip, which is hidden by default\n        tooltip = document.createElement('div');\n        Object.assign(tooltip.style, {\n          display: 'none',\n          position: 'absolute',\n          pointerEvents: 'none',\n          backgroundColor: 'rgba( 0, 0, 0, 0.6 )',\n          color: 'lightgrey',\n          padding: '8px',\n          fontFamily: 'sans-serif',\n        });\n        container.appendChild(tooltip);\n\n        canvasElement.onmousemove = e => {\n          // Get current mouse position\n          const mousePosition = getMousePosition(e);\n          // Set the tooltip text\n          tooltip.innerText = onTooltip(mousePosition);\n          //console.log(xIndex + ',' + yIndex);\n          // Set the tooltip position inside the heatmap\n          tooltip.style.display = 'inline-block';\n          const {\n            x: xTooltipPosition,\n            y: yTooltipPosition,\n          } = setTooltipPosition(\n            container,\n            tooltip,\n            { x: e.clientX, y: e.clientY },\n            3,\n          );\n          tooltip.style.left = xTooltipPosition + 'px';\n          tooltip.style.top = yTooltipPosition + 'px';\n        };\n        canvasElement.onmouseleave = () => {\n          tooltip.style.display = 'none';\n        };\n      }\n\n      // Handle when a cell is clicked\n      if (onClick) {\n        canvasElement.onmousedown = e => {\n          // Get current mouse position\n          const mousePosition = getMousePosition(e);\n          // Call the on click function\n          onClick(mousePosition);\n        };\n      }\n\n      // Record all elements which must be removed manually when re-rendering\n      previousCharts.current = tooltip ? [svg, canvas, tooltip] : [svg, canvas];\n\n      const handleResize = () => {\n        setCurrentWindow({\n          innerWidth: window.innerWidth,\n          innerHeight: window.innerHeight,\n        });\n      };\n      window.addEventListener('resize', handleResize);\n\n      // Cleaning function\n      return () => {\n        window.removeEventListener('resize', handleResize);\n      };\n    }); // This useEffect has no dependencies\n\n    // Finally, render the heatmap\n    return (\n      // It is important to specify a height value\n      // Otherwise canvas and svg may be not coordinated\n      <div\n        className={className}\n        style={className ? undefined : { height: '600px', width: '600px' }}\n      >\n        <div\n          ref={containerRef}\n          id={'container'}\n          // WARNING: This width 100% may seem redundant, but chrome needs it\n          style={{ position: 'relative', width: '100%', height: '100%' }}\n        />\n      </div>\n    );\n  },\n);\n\nexport default D3HeatmapGrid;\n","import React, { lazy, Suspense, useState, useContext, useMemo, useRef, useEffect } from 'react';\nimport { useInView } from 'react-intersection-observer';\n\nimport {\n  CardContent,\n  Table,\n  TableHead,\n  TableBody,\n  TableRow,\n  TableCell,\n  FormControlLabel,\n  Checkbox,\n  Tabs,\n  Tab,\n  Typography,\n  Slider,\n} from '@mui/material';\n\nimport Card from '../../../components/animated-card';\nimport ViewerWithControls from '../../../components/viewer-with-controls';\nimport Loading from '../../../components/loading';\nimport ColorLegend from '../../../components/color-legend';\n\nimport useAPI from '../../../hooks/use-api';\nimport { ProjectCtx } from '../../../contexts';\nimport { BASE_PATH_PROJECTS } from '../../../utils/constants';\n\nimport style from './style.module.css';\nimport { ColormakerRegistry } from 'ngl';\n\nconst useInViewOptions = { triggerOnce: true, rootMargin: '100px' };\n\nconst LipidInteractions = () => {\n  const { accessionAndMdNumber, topology, inchikeyReferences } = useContext(ProjectCtx);\n  const [nglRef, isNglVisible] = useInView(useInViewOptions);\n  const viewerRef = useRef(null);\n\n  // Get the default representations\n  const defaultRepresentations = topology && topology.defaultRepresentations;\n\n  // Send a request to the API with the url of the specific analysis\n  const {\n    loading: interactionsLoading,\n    payload: interactionsPayload,\n    error: interactionsError,\n  } = useAPI(`${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/analyses/lipid-inter/`);\n\n  // Add state for selected lipid type\n  const [selectedLipid, setSelectedLipid] = useState(null);\n  const [representations, setRepresentations] = useState(null);\n  const schemes = useRef({});\n  const maxOccupancy = useRef({});\n\n  // Get available lipid types for tabs\n  const lipidTypes = useMemo(() => {\n    if (!interactionsPayload || !interactionsPayload.data) return [];\n    \n    // Get available lipid types for tabs\n    return Object.keys(interactionsPayload.data).filter(key => key !== 'residue_indices');\n  }, [interactionsPayload]);\n  \n  // Set initial selected lipid when data loads\n  useMemo(() => {\n    if (lipidTypes.length && !selectedLipid) {\n      setSelectedLipid(lipidTypes[0]);\n    }\n    // Save max occupancy of all lipids in a ref\n    maxOccupancy.current = lipidTypes.reduce((acc, lipid) => {\n      acc[lipid] = Math.max(...interactionsPayload.data[lipid]);\n      return acc;\n    }, {});\n    maxOccupancy.current = Math.max(...Object.values(maxOccupancy.current));\n  }, [lipidTypes, selectedLipid]);\n\n  // Get the names and synonyms from the references\n  const lipidNames = useMemo(() => {\n    if (!lipidTypes.length || !inchikeyReferences) return {};\n    return lipidTypes.reduce((acc, lipid) => {\n      const ref = inchikeyReferences.find(ref => ref.inchikey === lipid);\n      let name, shortName, longName;\n      if (ref.lipidmaps.synonyms) {\n        name = ref.lipidmaps.name;\n        shortName = ref.lipidmaps.synonyms.split('; ').sort((a, b) => a.length - b.length)[0];\n        longName = ref.lipidmaps.sys_name;\n      } else if (ref.swisslipids.synonyms) {\n        name = shortName = ref.swisslipids.synonyms.find(item => item.type === 'abbreviation').name;\n        longName = ref.swisslipids.entity_name;\n      }\n      console.log('lipid', lipid, 'name', name, 'shortName', shortName, 'longName', longName);\n      acc[lipid] = { name, shortName, longName };\n      return acc;\n    }, {});\n  }, [lipidTypes, inchikeyReferences]);\n\n  // Get the lipid residue selection for the SpawnViewer\n    const lipidSelection = useMemo(() => {\n      if (!lipidTypes.length || !topology) return {};\n      return lipidTypes.reduce((acc, lipid) => {\n        const resIndices = topology.getReferenceResidueIndices(lipid);\n        const atomsSelection = `( @${topology.residue2atomIndices(resIndices).join(',')} )`;\n        acc[lipid] = atomsSelection;\n        return acc;\n      }, {});\n    }, [lipidTypes, topology]);\n\n  // Generate a color scheme based on interaction data\n  const generateScheme = (lipid) => {\n    if (!interactionsPayload || !interactionsPayload.data || !lipid) return null;\n    return ColormakerRegistry.addScheme(function (params) {\n      this.atomColor = function (atom) {\n        // Check if this residue has interaction data\n        const resIdx = interactionsPayload.data.residue_indices.indexOf(atom.residueIndex);\n        if (resIdx === -1) return 0xffffff;\n        const value = interactionsPayload.data[lipid][resIdx];\n        // Create a gradient from white (0xffffff) to dark red (0x800000) through orange\n        // For white -> orange -> dark red transition\n        const normalized = Math.sqrt(value/maxOccupancy.current);\n        let red = 255;\n        let green, blue;\n        \n        if (normalized < 0.5) {\n        // White to orange transition (first half)\n        green = 255 - Math.floor(128 * normalized * 2); // Gradually reduce green\n        blue = 255 - Math.floor(255 * normalized * 2);  // Rapidly reduce blue\n        } else {\n        // Orange to dark red transition (second half)\n        green = 127 - Math.floor(127 * (normalized - 0.5) * 2); // Continue reducing green\n        blue = 0; // Blue stays at zero\n        }\n        \n        // Combine into RGB color\n        return (red << 16) | (green << 8) | blue;\n        };\n    }, lipid);\n  };\n\n  // Get or create a scheme for a lipid type\n  const getSchemeForLipid = (lipidType) => {\n    if (!schemes.current[lipidType]) {\n      schemes.current[lipidType] = generateScheme(lipidType);\n    }\n    return schemes.current[lipidType];\n  };\n  \n  // Update representations when selection changes\n  useEffect(() => {\n    if (!defaultRepresentations || defaultRepresentations.length === 0 || !selectedLipid) return;\n    defaultRepresentations.forEach(rep => {\n        if (rep.name.toLowerCase().includes('protein')) { \n            rep.color = 'custom';\n            rep.type = 'spacefill';\n            rep.color = getSchemeForLipid(selectedLipid);\n            rep.customScheme = selectedLipid;\n        } else if (rep.name.toLowerCase().includes('lipid')) {\n            rep.color = 'grey';\n            rep.opacity = 0.1;\n        }\n    });\n    const lipidRep = {\n      'name': selectedLipid,\n      'type': 'licorice',\n      'color': 'orange',\n      'opacity': 0.3,\n      'selection': lipidSelection[selectedLipid],\n    };\n\n    setRepresentations([...defaultRepresentations, lipidRep]);\n  }, [selectedLipid, defaultRepresentations]);\n\n  if (interactionsLoading) return <Loading />;\n  if (interactionsError) return interactionsError.toString();\n  if (!interactionsPayload) return 'Something bad happened with Lipid Interactions analysis';\n\n  return (\n    <Suspense fallback={<Loading />}>\n      <Card className={style.card}>\n        <CardContent>\n          <Tabs\n            value={selectedLipid}\n            variant=\"fullWidth\"\n            indicatorColor=\"primary\"\n            textColor=\"primary\"\n            onChange={(event, value) => {\n              setSelectedLipid(value);\n            }}\n            className={style.tabs}\n          >\n            {lipidTypes.map((lipid) => (\n              lipidNames[lipid] && <Tab\n                key={lipid}\n                value={lipid}\n                label={\n                  <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>\n                    <span title={`${lipidNames[lipid].longName}`}>\n                      {lipidNames[lipid].name}\n                    </span>\n                    {lipidNames[lipid].shortName !== lipidNames[lipid].name && (\n                      <Typography variant=\"caption\" color=\"text.secondary\" title={`${lipidNames[lipid].longName}`}>\n                        {lipidNames[lipid].shortName}\n                      </Typography>\n                    )}\n                  </div>\n\n                }\n              />\n            ))}\n          </Tabs>\n          \n          {/* <div className={style.controls}>\n            <Typography id=\"threshold-slider\" gutterBottom>\n              Interaction Threshold: {threshold}\n            </Typography>\n            <Slider\n              value={threshold}\n              onChange={(e, newValue) => setThreshold(newValue)}\n              aria-labelledby=\"threshold-slider\"\n              step={0.05}\n              marks\n              min={0}\n              max={1}\n              valueLabelDisplay=\"auto\"\n            />\n            \n          </div> */}\n        </CardContent>\n      </Card>\n      \n      {/* <Card className={style.legend_container}>\n        <ColorLegend\n          title={'Lipid Interaction Frequency'}\n          minValue={0}\n          maxValue={1}\n          colorPlan={colorPalette}\n          vertical={true}\n          className={style.legend}\n        />\n      </Card> */}\n      \n      <Card className={style.nglcard} ref={nglRef}>\n        {isNglVisible ? (\n          <ViewerWithControls\n            className={style.container}\n            representationsState={[representations, setRepresentations]}\n            ref={viewerRef}\n            rotateX={true}\n          />\n        ) : (\n          <div style={{ height: '50vh' }} />\n        )}\n      </Card>\n    </Suspense>\n  );\n};\n\nexport default LipidInteractions;\n"],"names":["KEYFRAMES","opacity","reducedMotion","transform","ANIMATION_OPTIONS","fill","easing","duration","forwardRef","_ref","ref","overrideComponent","props","containerRef","useRef","useLayoutEffect","node","current","firstElementChild","animate","index","Array","from","document","querySelectorAll","findIndex","section","animation","delay","cancel","Component","Card","_jsx","className","style","children","component","getCardUtilityClass","slot","generateUtilityClass","generateUtilityClasses","_excluded","CardRoot","styled","Paper","name","overridesResolver","styles","root","overflow","React","inProps","useDefaultProps","raised","other","_objectWithoutPropertiesLoose","ownerState","_extends","classes","composeClasses","useUtilityClasses","clsx","elevation","undefined","title","maxValue","minValue","colorPlan","splits","vertical","flip","legendData","legendLabels","useMemo","values","push","i","map","val","Math","round","length","decimal","Set","size","v","reverse","_jsxs","CardContent","D3HeatmapGrid","data","xAxisValues","yAxisValues","flippedXAxisValues","getTextWidth","text","font","arguments","context","canvas","createElement","getContext","measureText","width","getTextSizeDOM","element","content","createTextNode","appendChild","Object","assign","position","visibility","height","body","clientWidth","clientHeight","defaultD3font","titlesD3font","memo","xAxisLabel","yAxisLabel","verticalPadding","colorScale","onTooltip","onClick","margin","top","right","bottom","left","NaNColor","addBorder","Error","console","log","keys","concat","validValues","filter","value","isNaN","maxv","max","minv","min","xlabs","ylabs","lab","fdata","x","y","previousCharts","setCurrentWindow","useState","textHeight","labelsHeight","maxXAxisWidth","label","maxYAxisWidth","xAxisLabelHegiht","yAxisLabelHeight","requiredXOffset","requiredYOffset","offset","useEffect","forEach","chart","remove","container","parentElement","bodyWidth","bodyHeight","xSlots","ySlots","xstep","ceil","ystep","canvasElement","select","attr","canvasContext","svg","append","scaleBand","range","domain","paddingInner","xAxis","call","axisBottom","tickFormat","d","selectAll","padding","axisLeft","myColor","scaleLinear","cellWidth","bandwidth","cellHeight","row","cy","yPosition","cx","xPosition","fillStyle","fillRect","strokeStyle","lineWidth","strokeRect","getMousePosition","e","canvasRect","getBoundingClientRect","clientX","clientY","xIndex","floor","step","yIndex","xLimit","yLimit","xAxisValue","yAxisValue","tooltip","display","pointerEvents","backgroundColor","color","fontFamily","onmousemove","mousePosition","innerText","xTooltipPosition","yTooltipPosition","setTooltipPosition","onmouseleave","onmousedown","handleResize","innerWidth","window","innerHeight","addEventListener","removeEventListener","id","useInViewOptions","triggerOnce","rootMargin","LipidInteractions","accessionAndMdNumber","topology","inchikeyReferences","useContext","ProjectCtx","nglRef","isNglVisible","useInView","viewerRef","defaultRepresentations","loading","interactionsLoading","payload","interactionsPayload","error","interactionsError","useAPI","BASE_PATH_PROJECTS","selectedLipid","setSelectedLipid","representations","setRepresentations","schemes","maxOccupancy","lipidTypes","key","reduce","acc","lipid","lipidNames","find","inchikey","shortName","longName","lipidmaps","synonyms","split","sort","a","b","sys_name","swisslipids","item","type","entity_name","lipidSelection","resIndices","getReferenceResidueIndices","atomsSelection","residue2atomIndices","join","generateScheme","ColormakerRegistry","addScheme","params","this","atomColor","atom","resIdx","residue_indices","indexOf","residueIndex","normalized","sqrt","green","blue","rep","lipidType","toLowerCase","includes","customScheme","lipidRep","Loading","toString","Suspense","fallback","card","Tabs","variant","indicatorColor","textColor","onChange","event","tabs","Tab","flexDirection","alignItems","Typography","nglcard","ViewerWithControls","representationsState","rotateX"],"sourceRoot":""}