{"version":3,"file":"static/js/6899.b0744db6.chunk.js","mappings":"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","sources":["webpack://mdposit/./src/components/loading/style.module.css?350d","components/loading/index.js","hooks/use-api/index.js","utils/topology-manager/residues-library/index.js","utils/topology-manager/get-default-reprensetations/index.js","utils/topology-manager/get-epitopes-representations/index.js","utils/topology-manager/get-mutations-representations/index.js","utils/topology-manager/index.js","utils/project-manager/index.js","hooks/use-toggle-state/index.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"loading\":\"style_loading__Vdgbc\",\"show\":\"style_show__wIdQ5\"};","import React, { useLayoutEffect } from 'react';\nimport cn from 'classnames';\n//import { sleep, frame } from 'timing-functions';\n\nimport { CircularProgress } from '@mui/material';\n\nimport useToggleState from '../../hooks/use-toggle-state';\n\nimport style from './style.module.css';\n\nconst WAIT_DELAY = 750; // 750ms\n\n// This component is used to hide the loading indicator for a bit (just in case\n// the next content is quick enough, because we don't want a flash with the\n// indicator), then slowly display it.\n// In the best of cases this component will *never* even have to be displayed\nconst Loading = ({ wait = WAIT_DELAY }) => {\n  const [flag, toggleFlag] = useToggleState(false);\n  // This is a hook\n  useLayoutEffect(() => {\n    const timer = setTimeout(() => {\n      toggleFlag();\n    }, wait);\n    return () => clearTimeout(timer);\n\n    /*\n    let mounted = true;\n    sleep(wait) // wait for a bit\n      // this might be useful if the page is not even visible\n      .then(() => frame()) // Wait for the next animation frame\n      // After waiting, check if mounted is still true\n      .then(() => {\n        // If mounted is false it means that the loading was over before the wait ended\n        if (mounted) toggleFlag(); // This toggleFlag changes the flag from false to true\n      });\n    // In a useEffect or similar hooks, \"return\" stands for an ending function\n    // The ending function is called when the components is no longer rendered\n    return () => (mounted = false); // When useLayoutEffect is over or cancelled, set mounted to false\n    */\n  }, [toggleFlag, wait]); // useLayoutEffect is only called when the toggleFlag is called (only once)\n  // Return an animated circle\n  return (\n    <div\n      title=\"loading...\" // This tag appears when the mouse remains over the circle\n      className={cn(style.loading, { [style.show]: flag })}\n    >\n      {flag && (\n        <CircularProgress\n          variant=\"indeterminate\"\n          color=\"primary\"\n          size={50}\n          thickness={5}\n        /> // Renders the circle\n      )}\n    </div>\n  );\n};\n\nexport default Loading;\n","import { useState, useEffect } from 'react';\nimport axios from 'axios';\n\n// Empty response\nconst blank = {\n  loading: false,\n  payload: null,\n  error: null,\n};\n\n// Loading response\nconst loading = {\n  loading: true,\n};\n\n\n// Default cache expiration time (e.g., 1 hour in milliseconds)\nconst DEFAULT_CACHE_EXPIRATION = 60 * 60 * 1000;\n\n// Load cache from localStorage\nconst loadCache = () => {\n  const cachedData = localStorage.getItem('apiCache');\n  return cachedData ? JSON.parse(cachedData) : {};\n};\n\n// Save cache to localStorage\nconst saveCache = (cache) => {\n  localStorage.setItem('apiCache', JSON.stringify(cache));\n};\n\n// Cache object to store API responses\nlet cache = loadCache();\n// Get data from the API\nconst useAPI = (url, cacheOptions = {}) => {\n  // Destructure options and set default values\n  const {\n    name = '',\n    cacheOn = false,\n    cacheExpiration = DEFAULT_CACHE_EXPIRATION, // Default cache expiration\n  } = cacheOptions;\n  \n  // Check cache synchronously before initializing state\n  const initialData = (() => {\n    if (cacheOn && cache[name]) {\n      const responseData = cache[name];\n      const now = Date.now();\n      const receivedTime = new Date(responseData.received).getTime()\n      // Use cached data if it hasn't expired\n      if (now - receivedTime < cacheExpiration) {\n        return responseData;\n      }\n    }\n    return blank;\n  })();\n  // Set the 'data' state object, which is returned at the end of this function\n  const [data, setData] = useState(initialData);\n\n  // This react hook is responisble for sending the request to the API\n  // This react hook has 'url' dependencies, so it is only runned once per request\n  useEffect(() => {\n    // In case there is no valid url\n    // This may be useful as a workaround to not call the API, since hooks can not be called conditionally\n    if (!url) {\n      setData(blank);\n      return;\n    }\n    // This is axios (https://www.npmjs.com/package/axios)\n    // Set a cancel option (token). If a request includes this cancel token in its options, the request can be cancelled\n    // In order to cancel the request, the same token must be used through axios\n    const source = axios.CancelToken.source();\n    let didCancel = false;\n    // Make a request in a Promise/await way\n    axios(url, {\n      // This token allows us to further cancel the request if necessary\n      cancelToken: source.token,\n      // Send the start time so we can calculate the response time when we get the response\n      startTime: new Date()\n    })\n      // (.then is async) If the request has succeed\n      .then(response => {\n        if (didCancel) return;\n        // Calculate the response time\n        const endTime = new Date();\n        const startTime = response.config.startTime;\n        const responseTime = endTime - startTime; // In ms\n        // Return response data\n        const responseData = {\n          url: url,\n          loading: false,\n          payload: response.data,\n          error: null,\n          time: responseTime,\n          received: endTime,\n        };\n        // Cache the response if caching is enabled\n        if (cacheOn) {\n          cache[name] = responseData;\n          saveCache(cache);\n        }\n        setData(responseData);\n      })\n      // Otherwise\n      .catch(error => {\n        if (didCancel) return;\n        const responseData = {\n          url: url,\n          loading: false,\n          payload: null,\n          error: error,\n        };\n        setData(responseData);\n      });\n\n    return () => {\n      // Cancel the request\n      source.cancel();\n      didCancel = true;\n    };\n\n    // 'useEffect' will only be called when the url changes\n  }, [url]);\n  // If there is no url then return the blank response\n  if (!url) return blank;\n  // Data is returned this way\n  // Data is returned only if the data.url matches the url from this request\n  // These urls do not macth each first time 'useAPI' is called\n  // 'data' is not reset each time 'useAPI' is called so the url is from the previous request\n  if (data.url === url || initialData.url === url) return data;\n  // The first time 'useAPI' is called only { loading: true } is returned\n  else return loading;\n};\n\nexport default useAPI;\n","// Set a library of residues useful for topology handling\n\n// Amino acids\nexport const PROTEIN_RESIDUE_NAME_LETTERS = {\n    'ALA':'A',\n    'ALAN':'A',\n    'ALAC':'A',\n    'ARG':'R',\n    'ARGN':'R',\n    'ARGC':'R',\n    'ASN':'N',\n    'ASNN':'N',\n    'ASNC':'N',\n    'ASP':'D',\n    'ASPN':'D',\n    'ASPC':'D',\n    'CYS':'C',\n    'CYSN':'C',\n    'CYSC':'C',\n    'CYH':'C',\n    'CSH':'C',\n    'CSS':'C',\n    'CYX':'C',\n    'CYP':'C',\n    'GLN':'Q',\n    'GLNN':'Q',\n    'GLNC':'Q',\n    'GLU':'E',\n    'GLUN':'E',\n    'GLUC':'E',\n    'GLUP':'E',\n    'GLY':'G',\n    'GLYN':'G',\n    'GLYC':'G',\n    'HIS':'H',\n    'HISN':'H',\n    'HISC':'H',\n    'HID':'H',\n    'HIE':'H',\n    'HIP':'H',\n    'HSD':'H',\n    'HSE':'H',\n    'ILE':'I',\n    'ILEN':'I',\n    'ILEC':'I',\n    'ILU':'I',\n    'LEU':'L',\n    'LEUN':'L',\n    'LEUC':'L',\n    'LYS':'K',\n    'LYSN':'K',\n    'LYSC':'K',\n    'MET':'M',\n    'METN':'M',\n    'METC':'M',\n    'PHE':'F',\n    'PHEN':'F',\n    'PHEC':'F',\n    'PRO':'P',\n    'PRON':'P',\n    'PROC':'P',\n    'PRÃ˜':'P',\n    'PR0':'P',\n    'PRZ':'P',\n    'SER':'S',\n    'SERN':'S',\n    'SERC':'S',\n    'THR':'T',\n    'THRN':'T',\n    'THRC':'R',\n    'TRP':'W',\n    'TRPN':'W',\n    'TRPC':'W',\n    'TRY':'W',\n    'TYR':'Y',\n    'TYRN':'Y',\n    'TYRC':'Y',\n    'VAL':'V',\n    'VALN':'V',\n    'VALC':'V',\n};\n// Nucleotides\nexport const DNA_RESIDUE_NAME_LETTERS = {\n    'DA': 'A',\n    'T': 'T',\n    'T3': 'T',\n    'T5': 'T',\n    'DT': 'T',\n    'DC': 'C',\n    'DG': 'G',\n    'DA3': 'A',\n    'DA5': 'A',\n    'DT3': 'T',\n    'DT5': 'T',\n    'DC3': 'C',\n    'DC5': 'C',\n    'DG3': 'G',\n    'DG5': 'G',\n};\nexport const RNA_RESIDUE_NAME_LETTERS = {\n    'RA': 'A',\n    'U': 'U',\n    'U3': 'U',\n    'U5': 'U',\n    'RU': 'U',\n    'RC': 'C',\n    'RG': 'G',\n    'RA3': 'A',\n    'RA5': 'A',\n    'RU3': 'U',\n    'RU5': 'U',\n    'RC3': 'C',\n    'RC5': 'C',\n    'RG3': 'G',\n    'RG5': 'G',\n};\nexport const NUCLEIC_RESIDUE_NAME_LETTERS = {\n    ...DNA_RESIDUE_NAME_LETTERS,\n    ...RNA_RESIDUE_NAME_LETTERS,\n    'A': 'A',\n    'A3': 'A',\n    'A5': 'A',\n    'C': 'C',\n    'C3': 'C',\n    'C5': 'C',\n    'G': 'G',\n    'G3': 'G',\n    'G5': 'G',\n};\n// All of them together\nexport const RESIDUE_NAME_LETTERS = {\n    ...PROTEIN_RESIDUE_NAME_LETTERS,\n    ...NUCLEIC_RESIDUE_NAME_LETTERS\n};\n\n// Lipid common residue names\n// https://github.com/molstar/molstar/blob/master/src/mol-model/structure/model/types/lipids.ts\n// Source: https://github.com/NMRLipids/Databank/blob/main/Scripts/DatabankLib/settings/molecules.py#L10\n// Meanings: https://github.com/NMRLipids/Databank/blob/48fdf2c4149d0db8900ce08b0e74dc1836dcfab3/Scripts/BuildDatabank/docs/source/moleculesAndMapping.md?plain=1#L50\nexport const FATTY_RESIDUE_NAMES = new Set([\n    'ANE5', 'APC', 'BNSM', 'BOG', 'CER', 'CER180', 'CER1', 'CER2', 'CPC', 'DAPA', 'DAPC', 'DAPE',\n    'DAPG', 'DAPS', 'DBPA', 'DBPC', 'DBPE', 'DBPG', 'DBPS', 'DBSM', 'DDOPC',\n    'DEPC', 'DFPA', 'DFPC', 'DFPE', 'DFPG', 'DFPS', 'DGPA', 'DGPC', 'DGPE',\n    'DGPG', 'DGPS', 'DHMDMAB', 'DIPA', 'DIPC', 'DIPE', 'DIPG', 'DIPS', 'DLIPC',\n    'DLPA', 'DLPC', 'DLPE', 'DLPG', 'DLPS', 'DMPC', 'DMTAP', 'DNPA', 'DNPC',\n    'DNPE', 'DNPG', 'DNPS', 'DOG', 'DOPA', 'DOPC', 'DOPE', 'DOPG', 'DOPS',\n    'DPCE', 'DPP', 'DPPA', 'DPPC', 'DPPE', 'DPPG', 'DPPGK', 'DPPI', 'DPPS',\n    'DPSM', 'DRPA', 'DRPC', 'DRPE', 'DRPG', 'DRPS', 'DSPC', 'DTPA', 'DTPC',\n    'DTPE', 'DTPG', 'DTPS', 'DUPE', 'DUPS', 'DVPA', 'DVPC', 'DVPE', 'DVPG',\n    'DVPS', 'DXCE', 'DXPA', 'DXPC', 'DXPE', 'DXPG', 'DXPS', 'DXSM', 'DYPA',\n    'DYPC', 'DYPE', 'DYPG', 'DYPS', 'GB3', 'GM1', 'IPC', 'LPC', 'LLPE', 'LPPA', 'LPPC',\n    'LPPE', 'LPPG', 'LPPS', 'NSM', 'OPC', 'PADG', 'PAPA', 'PAPC', 'PAPE', 'PAPG',\n    'PAPI', 'PAPS', 'PAzePCdeprot', 'PAzePCprot', 'PEPC', 'PGPA', 'PGPC',\n    'PGPE', 'PGPG', 'PGPS', 'PGSM', 'PIDG', 'PIPA', 'PIPC', 'PIPE', 'PIPG',\n    'PIPI', 'PIPS', 'PLPS', 'PNCE', 'PNSM', 'PODG', 'POP', 'POPA', 'POPC', 'POPE',\n    'POPG', 'POPI', 'POPS', 'POSM', 'PPC', 'PQPE', 'PQPS', 'PRPA', 'PRPC',\n    'PRPE', 'PRPG', 'PRPS', 'PUDG', 'PUPA', 'PUPC', 'PUPE', 'PUPI', 'PUPS',\n    'PVDG', 'PVP', 'PVPI', 'PVSM', 'PYPC', 'SAPI', 'SAPI24', 'SAPI25', 'SDG',\n    'SDPE', 'SLPI', 'SLiPC', 'SM16', 'SM18', 'SOPC', 'SSM', 'TLCL_0H', 'TMCL', 'TOCL',\n    'TPC', 'UPC', 'VPC', 'XNCE', 'XNSM']);\nexport const STEROID_RESIDUE_NAMES = new Set([ \"CHL\", \"CHL1\", \"CHOL\", \"DCHOL\" ]);\n\n// Set typical residue names to guess what residues are\nexport const STANDARD_SOLVENT_RESIDUE_NAMES = new Set([ 'SOL', 'WAT', 'HOH', 'TIP', 'TP3', 'SWM4' ]);\n// WARNING: Note that standard names also include + and - symbols\n// Use functions such as Structure.select_counter_ions instead of checking if the set includes a name\nexport const STANDARD_COUNTER_CATION_ATOM_NAMES = new Set([ 'K', 'NA', 'SOD', 'POT' ]);\nexport const STANDARD_COUNTER_ANION_ATOM_NAMES = new Set([ 'CL', 'CLA' ]);\nexport const STANDARD_COUNTER_ION_ATOM_NAMES = STANDARD_COUNTER_CATION_ATOM_NAMES.union(STANDARD_COUNTER_ANION_ATOM_NAMES)\nexport const STANDARD_DUMMY_ATOM_NAMES = new Set([ 'MW' ]);\nexport const DUMMY_ATOM_ELEMENT = 'Dm'\nexport const CG_ATOM_ELEMENT = 'Cg'","import { generateRanges } from 'src/utils/auxiliar-functions';\n\n// Get NGL predefined default representations\nconst getDefaultRepresentations = topology => {\n    // If there is no topology yet then return here and wait for data to be downloaded\n    if (!topology) return [];\n    // Set a list to store all final representations\n    const reps = [];\n    // Iterate the different chains\n    // Every representation, no matter the type, will be organized as one per chain\n    topology.iterchains().forEach(chain => {\n        // Set the chain label\n        const metadataChainName = chain.metadataChainName\n        const chainLabel = metadataChainName\n            ? `${metadataChainName} (Chain ${chain.name})`\n            : `Chain ${chain.name}`;\n        // Get residues in the current chain\n        const chainResidues = chain.residues;\n        // 1. Polymers such as proteins and nucleic acids\n        // Represent polymers in cartoon and colored by chain\n        // Note that coarse grain (CG) residues will not be propery represented in cartoon\n        // For this reason we must create a separated representation for them in spacefill (vdw)\n        const respresentPolymer = polymer => {\n            // Start by classify residues (note that this logic is actually run only once and then stored)\n            const residues = chainResidues.filter(residue => residue.classification === polymer);\n            if (residues.length === 0) return;\n            // First of all handle coarse grain residues\n            const cgResidues = residues.filter(residue => residue.isCg);\n            if (cgResidues.length > 0) {\n            const cgResiduesIndices = cgResidues.map(residue => residue.index);\n            const { rangedSelection: nglSelection } = topology.residueIndices2Ngl(cgResiduesIndices);\n            // Set the new representation\n            reps.push({\n                name: `${chainLabel} - ${polymer} polymer (coarse grain)`,\n                selection: nglSelection,\n                type: 'spacefill',\n                color: 'chainid',\n            });\n            }\n            // Now keep going with the all atom residues\n            const aaResidues = residues.filter(residue => !residue.isCg);\n            // Get ranges of residue indices in a row\n            const aaResiduesIndices = aaResidues.map(residue => residue.index);\n            const ranges =  [ ...generateRanges(aaResiduesIndices) ];\n            // Those regions with 3 residues or less are not representable by cartoon (NGL limitation)\n            // Therefore, we will set an additional licorice representation for them\n            const shortRanges = ranges.filter(range => range.length <= 3);\n            if (shortRanges.length > 0) {\n            // Transform the residue indices to a NGL selection\n            const shortResidueIndices = shortRanges.reduce((ac, curr) => ac.concat(curr), []);\n            const { rangedSelection: nglSelection } = topology.residueIndices2Ngl(shortResidueIndices);\n            // Set the new representation\n            reps.push({\n                name: `${chainLabel} - ${polymer} polymer (short)`,\n                selection: nglSelection,\n                type: 'licorice',\n                color: 'chainid',\n            });\n            }\n            // The long ranges are to be displayed in cartoon\n            const longRanges = ranges.filter(range => range.length > 3);\n            if (longRanges.length > 0) {\n            // Transform the residue indices to a NGL selection\n            const longResidueIndices = longRanges.reduce((ac, curr) => ac.concat(curr), []);\n            const { rangedSelection: nglSelection } = topology.residueIndices2Ngl(longResidueIndices);\n            // Set the new representation\n            reps.push({\n                name: `${chainLabel} - ${polymer} polymer`,\n                selection: nglSelection,\n                type: 'cartoon',\n                color: 'chainid',\n            });\n            // If this is a nucleic polymer then set also a representation for its bases\n            const nucleicPolymers = new Set([ 'dna', 'rna', 'nucleic' ]);\n            if (nucleicPolymers.has(polymer)) {\n                reps.push({\n                    name: `${chainLabel} - ${polymer} bases`,\n                    selection: nglSelection,\n                    type: 'base',\n                    color: 'resname',\n                });\n            }\n            }\n        }\n        // Represent protein polymers\n        respresentPolymer('protein');\n        // Represent DNA polymers\n        respresentPolymer('dna');\n        // Represent RNA polymers\n        respresentPolymer('rna');\n        // Represent other nucleic polymers\n        respresentPolymer('nucleic');\n        // 2. Ligands, small molecules which are referenced\n        // Represent ligands in ball+stick (cpk) colored by element\n        // Start by classify residues (note that this logic is actually run only once and then stored)\n        const ligandResidues = chainResidues.filter(residue => residue.classification === 'ligand');\n        if (ligandResidues.length > 0) {\n            // In case we have more than a different ligand in this chain, set a representation for each one\n            const ligandIds = new Set(ligandResidues.map(residue => residue.referenceId));\n            for (const ligandId of ligandIds) {\n            // Get the NGL selection of traget residues\n            const currentLigandResidueIndices = ligandResidues\n                .filter(residue => residue.referenceId === ligandId)\n                .map(residue => residue.index);\n            const { rangedSelection: nglSelection } = topology.residueIndices2Ngl(currentLigandResidueIndices);\n            // Add the representation\n            reps.push({\n                name: `${chainLabel} - ligand ${ligandId}`,\n                selection: nglSelection,\n                type: 'ball+stick',\n                color: 'element'\n            });\n            }\n        }\n        // 3. Lipids, usually membranes\n        // Represent membranes in grey licorice, with a reduced oppacity\n        // Thus we ease observing what is there inside of the membrane\n        // Start by finding lipid residues\n        const lipidClasses = new Set([ 'fatty', 'steroid' ]);\n        const lipidResidues = chainResidues.filter(residue => lipidClasses.has(residue.classification));\n        if (lipidResidues.length > 0) {\n            // Now parse them to a NGL selection\n            const lipidResidueIndices = lipidResidues.map(residue => residue.index);\n            const { rangedSelection: nglSelection } = topology.residueIndices2Ngl(lipidResidueIndices);\n            // Add the representation\n            reps.push({\n                name: `${chainLabel} - lipids`,\n                selection: nglSelection,\n                type: 'licorice',\n                color: 'grey',\n                opacity: 0.5,\n            });\n        }\n        // 4. Ions, single atoms\n        // Represent ions using spacefill (vdw) and colored by element\n        // Start by finding ion residues\n        const ionResidues = chainResidues.filter(residue => residue.classification === 'ion');\n        if (ionResidues.length > 0) {\n            // Now parse them to a NGL selection\n            const ionResidueIndices = ionResidues.map(residue => residue.index);\n            const { rangedSelection: nglSelection } = topology.residueIndices2Ngl(ionResidueIndices);\n            // Add the representation\n            reps.push({\n                name: `${chainLabel} - ions`,\n                selection: nglSelection,\n                type: 'ball+stick',\n                color: 'element',\n            });\n        }\n        // 5. Other, anything else\n        // Residues not falling in any previous section will be represented in low opacity purple licorice\n        // This includes solvent and unknown residues (e.g. carbohydrates)\n        const otherClasses = new Set([ 'solvent', 'unknown' ]);\n        const otherResidues = chainResidues.filter(residue => otherClasses.has(residue.classification));\n        if (otherResidues.length > 0) {\n            // Now parse them to a NGL selection\n            const otherResiduesIndices = otherResidues.map(residue => residue.index);\n            const { rangedSelection: nglSelection } = topology.residueIndices2Ngl(otherResiduesIndices);\n            // Add the representation\n            reps.push({\n                name: `${chainLabel} - other`,\n                selection: nglSelection,\n                type: 'licorice',\n                color: 'purple',\n                opacity: 0.3,\n            });\n        }\n    });\n    return reps;\n};\n\nexport default getDefaultRepresentations;\n","// Get NGL predefined representations for the epitopes page\nconst getEpitopesRepresentations = topology => {\n    if (!topology) return;\n    // Check that at least one of the protein references has epitopes\n    const anyReferenceEpitopes = topology.proteinReferences.some(\n        reference => !!reference.epitopes,\n    );\n    if (!anyReferenceEpitopes) return;\n    // Get the residues on each reference epitopes in the current topology numeration\n    const mappedResiduesPerReference = topology.proteinReferences.map(reference => {\n        // Get the reference name and epitopes\n        const referenceId = reference.uniprot;\n        const referenceEpitopes = reference.epitopes;\n        if (!referenceEpitopes) return [];\n        // Save all epitope residues together and eliminate duplicates\n        const epitopeResidues = Object.values(referenceEpitopes).map(\n            epitope => epitope.residues,\n        );\n        const allResidues = [].concat.apply([], epitopeResidues);\n        const uniqueResidues = Array.from(new Set(allResidues));\n        const mappedResidues = topology.getReferenceResidueIndices(\n            referenceId,\n            uniqueResidues,\n        );\n        if (!mappedResidues) return [];\n        return mappedResidues;\n    });\n    // Join all previous mapped residues together\n    const allMappedResidues = [].concat.apply(\n        [],\n        Object.values(mappedResiduesPerReference),\n    );\n    // Transform mapped residues indices to an NGL selection\n    const { rangedSelection, small } = topology.residueIndices2Ngl(\n        allMappedResidues,\n    );\n    const reps = [\n        {\n            name: 'Epitopes',\n            selection: rangedSelection || 'none',\n            type: small ? 'licorice' : 'cartoon',\n            color: 'purple',\n        },\n    ];\n    return reps;\n};\n\nexport default getEpitopesRepresentations;\n","import { ColormakerRegistry } from 'ngl';\n\nimport { color as d3color, scaleLinear } from 'd3';\n\n// Set the color of each residue in the NGL representation\n// WARNING: Grey looks better than white because the background may be white and resdiues are hard to see\nconst greyColorPlan = ['grey', 'yellow', 'red'];\n\n// Get NGL predefined representations for the mutations page\nconst getMutationsRepresentations = topology => {\n    if (!topology) return;\n    // Check that at least 1 of the references has entropies\n    const anyReferenceMutations = topology.proteinReferences.some(\n        reference => !!reference.entropies,\n    );\n    if (!anyReferenceMutations) return;\n\n    // Get the entorpies of each reference\n    // Save the logarithmic values on each reference\n    const entropiesPerReference = topology.proteinReferences.map(reference => {\n        if (!reference.entropies) return [];\n        const logarithmicEntropies = reference.entropies.map(entropy =>\n            Math.log(entropy + 0.0001),\n        );\n        reference.logarithmicEntropies = logarithmicEntropies;\n        return logarithmicEntropies;\n    });\n\n    // Save all array values together just to check the minimum and maximum values\n    const allEntropies = [].concat.apply([], entropiesPerReference);\n    const max = Math.max(...allEntropies);\n    const min = Math.min(...allEntropies);\n\n    // Set the color scale according to the maximum and minimum means\n    const colorScale = scaleLinear()\n        .range(greyColorPlan)\n        .domain([min, (min + max) / 2, max]);\n\n    const colorScheme = ColormakerRegistry.addScheme(function(params) {\n        this.atomColor = atom => {\n            // Find the residue index and then the entropy for this residue\n            // WARNING: atom.residueIndex starts the count at 0 although it may seem that starts at 1\n            // WARNING: It may happen that the first residue is a capping terminal and it is skipped\n            // WARNING: The cartoon representation would skip the non-standard residue and start by 1\n            const residueIndex = atom.residueIndex;\n            const residue = topology.getResidueByIndex(residueIndex);\n            const referenceId = residue.referenceId;\n            // If no reference residue was found then paint it white\n            if (!referenceId) return parseInt('ffffff', 16);\n            // get the corresponding entropy\n            // -1 because the residue 'x' would be the index 'x-1' in the array\n            const reference = residue.referenceData;\n            const entropies = reference.logarithmicEntropies;\n            if (!entropies || entropies.length === 0) return parseInt('ffffff', 16);\n            const entropy = entropies[residue.referenceNumber - 1];\n            // If there is no entropy at this point probably there is something wrong with the map\n            if (!entropy) return parseInt('ffffff', 16);\n            // Calculate the interpolated rgb for this value\n            // The interpolated color comes in rbg format\n            const hexColor = d3color(colorScale(entropy)).formatHex();\n            // The color interpolation returns a string like '#000000'\n            // We remove the first character ('#') and parse it to integer from hexadecimal\n            const color = parseInt(hexColor.substring(1), 16);\n            return color;\n        };\n    });\n\n    const reps = [\n        { name: 'Mutations', color: 'custom', customScheme: colorScheme },\n    ];\n    return reps;\n};\n\nexport default getMutationsRepresentations;\n","import {\n  RESIDUE_NAME_LETTERS,\n  PROTEIN_RESIDUE_NAME_LETTERS,\n  DNA_RESIDUE_NAME_LETTERS,\n  RNA_RESIDUE_NAME_LETTERS,\n  NUCLEIC_RESIDUE_NAME_LETTERS,\n  FATTY_RESIDUE_NAMES,\n  STEROID_RESIDUE_NAMES,\n  STANDARD_SOLVENT_RESIDUE_NAMES,\n  STANDARD_COUNTER_ION_ATOM_NAMES,\n  STANDARD_DUMMY_ATOM_NAMES,\n  DUMMY_ATOM_ELEMENT,\n  CG_ATOM_ELEMENT\n} from './residues-library';\n// Import some auxiliar functions\nimport {\n  countElement,\n  parsedSelectionRanger,\n  unique\n} from 'src/utils/auxiliar-functions';\n// Functions te setup some predefined viewer representations\nimport getDefaultRepresentations from './get-default-reprensetations';\nimport getEpitopesRepresentations from './get-epitopes-representations';\nimport getMutationsRepresentations from './get-mutations-representations';\n\n// Topology manager\n// Many functions to handle atom/residue/chain numeration conversions and more\n// All these functions which need the topology are able to read the context topology\n// However, it may be better to pass them the topology as an argument since the context may be null\n\n// Set the element colors for displaying\nconst ELEMENT_COLORS = {\n  H: 'white',\n  C: 'grey',\n  N: 'blue',\n  O: 'red',\n  S: 'yellow',\n  P: 'orange',\n};\n\n// Set a flag which may be found in atom bonds to represent irremediably missing bonds\n// These como from coarse grain simulations with no topology\nconst MISSING_BONDS_FLAG = 'MB';\n\n// Set an atom handler\nclass Atom {\n  // Constructor expects the topology this atom belongs to and the atom index\n  constructor (topology, atomIndex) {\n    this.topology = topology;\n    this.index = atomIndex;\n  }\n  // Atom name\n  get name () {\n    return this.topology.atomNames[this.index];\n  }\n  // Standard label\n  get label () {\n    return `${this.residue.standardLabel}.${this.name}`;\n  }\n  // Index of the residue this atom belongs to\n  get residueIndex () {\n    return this.topology.atomResidueIndices[this.index];\n  }\n  // Residue this atom belongs to\n  get residue () {\n    return this.topology.getResidueByIndex(this.residueIndex);\n  }\n  // Atom element\n  get element () {\n    return this.topology.atomElements[this.index];\n  }\n  // Viewer color representations for this atom according to tis element\n  get elementColor () {\n    const color = ELEMENT_COLORS[this.element];\n    if (!color) return 'black';\n    return color;\n  }\n  // Check if the resiude is coarse grained\n  get isCg () {\n    return this.element === CG_ATOM_ELEMENT;\n  }\n}\n\n// Set a residue handler\nclass Residue {\n  // Constructor expects the topology this residue belongs to and the residue index\n  constructor(topology, residueIndex) {\n    this.topology = topology;\n    this.index = residueIndex;\n    // Internal variables\n    this._classification = undefined;\n  }\n  // Original residue number (source numeration)\n  get number () {\n    return this.topology.residueNumbers[this.index];\n  }\n  // Chain index\n  get chainIndex () {\n    return this.topology.residueChainIndices[this.index];\n  }\n  // Chain name\n  get chainName () {\n    return this.topology.chainNames[this.chainIndex];\n  }\n  // Chain handler\n  get chain () {\n    return this.topology.getChainByIndex(this.chainIndex);\n  }\n  // Insertion code\n  get icode () {\n    if (!this.topology.residueIcodes) return null;\n    return this.topology.residueIcodes[this.index];\n  }\n  // NGL selection of this specific residue\n  get nglSelection () {\n    let selection = `:${this.chainName} and ${this.number}`\n    if (this.icode) selection += ` ^${this.icode}`\n    return selection;\n  }\n  // Residue name\n  get name () {\n    return this.topology.residueNames[this.index];\n  }\n  // Residue standard letter (e.g. ARG -> R)\n  get letter () {\n    if (!this.name) return;\n    const letter = RESIDUE_NAME_LETTERS[this.name];\n    if (letter) return letter;\n    return 'X';\n  }\n  // Get a cassification for this residue\n  // This is quite standard for proteins and nucleic acids\n  // It also relies on references to classify ligands\n  // However, it delegates in the 'classificationByName' function for the rest\n  // Available classifications:\n  // - protein\n  // - dna\n  // - rna\n  // - carbohydrate\n  // - fatty\n  // - steroid\n  // - ion\n  // - solvent\n  // - acetyl\n  // - amide\n  // - other\n  get classification () {\n    // If the classification was previously found then return the stored value\n    if (this._classification !== undefined) return this._classification;\n    // If this is a coarse grain residue then we can not classify it through the smart way\n    // We can only rely in residue names\n    if (this.isCg) {\n      this._classification = this.classificationByName;\n      return this._classification;\n    }\n    // Classify according this residue according to its atom composition\n    // ----- Ions -----------------------------------------------\n    // If it has only one atom then it must be an ion\n    if (this.atomCount === 1) {\n      this._classification = 'ion';\n      return this._classification;\n    }\n    // ----- Solvent -----------------------------------------------\n    // Solvent is water molecules\n    // First rely on the residue name\n    if (this.name in STANDARD_SOLVENT_RESIDUE_NAMES) {\n      this._classification = 'solvent'\n      return this._classification\n    }\n    // It may be water with a not known name\n    // Literally check if its a molecule with 3 atoms: 2 hydrogens and 1 oxygen\n    if (this.atomCount === 3) {\n      const atomElements = this.atoms.map(atom => atom.element);\n      const hydrogenCount = countElement(atomElements, 'H');\n      const oxygenCount = countElement(atomElements, 'O');\n      if (hydrogenCount === 2 && oxygenCount === 1) {\n        this._classification = 'solvent'\n        return this._classification\n      }\n    }\n    // ----- Protein -----------------------------------------------\n    // Protein definition according to vmd:\n    // a residue with atoms named C, N, CA, and O\n    // In our case we accept OC1 and OC2 or OT1 and OT2 instead of O for terminal residues\n    const atomNames = new Set(this.atoms.map(atom => atom.name));\n    if (['C', 'N', 'CA'].every(name => atomNames.has(name)) && (\n      atomNames.has('O') ||\n      ['OC1', 'OC2'].every(name => atomNames.has(name)) ||\n      ['OT1', 'OT2'].every(name => atomNames.has(name))\n    )) {\n      this._classification = 'protein'\n      return this._classification\n    }\n    // ----- Nucleic -----------------------------------------------\n    // Nucleic acids definition according to vmd:\n    // a residue with atoms named P, O1P, O2P and either O3â€™, C3â€™, C4â€™, C5â€™, O5â€™ or O3*, C3*, C4*, C5*, O5*\n    // Apparently it has been fixed so now a residue does not need to be phosphorylated to be considered nucleic\n    if ([\"O3'\", \"C3'\", \"C4'\", \"C5'\", \"O5'\"].every(name => atomNames.has(name))\n    || [\"O3*\", \"C3*\", \"C4*\", \"C5*\", \"O5*\"].every(name => atomNames.has(name))) {\n      // At this point we know it is nucleic\n      // We must tell the difference between DNA and RNA\n      if (atomNames.has(\"O2'\") || atomNames.has(\"O2*\")) this._classification = 'rna'\n      else this._classification = 'dna'\n      return this._classification\n    }\n    // ----- Ligands -----------------------------------------------\n    // If this residue is a ligand according to the references then classify it as ligand\n    if (this.referenceType === 'ligand') {\n      this._classification = 'ligand'\n      return this._classification\n    }\n    // ----- Others -----------------------------------------------\n    // If the residue does not fall in any of the previous conditions then try it with the residue name\n    this._classification = this.classificationByName;\n    return this._classification;\n  }\n  // Set an alternative function to \"try\" to classify the residues according only to its name\n  // This is useful for corase grain residues whose atoms may not reflect the real atoms\n  // WARNING: This logic is very limited and may return \"unknown\"\n  // WARNING: This logic relies in atom names, which may be not standard\n  get classificationByName () {\n    if (this.name in PROTEIN_RESIDUE_NAME_LETTERS) return 'protein';\n    if (this.name in DNA_RESIDUE_NAME_LETTERS) return 'dna';\n    if (this.name in RNA_RESIDUE_NAME_LETTERS) return 'rna';\n    if (this.name in NUCLEIC_RESIDUE_NAME_LETTERS) return 'nucleic';\n    if (FATTY_RESIDUE_NAMES.has(this.name)) return 'fatty';\n    if (STEROID_RESIDUE_NAMES.has(this.name)) return 'steroid';\n    if (STANDARD_COUNTER_ION_ATOM_NAMES.has(this.name)) return 'ion';\n    if (STANDARD_SOLVENT_RESIDUE_NAMES.has(this.name)) return 'solvent';\n    // If we do not know what it is\n    return 'unknown'\n  }\n  // Reference index in the topology\n  get referenceIndex () {\n    if (!this.topology.residueReferenceIndices) return null;\n    return this.topology.residueReferenceIndices[this.index];\n  }\n  // Reference id\n  get referenceId () {\n    const referenceIndex = this.referenceIndex;\n    if (referenceIndex === null) return null;\n    return this.topology.references[referenceIndex];\n  }\n  // Reference type\n  get referenceType () {\n    const referenceIndex = this.referenceIndex;\n    if (referenceIndex === null) return null;\n    return this.topology.referenceTypes[referenceIndex];\n  }\n  // Reference residue number (reference numeration)\n  get referenceNumber () {\n    if (!this.topology.residueReferenceNumbers) return null;\n    return this.topology.residueReferenceNumbers[this.index];\n  }\n  // Reference data\n  get referenceData () {\n    // If this residue has reference id then it belongs to no reference at all\n    if (this.referenceId === null) return null;\n    // Otherwise get the corresponding reference data\n    if (this.referenceType === 'protein') {\n      const reference = this.topology.proteinReferences.find(ref => ref.uniprot === this.referenceId);\n      // If reference is not found then it means it is missing in the database\n      if (!reference) {\n        console.error(`Reference id ${this.referenceId} is not found among protein references`);\n        return null;\n      }\n      return reference;\n    }\n    if (this.referenceType === 'ligand') {\n      const reference = this.topology.ligandReferences.find(ref => ref.pubchem === this.referenceId);\n      // If reference is not found then it means it is missing in the database\n      if (!reference) {\n        console.error(`Reference id ${this.referenceId} is not found among ligand references`);\n        return null;\n      }\n      return reference;\n    }\n    if (this.referenceType === 'inchikey') {\n      const reference = this.topology.inchikeyReferences.find(ref => ref.inchikey === this.referenceId);\n      // If reference is not found then it means it is missing in the database\n      if (!reference) {\n        console.error(`Reference id ${this.referenceId} is not found among inchikey references`);\n        return null;\n      }\n      return reference;\n    }\n    throw new Error(`Not supported reference type ${this.referenceType}`);\n  }\n  // Reference name\n  get referenceName () {\n    // If this is a ligand we may have a forced name in metadata\n    const forcedLigandName = this.topology.metadataLigandNames && this.topology.metadataLigandNames[this.referenceId];\n    if (forcedLigandName) return forcedLigandName;\n    // Get reference data\n    const referenceData = this.referenceData;\n    if (!referenceData) return null;\n    // Now return its name\n    return referenceData.name;\n  }\n  // Check if the resiude is in periodic boundary conditions\n  get isPbc () {\n    return this.topology.pbcResidues.has(this.index);\n  }\n  // Check if the resiude is coarse grained\n  get isCg () {\n    for (const atom of this.iteratoms())\n      if (atom.isCg) return true;\n    return false;\n  }\n  // Standard label for display\n  get standardLabel () {\n    // Add the chain to the label only if there is more than ona chain\n    let labelChain = '';\n    if (this.topology.chainNames.length > 1 ) labelChain = `${this.chainName}:`;\n    // Use the reference numeration if possible\n    // Use the source numeration otherwise\n    const referenceNumber = this.referenceNumber;\n    let labelNumber;\n    if (referenceNumber !== null) labelNumber = `${referenceNumber}`;\n    else labelNumber = `${this.number}*`;\n    // Get the insertion code\n    let labelIcode = this.icode;\n    if (!labelIcode) labelIcode = '';\n    // Get the residue name\n    const labelType = `(${this.name})`;\n    // Finally return the label\n    return labelChain + labelNumber + labelIcode + labelType;\n  }\n  // Atom indices for atoms which belong to this residue\n  get atomIndices () {\n    return this.topology.residueAtomIndices[this.index];\n  }\n  // Number of atoms which belong to this residue\n  get atomCount () {\n    return this.atomIndices.length;\n  }\n  // Check if the residue has an alpha carbon\n  get hasCAlpha () {\n    for (const atom of this.iteratoms())\n      if (atom.name === 'CA') return true;\n    return false;\n  }\n  // Iterate residue atoms\n  * iteratoms () {\n    for (const atomIndex of this.atomIndices)\n      yield new Atom(this.topology, atomIndex);\n  }\n  // Get all atoms already parsed\n  get atoms () {\n    return [...this.iteratoms()];\n  }\n};\n\n// Set a chain handler\nclass Chain {\n  // Constructor expects the chain index\n  constructor(topology, chainIndex) {\n    this.topology = topology;\n    this.index = chainIndex;\n  }\n  // Get the chain name\n  get name () {\n    return this.topology.chainNames[this.index];\n  }\n  get letter () {\n    return this.name;\n  }\n  // Get the metadata chain name\n  get metadataChainName () {\n    const metadataChainNames = this.topology.metadataChainNames;\n    if (!metadataChainNames) return '';\n    // OBSOLETE: Chains were stored as an array of names long time ago\n    if (Array.isArray(metadataChainNames)) return metadataChainNames[this.index] || '';\n    // Chains are stored as and object (e.g. { 'A': 'ACE2', 'B': 'RBD' })\n    else return metadataChainNames[this.name] || '';\n  }\n  // Get residue indcies\n  get residueIndices () {\n    return this.topology.chainResidueIndices[this.index];\n  }\n  // Get residue numbers\n  get residueNumbers () {\n    return this.topology.chainResidueNumbers[this.index];\n  }\n  // Get the residue sequence\n  get sequence () {\n    return this.sequences[this.index];\n  }\n  // Iterate chain residues\n  * iterresidues () {\n    for (const residueIndex of this.residueIndices)\n      yield new Residue(this.topology, residueIndex);\n  }\n  // Get all residues already parsed\n  get residues () {\n    return [...this.iterresidues()];\n  }\n}\n\nexport class Topology {\n  constructor(topology, metadata, references) {\n    // Save the topology data as it comes\n    this.atomNames = topology.atom_names;\n    this.atomElements = topology.atom_elements;\n    this.atomCharges = topology.atom_charges;\n    this.atomResidueIndices = topology.atom_residue_indices;\n    this.residueNames = topology.residue_names;\n    this.residueNumbers = topology.residue_numbers;\n    // Residue icodes have a different structure, since usually there are only a few icodes and not 1 per residue\n    // It is an object where keys are residue indices\n    // It is null when there are not icodes at all in the topology\n    // In order to convert it to the other values format we transform the object into an array\n    // Non assigned indices will become empty strings\n    const icodes = topology.residue_icodes;\n    // In case we have no icodes at all we set the icodes list as an empty string\n    // This is usefull for icode getters that do 'icodes && ...'\n    if (!icodes) this.residueIcodes = '';\n    else {\n      this.residueIcodes = Array(this.residueNames.length).fill('');\n      Object.entries(icodes).forEach(([residueIndex, icode]) => {\n        this.residueIcodes[+residueIndex] = icode;\n      });\n    }\n    this.residueChainIndices = topology.residue_chain_indices;\n    this.chainNames = topology.chain_names;\n    this.references = topology.references;\n    this.referenceTypes = topology.reference_types;\n    // DANI: Esta linea es para mantener las topologÃ­as viejas que solo tienen referencias de proteÃ­nas\n    if (!this.referenceTypes && this.references) this.referenceTypes = this.references.map(r => 'protein');\n    this.residueReferenceIndices = topology.residue_reference_indices;\n    this.residueReferenceNumbers = topology.residue_reference_numbers;\n    // Save atom bonds\n    // Replace missing bonds flags by empty arrays\n    this.atomBonds = topology.atom_bonds && topology.atom_bonds.map(bonds => \n      bonds === MISSING_BONDS_FLAG ? [] : bonds\n    )\n    // Save the PBC (Priodic Boundary Conditions) residues\n    this.pbcResidues = topology.pbc_residues && new Set(topology.pbc_residues);\n    // Data is stored in a down-top structure according to atom-residue-chain indices\n    // i.e. atoms know which residue they belong to and residues know which chain they belong to\n    // Now set the top-down structure values\n    // i.e. set which atoms are contained on every residue and which residues are contained on every chain\n    // WARNING: Note that arrays of empty arrays can not be filled as when filled with nulls or empty strings\n    // WARNING: We must fill them with this complicated method or all empty arrays would be the same array\n    this.residueAtomIndices = Array.from(Array(this.residueNames.length), () => []);\n    for (const [atomIndex, residueIndex] of this.atomResidueIndices.entries()) {\n      this.residueAtomIndices[residueIndex].push(atomIndex);\n    }\n    this.chainResidueIndices = Array.from(Array(this.chainNames.length), () => []);\n    for (const [ residueIndex, chainIndex ] of this.residueChainIndices.entries()) {\n      this.chainResidueIndices[chainIndex].push(residueIndex);\n    }\n    this.chainResidueNumbers = this.chainResidueIndices.map(\n      residueIndices => residueIndices.map(residueIndex => this.residueNumbers[residueIndex])\n    );\n    // Get chain sequences by adding all residue letters together for each chain\n    this.sequences = this.chainResidueIndices.map(residueIndices => \n      residueIndices.map(residueIndex => this.getResidueByIndex(residueIndex).letter).join('')\n    );\n    // Save metadata chain names\n    // They are not letters ('A', 'B', etc.) but actual names ('Spike', 'Glycans', etc.)\n    this.metadataChainNames = metadata.CHAINNAMES;\n    // Save metadata forced ligand names\n    this.metadataLigandNames = metadata.LIGANDNAMES;\n    // Save the references so we can further return reference data from here\n    this.proteinReferences = references.proteins;\n    this.ligandReferences = references.ligands;\n    this.chainReferences = references.chains;\n    this.inchikeyReferences = references.inchikeys;\n    // Assign the chain name and index to every chain reference\n    // Match every chain reference with its chain relying on sequence\n    for (const chainReference of this.chainReferences) {\n      chainReference.chains = [];\n      chainReference.chain_indices = [];\n      for (const [chainIndex, chainName] of Object.entries(this.chainNames)) {\n        // Match sequence\n        const chainSequence = this.sequences[chainIndex];\n        if (chainSequence !== chainReference.sequence) continue;\n        // Once we have a match assign the corresponding name and index\n        chainReference.chains.push(chainName);\n        chainReference.chain_indices.push(+chainIndex);\n      }\n      // If we did not manage to match this chain then log an error\n      if (chainReference.chain_indices.length === 0)\n        console.error('Unmatched chain reference ' + chainReference.sequence);\n    }\n    // Set internal values\n    this._defaultRepresentations = undefined;\n    this._epitopeRepresentations = undefined;\n    this._mutationRepresentations = undefined;\n  }\n\n  // --------------------------------------------------------------------\n  // BASICS\n  // --------------------------------------------------------------------\n\n  get atomCount () {\n    return this.atomNames.length;\n  }\n\n  get residueCount () {\n    return this.residueNumbers.length;\n  }\n\n  get chainCount () {\n    return this.chainNames.length;\n  }\n\n  // --------------------------------------------------------------------\n  // Atom getters\n  // --------------------------------------------------------------------\n\n  getAtomByIndex = atomIndex => {\n    const count = this.atomCount;\n    if (atomIndex >= count) throw new Error(\n      `The atom index ${atomIndex} is out of range. There are ${count} atoms in the topology`,\n    );\n    return new Atom(this, atomIndex);\n  };\n\n  // --------------------------------------------------------------------\n  // Residue getters\n  // --------------------------------------------------------------------\n\n  // Given a residue index, return its handler\n  getResidueByIndex = residueIndex => {\n    const count = this.residueCount;\n    if (residueIndex >= count) throw new Error(\n      `The residue index ${residueIndex} is out of range. There are ${count} residues in the topology`,\n    );\n    return new Residue(this, residueIndex);\n  };\n\n  // Given a residue parameters, find the residue and then return its handler\n  getResidueByParameters = (chainName, number, icode = null) => {\n    // Get the residue chain\n    const chain = this.getChainByName(chainName);\n    // Now iterate residues starting at this index\n    for (const residueIndex of chain.residueIndices) {\n      const residue = new Residue(this, residueIndex);\n      // Check if the residue number matches\n      if (residue.number !== number) continue;\n      // Check if the insertion code matches\n      if (residue.icode !== icode) continue;\n      // If everything matches then return this residue\n      return residue;\n    }\n    // There should always be a match\n    const icode_message = icode ? `icode ${icode}` : `no icode`\n    throw new Error(\n      `Residue with chain ${chainName}, number ${number} and ${icode_message} does not exist`,\n    );\n  };\n\n  // --------------------------------------------------------------------\n  // Chain getters\n  // --------------------------------------------------------------------\n\n  // Given a chain index, return its handler\n  getChainByIndex = chainIndex => {\n    const count = this.chainNames.length;\n    if (chainIndex >= count) throw new Error(\n      `The chain index ${chainIndex} is out of range. There are ${count} chains in the topology`,\n    );\n    return new Chain(this, chainIndex);\n  }\n\n  // Given a chain name, find the chain and return its handler\n  getChainByName = chainName => {\n    const chainIndex = this.chainNames.indexOf(chainName);\n    if (chainIndex === -1)\n      throw new Error(`Chain ${chainName} is not found in the topology`);\n    return new Chain(this, chainIndex);\n  }\n\n  // --------------------------------------------------------------------\n  // ITERATORS\n  // --------------------------------------------------------------------\n\n  // Iterate topology atoms\n  * iteratoms () {\n    for (let atomIndex = 0; atomIndex < this.atomCount; atomIndex++) \n      yield new Atom(this, atomIndex);\n  }\n\n  // Iterate topology residues\n  * iterresidues () {\n    for (let residueIndex = 0; residueIndex < this.residueCount; residueIndex++) \n      yield new Residue(this, residueIndex);\n  }\n\n  // Iterate topology chains\n  * iterchains () {\n    for (let chainIndex = 0; chainIndex < this.chainCount; chainIndex++) \n      yield new Chain(this, chainIndex);\n  }\n\n  // --------------------------------------------------------------------\n  // OTHER\n  // --------------------------------------------------------------------\n\n  // Given a list of residue indices, convert it to atom indices\n  residue2atomIndices = residueIndices => {\n    let atomIndices = [];\n    for (const residueIndex of residueIndices) {\n      const residue = this.getResidueByIndex(residueIndex);\n      atomIndices = atomIndices.concat(residue.atomIndices);\n    }\n    return atomIndices;\n  }\n\n  // Given a list of atom indices, convert it to residue indices\n  atom2residueIndices = atomIndices => {\n    const residueIndices = unique(atomIndices.map(index => this.atomResidueIndices[index]));\n    residueIndices.sort((a, b) => a - b);\n    return residueIndices;\n  }\n\n  // This function returns residue indices for every residue which belongs to a reference\n  // The reference must be specified with the topology reference id (i.e. uniprot id)\n  // Optionally, you may request only specific residue numbers according to reference numeration\n  // Note that one residue in the reference may be more than once or not be at all in the topology\n  getReferenceResidueIndices = (reference, residueNumbers = null) => {\n    if (!this.references) return;\n    // Get the requested reference index\n    const referenceIndex = this.references.indexOf(reference);\n    if (referenceIndex === -1) return;\n    const residueIndices = [];\n    this.residueReferenceIndices.forEach((refIndex, residueIndex) => {\n      if (refIndex !== referenceIndex) return;\n      // If no residue number were specified then simply return all residue indices\n      if (residueNumbers === null) return residueIndices.push(residueIndex);\n      // Otherwise we must check\n      const residueNumber = this.residueReferenceNumbers[residueIndex];\n      if (residueNumbers.includes(residueNumber)) residueIndices.push(residueIndex);\n    });\n    return residueIndices;\n  };\n\n  // Set an NGL selection from a list of residue indices\n  // e.g. [0, 1, 2, 3, ...] => nglSelection = \"(A: and 1, 3-5) or (B: and 1)\"\n  // In addition track if there is any small serie (i.e. 3 residues or less)\n  // DANI: Esta funciÃ³n no serÃ­a necesaria si se pudiesen hacer selecciones en NGL con Ã­ndices de residuos\n  // DANI: De hecho no harÃ­a falta eliminar residuos duplicados si se pudiesen hacer selecciones en NGL con Ã­ndices de residuos\n  residueIndices2Ngl = residueIndices => {\n    const rangedSelections = [];\n    let small = false;\n    // Parse each residue in complex notation\n    const parsedResidues = residueIndices.map(residueIndex => this.getResidueByIndex(residueIndex));\n    // Get unique chains\n    const chains = parsedResidues.map(r => r.chainName).filter((v, i, a) => a.indexOf(v) === i);\n    // For each chain, get all residues and \"range\" them\n    chains.forEach(chain => {\n      const chainResidues = parsedResidues.filter(v => v.chainName === chain).map(r => r.number);\n      const { rangedSelection: ranged, small: smallChain } = parsedSelectionRanger(chainResidues);\n      rangedSelections.push(`(:${chain} and (${ranged}))`); // Al parenthesis are mandatory\n      if (smallChain) small = true; // If any chain small is true then the overall small is true\n    });\n    // Join all ranged selections\n    const rangedSelection = rangedSelections.join(' or ');\n    return { rangedSelection, small };\n  };\n\n  // Set an NGL selection from a list of atom indices\n  // Note that atom selection in NGL does not support ranges\n  atomIndices2Ngl = atomIndices => {\n    return '@' + atomIndices.join(',');\n  };\n\n  // Given a list of residues indices, separate them by chain and return an object where keys are chain names\n  // e.g. [ 1, 2, 3, 17 ] -> { 'A': [1,2,3], 'B': [17] }\n  byChains = residuesIndices => {\n    const chained = {};\n    residuesIndices.forEach(residueIndex => {\n      const chainName = this.getResidueByIndex(residueIndex).chainName;\n      const current = chained[chainName];\n      if (current) current.push(residueIndex);\n      else chained[chainName] = [residueIndex];\n    });\n    return chained;\n  };\n\n  // Get all atom colors according to their elements\n  getAtomElementColors = () => {\n    return this.atomElements.map(element => {\n      const color = ELEMENT_COLORS[element];\n      if (!color) return 'black';\n      return color;\n    });\n  };\n\n  // --------------------------------------------------------------------\n  // VIEWER PREDEFINED REPRESENTATIONS\n  // --------------------------------------------------------------------\n\n  get defaultRepresentations () {\n    if (this._defaultRepresentations !== undefined) return this._defaultRepresentations;\n    this._defaultRepresentations = getDefaultRepresentations(this);\n    return this._defaultRepresentations;\n  }\n\n  get epitopesRepresentations () {\n    if (this._epitopeRepresentations !== undefined) return this._epitopeRepresentations;\n    this._epitopeRepresentations = getEpitopesRepresentations(this);\n    return this._epitopeRepresentations;\n  }\n\n  get mutationsRepresentations () {\n    if (this._mutationRepresentations !== undefined) return this._mutationRepresentations;\n    this._mutationRepresentations = getMutationsRepresentations(this);\n    return this._mutationRepresentations;\n  }\n}\n","// Get the use memo hook\nimport React, { useEffect, useMemo, useState } from 'react';\n// Function to request data through the API\nimport useAPI from '../../hooks/use-api';\n// Constants\nimport {\n    BASE_PATH_PROJECTS,\n    HOST_CONFIG,\n    REFERENCES_WITH_ENTROPIES,\n    REFERENCES_WITH_EPITOPES\n} from '../constants';\n// Import the topology manager class\nimport { Topology } from '../../utils/topology-manager';\n// Import the NGL structure parser\nimport { autoLoad } from 'ngl';\n\n// Set the project class\nexport class Project {\n    constructor(projectPayload) {\n        // Replicate all payload values in the project object\n        // This includes values such as metadata, files index, accession, etc.\n        Object.entries(projectPayload).forEach(([key, value]) => {\n            this[key] = value;\n        });\n        // If the project is wrong we do not even have metadata then stop here\n        if (!this.metadata) return;\n        // Calculate any additional metadata\n        if (!this.metadata.mdFrames) this.metadata.mdFrames = this.metadata.SNAPSHOTS;\n        this.metadata.timeLength = (this.metadata.FRAMESTEP && this.metadata.mdFrames &&\n            this.metadata.FRAMESTEP * this.metadata.mdFrames) || null;\n        // Set the count of MDs by excluding those MDs flagged as 'removed'\n        this.mdCount = this.mds ? this.mds.filter(md => md.slice(-9) !== '(removed)').length : 0;\n        // Calculate a few internal things\n        // Get the accession and the MD number in a single string which is useful to make API requests\n        // If project is in the old format then do not add the point and the MD number\n        const accessionOrId = this.accession || this.identifier;\n        this.accessionAndMdNumber = this.mds ? `${accessionOrId}.${this.mdNumber}` : accessionOrId;\n        // Check if there are interactions\n        this.hasInteractions = this.analyses.includes('interactions');\n        // Check if the populations file is found in the files index\n        this.isPopulated = Boolean(\n            this.files && this.files.find(filename => filename === 'populations.json'),\n        );\n        // Set the available directions in the client according to project data and host configuration\n        // IMPORTANT: Note that for every direction there must be a directory with equal name under src/pages/accession/\n        // Start with the directions which are to be always available\n        this.directions = {\n            overview: true,\n            trajectory: true,\n            files: true\n        }\n        // Set available analyses\n        // Start with the generic analyses\n        // These analyses are always visible but not clickable when data is missing\n        const genericAnalyses = [ 'rmsds', 'rgyr', 'fluctuation', 'pca', 'rmsd-perres',\n            'rmsd-pairwise', 'dist-perres', 'hbonds', 'energies', 'pockets', 'sasa', 'clusters',\n             'density', 'thickness', 'apl', 'lipid-order', 'lipid-inter', 'dihenergies' ];\n        for (const analysis of genericAnalyses) {\n            this.directions[analysis] = this.analyses.includes(analysis);\n        }\n        // Add the electrostatic direction whenever there are interactions\n        this.directions['electrostatic'] = this.analyses.includes('interactions');\n        // Add reference specific directions\n        this.directions['ligand-descriptors'] = Boolean(this.metadata && this.metadata.LIGANDS && this.metadata.LIGANDS.length > 0);\n        // Now set some specialized analyses\n        // These analyses are hidden when the project is out of context\n        // Their availability may be also more complicated than the generic ones\n        // Set covid-19 specific analyses\n        if (HOST_CONFIG.flags && HOST_CONFIG.flags.includes('covid')) {\n            const anyReferenceWithEntropies = this.metadata && this.metadata.REFERENCES &&\n                this.metadata.REFERENCES.find(ref => REFERENCES_WITH_ENTROPIES.includes(ref));\n            this.directions['mutations'] = Boolean(anyReferenceWithEntropies);\n            const anyReferenceWithEpitopes = this.metadata && this.metadata.REFERENCES &&\n                this.metadata.REFERENCES.find(ref => REFERENCES_WITH_EPITOPES.includes(ref));\n            this.directions['epitopes'] = Boolean(anyReferenceWithEpitopes);\n        }\n        // Set MSM specific analyses\n        if (this.metadata && this.metadata.METHOD === 'Markov state model (MSM)') {\n            this.directions['populations'] = this.files && this.files.find(file => file === 'populations.json');\n            this.directions['markov'] = this.analyses.includes('markov');\n        }\n        // Set an internal object to save data requested through the API\n        this._apiResponses = {\n            topology: undefined,\n            interactions: undefined,\n            references: undefined,\n            fileDescriptors: undefined,\n            populations: undefined\n        };\n        // Save the topology manager apart so we do not have to re-instantiate the class every time\n        this._topologyManager = null;\n        // Set the project base URL to request the API\n        this._apiBaseUrl = `${BASE_PATH_PROJECTS}/${this.accessionAndMdNumber}`;\n        // Set the creation date as a date object\n        this.creationDate = new Date(this.creationDate).toLocaleDateString('en-GB');\n        this.updateDate = this.updateDate ? new Date(this.updateDate).toLocaleDateString('en-GB') : undefined;\n    }\n    // Declare the different field endpoints to request the API\n    _apiEndpoints = {\n        topology: `/topology`,\n        structure: `/structure`,\n        interactions: `/analyses/interactions`,\n        references: `/references`,\n        fileDescriptors: `/filenotes`,\n        populations: `/files/populations.json`,\n    }\n    // Set a function to query the API and store the response for internal variables\n    _apiQuery = (fieldname, available = true) => {\n        // Set the request URL\n        let url = this._apiBaseUrl + this._apiEndpoints[fieldname];\n        // Request the value if it is available only\n        if (!available) url = null;\n        // If data for the requested fieldname is already saved then set the url as null\n        // This makes the useAPI hook not to repeat the query\n        if (this._apiResponses[fieldname] && this._apiResponses[fieldname].payload) url = null;\n        // Do the API query but save the result only if the url is not null\n        // Note that if url is null from the first render (i.e. there is not value at all) then its value will be null\n        const query = useAPI(url);\n        if (url !== null) this._apiResponses[fieldname] = query;\n        // If we are still loading then\n        return this._apiResponses[fieldname];\n    };\n\n    // Interactions getter\n    get interactions () {\n        // Ask the API for the interactions analysis\n        const response = this._apiQuery('interactions', this.hasInteractions);\n        const payload = response && response.payload;\n        // We will need the topology to make some corretions in old interactions\n        const topology = this.topology;\n        // Once we have interactions data, in case it is in the old format, adapt it to the new format\n        const interactions = useMemo(() => {\n            if (!payload || !topology) return;\n            // Fix old interaction by adding atom indices\n            // Iterate interactions in the payload\n            for (const interaction of response.payload) {\n                // If the interaction already has atom indices then there is nothing to do here\n                if (interaction.atom_indices_1) continue;\n                // If this is an old version then add atom indices\n                interaction.atom_indices_1 = topology.residue2atomIndices(interaction.residue_indices_1);\n                interaction.atom_indices_2 = topology.residue2atomIndices(interaction.residue_indices_2);\n                interaction.interface_atom_indices_1 = topology.residue2atomIndices(interaction.interface_indices_1);\n                interaction.interface_atom_indices_2 = topology.residue2atomIndices(interaction.interface_indices_1);\n            }\n            // Fill new interactions by adding residue indices\n            // Iterate interactions in the payload again\n            for (const interaction of response.payload) {\n                // If the interaction already has atom indices then there is nothing to do here\n                if (interaction.residue_indices_1) continue;\n                // If this is an old version then add atom indices\n                interaction.residue_indices_1 = topology.atom2residueIndices(interaction.atom_indices_1);\n                interaction.residue_indices_2 = topology.atom2residueIndices(interaction.atom_indices_2);\n                interaction.interface_indices_1 = topology.atom2residueIndices(interaction.interface_atom_indices_1);\n                interaction.interface_indices_2 = topology.atom2residueIndices(interaction.interface_atom_indices_2);\n            }\n            return response.payload;\n        }, [payload, topology]);\n        if (response === undefined) return undefined;\n        if (response.loading) return undefined;\n        if (response.error) throw new Error('Error when downloading project interactions: ' + response.error.message);\n        if (!response.payload) throw new Error('Something went wrong with project interactions');\n        return interactions;\n    }\n\n    // References getter\n    get references () {\n        const response = this._apiQuery('references');\n        if (response.loading) return undefined;\n        if (response.error) throw new Error('Error when downloading project references: ' + response.error.message);\n        if (!response.payload) throw new Error('Something went wrong with project references');\n        return response.payload;\n    }\n    // Specific references getters\n    get proteinReferences () {\n        const references = this.references;\n        return useMemo(() => references && references.filter(ref => ref.ref_type === 'proteins'), [references]);\n    }\n    get ligandReferences () {\n        const references = this.references;\n        return useMemo(() => references && references.filter(ref => ref.ref_type === 'ligands'), [references]);\n    }\n    get pdbReferences () {\n        const references = this.references;\n        return useMemo(() => references && references.filter(ref => ref.ref_type === 'pdbs'), [references]);\n    }\n    get chainReferences () {\n        const references = this.references;\n        return useMemo(() => references && references.filter(ref => ref.ref_type === 'chains'), [references]);\n    }\n    get inchikeyReferences () {\n        const references = this.references;\n        return useMemo(() => references && references.filter(ref => ref.ref_type === 'inchikeys'), [references]);\n    }\n\n    // Topology getter\n    get topology () {\n        // Get references to further load them to the topology manager\n        // Note that this must be done here to respect hooks\n        const references = this.references;\n        // Set an object with references used by the topology manager already classified\n        const topologyManagerReferences = {\n            proteins: this.proteinReferences,\n            ligands: this.ligandReferences,\n            chains: this.chainReferences,\n            inchikeys: this.inchikeyReferences\n        };\n        // Request topology data\n        const response = this._apiQuery('topology');\n        // Make sure data is available\n        if (response.loading) return undefined;\n        if (response.error) throw new Error('Error when downloading project topology: ' + response.error.message);\n        if (!response.payload) throw new Error('Something went wrong with project topology');\n        // Return the stored value in case we already have it\n        if (this._topologyManager) return this._topologyManager;\n        // Make sure references are available\n        if (references === undefined) return undefined;\n        this._topologyManager = new Topology(response.payload, this.metadata, topologyManagerReferences);\n        return this._topologyManager;\n    }\n\n    // File descriptors getter\n    get fileDescriptors () {\n        return this._apiQuery('fileDescriptors');\n    }\n    // Populations getter (populated ensembles only)\n    // Populations are requested only when this variable is read for the first time\n    // Then populations are stored so there is no need to repeat the query again\n    get populations () {\n        return this._apiQuery('populations', this.isPopulated);\n    }\n\n    // Get the reference frame\n    // Coordinates from this frame are to be used when representing the structure\n    // It is a frame which has been selected for distance between atoms to be coherent with atom bonds\n    // i.e. there are not bonded atoms to far or non-bonded atoms to close\n    // If bonds were to be guessed by atom distance they would be guess right\n    get referenceFrame () {\n        // If there is no reference frame then we use the first frame by default\n        // Note that old outdated projects may not have reference frame\n        if (this.refframe === undefined) return 0;\n        return this.refframe;\n    }\n\n    // Get the main structure data\n    // Note that the viewer would be already able to do it itself\n    // However we do it from here since this data is to be reused along different pages\n    // Thus we avoid having to download the same data every time\n    get structureData () {\n        // Ask the API for the structural data\n        const response = this._apiQuery('structure');\n        // Parse and memoize the result\n        const structureData = useMemo(() => {\n            if (!response.payload) return undefined;\n            return new Blob( [ response.payload ], { type: 'text/plain'} );\n        }, [response.payload]);\n        // Wait for the response and handle some possible errors\n        if (response.loading) return undefined;\n        if (response.error) throw new Error('Error when downloading project structure: ' + response.error.message);\n        if (!response.payload) throw new Error('Something went wrong with project structure');\n        return structureData\n    }\n\n    // Get the main structure data parsed by NGL\n    get nglStructure () {\n        // Set a state to store the already parsed data\n        const [ nglStructure, setNglStructure ] = useState(undefined);\n        // Get the current structure data\n        const structureData = this.structureData;\n        // Load the structure data in NGL asynchronously    \n        useEffect(() => {\n            if (!structureData) return;\n            autoLoad(structureData, { defaultRepresentation: false, ext: \"pdb\" })\n                // Once the parse has been completed update the parsed structure state\n                .then(prasedStructure => { setNglStructure({ file: prasedStructure }) })\n                // If there is any problem then log it to the console\n                .catch(error => {\n                    console.error(error);\n                    setNglStructure({ error });\n                });\n        }, [structureData])\n        return nglStructure;\n    }\n}\n  ","import { useState, useCallback } from 'react';\n\n// useToggleState is a custom hook which returns a state and a custom function to calculate the new state\nconst useToggleState = initialState => {\n  // useState is a React hook which returns a state and a function to change this state respectively\n  // The state is the initialState at the moment it is called\n  const [state, setState] = useState(!!initialState);\n  // useCallback is a React hook which returns a memoize callback\n  const toggleState = useCallback(valueOrSetter => {\n    // Set the state according to the input type\n    switch (typeof valueOrSetter) {\n      // Funtions are accepted and set as state\n      case 'function':\n        setState(valueOrSetter);\n        break;\n      // In case of booleans, numers and strings, a function that returns the opposite in boolean format is returned\n      case 'boolean':\n      case 'number':\n      case 'string':\n        setState(Boolean(valueOrSetter));\n        break;\n      // In other cases, returns a function which just change the state to the opposite of the previours state in boolean format\n      default:\n        setState(state => !state);\n    }\n  }, []);\n\n  return [state, toggleState];\n};\n\nexport default useToggleState;\n"],"names":["WAIT_DELAY","_ref","wait","flag","toggleFlag","useToggleState","useLayoutEffect","timer","setTimeout","clearTimeout","_jsx","title","className","cn","style","children","CircularProgress","variant","color","size","thickness","blank","loading","payload","error","DEFAULT_CACHE_EXPIRATION","cache","loadCache","cachedData","localStorage","getItem","JSON","parse","url","cacheOptions","arguments","length","undefined","name","cacheOn","cacheExpiration","initialData","responseData","Date","now","received","getTime","data","setData","useState","useEffect","source","axios","didCancel","cancelToken","token","startTime","then","response","endTime","responseTime","config","time","setItem","stringify","saveCache","catch","cancel","PROTEIN_RESIDUE_NAME_LETTERS","DNA_RESIDUE_NAME_LETTERS","RNA_RESIDUE_NAME_LETTERS","NUCLEIC_RESIDUE_NAME_LETTERS","_objectSpread","RESIDUE_NAME_LETTERS","FATTY_RESIDUE_NAMES","Set","STEROID_RESIDUE_NAMES","STANDARD_SOLVENT_RESIDUE_NAMES","STANDARD_COUNTER_CATION_ATOM_NAMES","STANDARD_COUNTER_ANION_ATOM_NAMES","STANDARD_COUNTER_ION_ATOM_NAMES","union","topology","reps","iterchains","forEach","chain","metadataChainName","chainLabel","concat","chainResidues","residues","respresentPolymer","polymer","filter","residue","classification","cgResidues","isCg","cgResiduesIndices","map","index","rangedSelection","nglSelection","residueIndices2Ngl","push","selection","type","aaResiduesIndices","ranges","generateRanges","shortRanges","range","shortResidueIndices","reduce","ac","curr","longRanges","longResidueIndices","has","ligandResidues","ligandIds","referenceId","ligandId","currentLigandResidueIndices","lipidClasses","lipidResidues","lipidResidueIndices","opacity","ionResidues","ionResidueIndices","otherClasses","otherResidues","otherResiduesIndices","proteinReferences","some","reference","epitopes","mappedResiduesPerReference","uniprot","referenceEpitopes","epitopeResidues","Object","values","epitope","allResidues","apply","uniqueResidues","Array","from","mappedResidues","getReferenceResidueIndices","allMappedResidues","small","greyColorPlan","entropies","entropiesPerReference","logarithmicEntropies","entropy","Math","log","allEntropies","max","min","colorScale","scaleLinear","domain","customScheme","ColormakerRegistry","addScheme","params","this","atomColor","atom","residueIndex","getResidueByIndex","parseInt","referenceData","referenceNumber","hexColor","d3color","formatHex","substring","ELEMENT_COLORS","H","C","N","O","S","P","Atom","constructor","atomIndex","atomNames","label","standardLabel","atomResidueIndices","element","atomElements","elementColor","Residue","_classification","number","residueNumbers","chainIndex","residueChainIndices","chainName","chainNames","getChainByIndex","icode","residueIcodes","residueNames","letter","classificationByName","atomCount","atoms","hydrogenCount","countElement","oxygenCount","every","referenceType","referenceIndex","residueReferenceIndices","references","referenceTypes","residueReferenceNumbers","find","ref","console","ligandReferences","pubchem","inchikeyReferences","inchikey","Error","referenceName","forcedLigandName","metadataLigandNames","isPbc","pbcResidues","iteratoms","labelChain","labelNumber","labelIcode","atomIndices","residueAtomIndices","hasCAlpha","Chain","metadataChainNames","isArray","residueIndices","chainResidueIndices","chainResidueNumbers","sequence","sequences","iterresidues","Topology","metadata","_this","getAtomByIndex","count","residueCount","getResidueByParameters","getChainByName","icode_message","indexOf","residue2atomIndices","atom2residueIndices","unique","sort","a","b","refIndex","residueNumber","includes","rangedSelections","parsedResidues","r","v","i","ranged","smallChain","parsedSelectionRanger","join","atomIndices2Ngl","byChains","residuesIndices","chained","current","getAtomElementColors","atom_names","atom_elements","atomCharges","atom_charges","atom_residue_indices","residue_names","residue_numbers","icodes","residue_icodes","fill","entries","residue_chain_indices","chain_names","reference_types","residue_reference_indices","residue_reference_numbers","atomBonds","atom_bonds","bonds","pbc_residues","CHAINNAMES","LIGANDNAMES","proteins","ligands","chainReferences","chains","inchikeys","chainReference","chain_indices","_defaultRepresentations","_epitopeRepresentations","_mutationRepresentations","chainCount","defaultRepresentations","getDefaultRepresentations","epitopesRepresentations","getEpitopesRepresentations","mutationsRepresentations","getMutationsRepresentations","Project","projectPayload","_apiEndpoints","structure","interactions","fileDescriptors","populations","_apiQuery","fieldname","available","_apiBaseUrl","_apiResponses","query","useAPI","key","value","mdFrames","SNAPSHOTS","timeLength","FRAMESTEP","mdCount","mds","md","slice","accessionOrId","accession","identifier","accessionAndMdNumber","mdNumber","hasInteractions","analyses","isPopulated","Boolean","files","filename","directions","overview","trajectory","genericAnalyses","analysis","LIGANDS","HOST_CONFIG","flags","anyReferenceWithEntropies","REFERENCES","REFERENCES_WITH_ENTROPIES","anyReferenceWithEpitopes","REFERENCES_WITH_EPITOPES","METHOD","file","_topologyManager","BASE_PATH_PROJECTS","creationDate","toLocaleDateString","updateDate","useMemo","interaction","atom_indices_1","residue_indices_1","atom_indices_2","residue_indices_2","interface_atom_indices_1","interface_indices_1","interface_atom_indices_2","interface_indices_2","message","ref_type","pdbReferences","topologyManagerReferences","referenceFrame","refframe","structureData","Blob","nglStructure","setNglStructure","autoLoad","defaultRepresentation","ext","prasedStructure","initialState","state","setState","toggleState","useCallback","valueOrSetter"],"sourceRoot":""}