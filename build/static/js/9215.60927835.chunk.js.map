{"version":3,"file":"static/js/9215.60927835.chunk.js","mappings":"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","sources":["utils/tooltip-position-manager/index.js","webpack://mdposit/./src/components/viewer-with-controls/representations-manager/style.module.css?be77","components/viewer-with-controls/constants.js","components/viewer-with-controls/representations-manager/index.js","utils/storage/index.js","components/molstar-viewer/molstar-parser/index.ts","webpack://mdposit/./src/components/molstar-viewer/style.module.css?3a43","components/molstar-viewer/index.js","components/ngl-viewer/payload-to-ngl-file/index.js","webpack://mdposit/./src/components/ngl-viewer/style.module.css?eaa8","components/ngl-viewer/index.js","hooks/use-viewer-data/index.js","utils/connection-level/index.js","webpack://mdposit/./src/components/viewer-with-controls/style.module.css?bc6d","components/viewer-with-controls/index.js"],"sourcesContent":["// Set the most suitable position for a tooltip\n// Use the parent element to set the limits where this tooltip may be\n// Use the tooltip element to get the suze of the tooltip\n// Use the reference position (e.g. mouse position) to place the tooltip\n// The offset is the pixels of separation between the reference and the tooltip\n// The idea is that the tooltip may be over/under and left/right of the reference position\n// It depends on how close to each limit is the reference position\nexport const setTooltipPosition = (parent, tooltip, reference, offset = 0) => {\n  const limits = parent.getBoundingClientRect();\n  const size = tooltip.getBoundingClientRect();\n  let x = reference.x;\n  // If it is more at the right side\n  if (Math.abs(limits.left - x) > Math.abs(x - limits.right)) {\n    const xSize = size.right - size.left;\n    x -= offset + xSize;\n  }\n  // If it is more at the left side\n  else {\n    x += offset;\n  }\n  // After this, apply the parent offset\n  x -= limits.left;\n  let y = reference.y;\n  // If it is more at the bottom side\n  if (Math.abs(limits.top - y) > Math.abs(y - limits.bottom)) {\n    const ySize = size.bottom - size.top;\n    y -= offset + ySize;\n  }\n  // If it is more at the top side\n  else {\n    y += offset;\n  }\n  // After this, apply the parent offset\n  y -= limits.top;\n  // Return the coordinates\n  return { x, y };\n};\n","// extracted by mini-css-extract-plugin\nexport default {\"popover-slider\":\"style_popover-slider__Rg-SB\",\"tablecard\":\"style_tablecard__1tgr+\",\"nglcard\":\"style_nglcard__xuaa2\",\"paper\":\"style_paper__G3Eus\",\"info\":\"style_info__itwxP\"};","export const NGL_DRAWING_METHODS = [\n  {\n    label: 'Cartoon',\n    value: 'cartoon',\n  },\n  {\n    label: 'Licorice',\n    value: 'licorice',\n  },\n  {\n    label: 'Ball and stick',\n    value: 'ball+stick',\n  },\n  {\n    label: 'Surface',\n    value: 'surface',\n  },\n  {\n    label: 'Spacefill',\n    value: 'spacefill',\n  },\n  {\n    label: 'Tube',\n    value: 'tube',\n  },\n  {\n    label: 'Trace',\n    value: 'trace',\n  },\n  {\n    label: 'Backbone',\n    value: 'backbone',\n  },\n  {\n    label: 'Nucleic bases',\n    value: 'base',\n  },\n];\n\nexport const NGL_COLORING_METHODS = [\n  {\n    label: 'By chain id',\n    value: 'chainid',\n  },\n  {\n    label: 'By residue',\n    value: 'resname',\n  },\n  {\n    label: 'By element',\n    value: 'element',\n  },\n  {\n    label: 'B factor',\n    value: 'bfactor',\n  },\n  {\n    label: 'Electrostatic',\n    value: 'electrostatic',\n  },\n  {\n    label: 'Secondary structure',\n    value: 'sstruc',\n  },\n  {\n    label: 'Uniform',\n    value: 'uniform',\n  },\n];\n\nexport const NGL_COLORS = [\n  'red',\n  'yellow',\n  'blue',\n  'green',\n  'orange',\n  'purple',\n  'white',\n  'grey',\n  'black',\n];\n","import React, { memo } from 'react';\n\nimport {\n  Chip,\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableRow,\n  TextField,\n  Select,\n  Slider,\n  IconButton,\n} from '@mui/material';\nimport {\n  faEye,\n  faEyeSlash,\n  faPlusCircle,\n} from '@fortawesome/free-solid-svg-icons';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport Info from '../../info';\nimport style from './style.module.css';\nimport {\n  NGL_DRAWING_METHODS,\n  NGL_COLORING_METHODS,\n  NGL_COLORS\n} from '../constants';\n\n// Check if a value exists inside the available values\nconst DrawingMethodExists = value => {\n  for (const opt of NGL_DRAWING_METHODS) {\n    if (opt.value === value) return true;\n  }\n  return false;\n};\n\n// Return a word but with the first letter in upper case\nconst firstLetterUpper = word => word[0].toUpperCase() + word.slice(1);\n\n// Display a huge panel to select which representations must be shown or hidden\n// In addition the user can manage the way these representatios are shown\nconst RepresentationsManager = memo(\n  ({\n    components, // Array with all components\n    representations, // Array with all representations\n    setRepresentations, // Representations setter\n  }) => {\n    return (\n      <>\n        <Table\n          aria-label=\"simple table\"\n          size=\"small\"\n          padding=\"checkbox\"\n          stickyHeader\n        >\n          <TableHead>\n            <TableRow>\n              <TableCell>Name</TableCell>\n              <TableCell align=\"right\">Show</TableCell>\n              <TableCell style={{ whiteSpace: 'nowrap' }} align=\"right\">\n                Selection <Info     tooltip={\n                <>\n                  Using{' '}\n                  <a href=\"https://nglviewer.org/ngl/api/manual/selection-language.html\" \n                    target=\"_blank\" \n                    rel=\"noopener noreferrer\">\n                    NGL selection language\n                  </a>.\n                </>\n              }  className={style.info} />\n              </TableCell>\n              <TableCell align=\"right\">Drawing method</TableCell>\n              <TableCell align=\"right\">Coloring method</TableCell>\n              <TableCell align=\"right\">Opacity</TableCell>\n            </TableRow>\n          </TableHead>\n          <TableBody>\n            {representations && representations.map((representation, index) => (\n              <TableRow key={representation.reference || index}>\n                {/* Name */}\n                <TableCell component=\"th\" scope=\"row\">\n                  {representation.name}\n                </TableCell>\n                {/* Show */}\n                <TableCell align=\"right\">\n                  <IconButton\n                    title=\"Show/Hide representation\"\n                    onClick={() =>\n                      setRepresentations(previousRepresentations => {\n                        previousRepresentations[index].show = !previousRepresentations[index].show;\n                        return [...previousRepresentations];\n                      })\n                    }\n                    color={'primary'}\n                  >\n                    <FontAwesomeIcon\n                      icon={representation.show ? faEye : faEyeSlash}\n                    />\n                  </IconButton>\n                </TableCell>\n                {/* Selection */}\n                <TableCell align=\"right\">\n                  <TextField\n                    defaultValue={representation.selection}\n                    variant=\"outlined\"\n                    onKeyPress={event => {\n                      if (event.key !== 'Enter') return;\n                      setRepresentations(previousRepresentations => {\n                        if (!event.target || !event.target.value) return previousRepresentations;\n                        previousRepresentations[index].selection = event.target.value;\n                        return [...previousRepresentations];\n                      });\n                    }}\n                    disabled={!representation.custom}\n                    size=\"small\"\n                    margin=\"dense\"\n                  />\n                </TableCell>\n                {/* Drawing method */}\n                <TableCell align=\"right\">\n                  <Select\n                    native\n                    value={representation.type}\n                    onChange={({ target: { value } }) => {\n                      setRepresentations(previousRepresentations => {\n                        previousRepresentations[index].type = value;\n                        return [...previousRepresentations];\n                      })\n                    }}\n                  >\n                    {!DrawingMethodExists(representation.type) && (\n                      <option value={representation.type}>\n                        {representation.type}\n                      </option>\n                    )}\n                    {NGL_DRAWING_METHODS.map((cm, i) => (\n                      <option key={i} value={cm.value}>\n                        {cm.label}\n                      </option>\n                    ))}\n                  </Select>\n                </TableCell>\n                {/* Coloring method */}\n                <TableCell align=\"right\">\n                  <Select\n                    native\n                    value={representation.color}\n                    onChange={({ target: { value } }) => {\n                      setRepresentations(previousRepresentations => {\n                        previousRepresentations[index].color = value;\n                        return [...previousRepresentations];\n                      })\n                    }}\n                  >\n                    {representation.customScheme === 'distorsion' ? (\n                      <option value={representation.color}>{'Distorsion'}</option>\n                    ) : representation.customScheme ? (\n                      <option value={'custom'}>{'Custom'}</option>\n                    ) : null}\n                    \n                    {NGL_COLORING_METHODS.map((cm, i) => (\n                      <option key={i} value={cm.value}>\n                        {cm.label}\n                      </option>\n                    ))}\n                    {NGL_COLORS.map((color, i) => (\n                      <option key={i} value={color}>\n                        {firstLetterUpper(color)}\n                      </option>\n                    ))}\n                  </Select>\n                </TableCell>\n                {/* Opacity */}\n                <TableCell align=\"right\">\n                  <Slider\n                    value={representation.opacity * 100}\n                    onChange={(_, value) => {\n                      setRepresentations(previousRepresentations => {\n                        previousRepresentations[index].opacity = value / 100;\n                        return [...previousRepresentations];\n                      })\n                    }}\n                    className={style['popover-slider']}\n                  />\n                </TableCell>\n              </TableRow>\n            ))}\n          </TableBody>\n          <TableBody>\n            <TableRow key={'addCustom'}>\n              <TableCell align=\"center\" colSpan={6}>\n                <Chip\n                  icon={<FontAwesomeIcon icon={faPlusCircle} />}\n                  label={'Add representation'}\n                  variant=\"outlined\"\n                  onClick={() =>\n                    setRepresentations(previousRepresentations => {\n                      // Set the default values for the custom representation\n                      const newRepresentation = {\n                        name: 'Custom', show: true,\n                        selection: 'None', type: 'licorice',\n                        color: 'chainid', opacity: 1,\n                        // Link the representation to the first (main) component\n                        component: components[0] && components[0].name,\n                        // Add the custom flag so this representation is treated differently\n                        custom: true,\n                      };\n                      const newRepresentations = [...previousRepresentations, newRepresentation];\n                      return newRepresentations;\n                    })\n                  }\n                />\n              </TableCell>\n            </TableRow>\n          </TableBody>\n        </Table>\n      </>\n    );\n  },\n);\n\nexport default RepresentationsManager;\n","import { schedule } from 'timing-functions';\nimport pck from '../../../package.json';\n\nconst KEY = `${pck.name}-`;\n\nconst MAX_WAIT_TIME = 1000;\n\nexport const get = (key, defaultValue) => {\n  const storedValue = localStorage.getItem(KEY + key);\n  if (storedValue === null) return defaultValue;\n  return JSON.parse(storedValue);\n};\n\nexport const set = (key, value) => {\n  localStorage.setItem(KEY + key, JSON.stringify(value));\n};\n\nexport const setAsync = async (key, value) => {\n  await schedule(MAX_WAIT_TIME);\n  return set(key, value);\n};\n\nexport const deleteAll = () => {\n  Object.keys(localStorage)\n    .filter(key => key.startsWith(KEY))\n    .forEach(key => localStorage.removeItem(key));\n};\n","import { StateTransformer } from 'molstar/lib/mol-state';\nimport { PluginStateObject } from 'molstar/lib/mol-plugin-state/objects';\nimport { Task } from 'molstar/lib/mol-task';\nimport { ParamDefinition as PD } from 'molstar/lib/mol-util/param-definition';\nimport { Coordinates, Time } from 'molstar/lib/mol-model/structure';\n\nconst CreateTransformer = StateTransformer.builderFactory('custom-namespace');\n\nexport const TrajectoryFromCustomData = CreateTransformer({\n    name: 'trajectory-from-custom-data',\n    display: 'Trajectory',\n    from: PluginStateObject.Root,\n    to: PluginStateObject.Molecule.Coordinates,\n    params: {\n        data: PD.Value<Uint8Array>(new Uint8Array(), { isHidden: true }),\n        natoms: PD.Value<number>(0, { isHidden: true }),\n    },\n})({\n    apply({ params }) {\n        return Task.create('Parse atom coordinates', async (ctx) => {\n            //ctx.update({ canAbort: true, message: 'Parsing trajectory...' });\n            return await customParse(params.data, params.natoms);\n        });\n    },\n});\n\n// Parse binary atom coordinates\nasync function customParse (data: Uint8Array, natoms: number) {\n    // Check the number of atoms to not be 0 (the default)\n    if (natoms === 0) throw new Error('Number of atoms is 0');\n    // Each coordinates is a float32 an thus it takes 4 bytes of space\n    const coordSize = 4;\n    // Each atom has 3 coordinates: x, y and z\n    const atomSize = coordSize * 3;\n    // Each frame has coordinates for every atom\n    const frameSize = atomSize * natoms;\n    // Check data contains whole frames\n    if (data.byteLength % frameSize !== 0) throw new Error('Trajectory data ends abruptly');\n    // Calculate the number of frames\n    const nframes = data.byteLength / frameSize;\n    // Convert binary data to coordinates\n    const coordinates = new Float32Array(data);\n    // Set a list with the already read coordinates\n    const frameCoordinates = [];\n    // Keep track of the coordinate we are reading\n    let count = 0;\n    // Iterate over each frame number\n    for (let frame = 0; frame < nframes; frame++) {\n        // Coordinates are saved separately by dimensions, as it is done in molstar\n        const x_coords = new Float32Array(natoms);\n        const y_coords = new Float32Array(natoms);\n        const z_coords = new Float32Array(natoms);\n        // Iterate over each atom number\n        for (let atom = 0; atom < natoms; atom++) {\n            // Read the current atom coordinates\n            x_coords[atom] = coordinates[count]\n            y_coords[atom] = coordinates[count+1];\n            z_coords[atom] = coordinates[count+2];\n            // Update the byte offset\n            count += 3;\n        }\n        // Push the current frame to the overall frames list\n        frameCoordinates.push({\n            x: x_coords,\n            y: y_coords,\n            z: z_coords,\n            // Add a few extra parameters on each frame\n            elementCount: natoms,\n            time: Time(frame, 'step'),\n            xyzOrdering: { isIdentity: true }\n        });\n    }\n    // Set the molstar object for coordinates\n    const molstarCoords = Coordinates.create(\n        frameCoordinates,\n        Time(1, 'step'), // deltaTime\n        Time(0, 'step') // offsetTime\n    );\n    return new PluginStateObject.Molecule.Coordinates(molstarCoords, { label: 'label' });\n}","// extracted by mini-css-extract-plugin\nexport default {\"container\":\"style_container__d6R8E\",\"light-theme\":\"style_light-theme__l3EaT\",\"loading-trajectory\":\"style_loading-trajectory__ciokb\",\"loading-structure\":\"style_loading-structure__ce+kY\",\"tooltip\":\"style_tooltip__KXFgY\"};","import React, {\n  forwardRef,\n  memo,\n  useState,\n  useRef,\n  useImperativeHandle,\n  useCallback,\n  useMemo,\n  useEffect,\n  useContext,\n} from 'react';\n//import useToggleState from '../../hooks/use-toggle-state';\nimport { useInView } from 'react-intersection-observer';\nimport cn from 'classnames';\n\n// Load molstar logic\n//import { PluginUIContext } from \"molstar/lib/mol-plugin-ui/context\";\nimport { createPluginUI } from 'molstar/lib/mol-plugin-ui/index';\nimport { DefaultPluginUISpec } from 'molstar/lib/mol-plugin-ui/spec';\nimport { TrajectoryFromModelAndCoordinates } from 'molstar/lib/mol-plugin-state/transforms/model';\nimport { AnimateModelIndex } from 'molstar/lib/mol-plugin-state/animation/built-in/model-index';\nimport { createStructureRepresentationParams } from 'molstar/lib/mol-plugin-state/helpers/structure-representation-params';\nimport { StateTransforms } from 'molstar/lib/mol-plugin-state/transforms';\n/*  Might require extra configuration,\nsee https://webpack.js.org/loaders/sass-loader/ for example.\ncreate-react-app should support this natively. */\n//import \"molstar/lib/mol-plugin-ui/skin/light.scss\";\n\n// Load the parser for trajectory coordinates in our format to molstar format\nimport { TrajectoryFromCustomData } from './molstar-parser';\n\nimport { ProjectCtx } from '../../contexts';\n\n//import { setTooltipPosition } from '../../utils/tooltip-position-manager';\n\nimport style from './style.module.css';\n\n// Used to just wait\nimport { sleep } from 'timing-functions';\n\n// Load the molstar plugin context in a global and accessible place\n//window.molstar = PluginUIContext;\n\n// Customize molstar specifications\n// Here you can see more clues about molstar options:\n//   https://github.com/molstar/molstar/blob/0bf32148afd93a645b44dca6d81e9779e85b4300/src/apps/viewer/app.ts\nconst molstarSpec = DefaultPluginUISpec();\nmolstarSpec.layout = {\n  initial: {\n    // When isExpanded is set true the vertical scroll is blocked\n    isExpanded: false,\n    // DANI: Esto no se que hace, he provado distintos valores y no veo la diferencia\n    // Available options: 'outside', 'portrait', 'landscape' or 'reactive'\n    controlsDisplay: 'reactive',\n    // If showControls is set to true then some logs are rendered in molstar\n    // This is a problem since they offset the molecule and they eclipse the mouse interaction with it\n    // These controls can be hidden by parts firther in the specifications however\n    showControls: false,\n  },\n};\nmolstarSpec.components = {\n  // This is only useful if showControls are set to true\n  controls: {\n    // Hide sequence (question mark in the top right corner)\n    // DANI: Al hacer click no hace nada\n    top: 'none',\n    // Hide console logs (they block the mouse click interaction with the main viewer)\n    bottom: 'none',\n    // Hide left panel (this panels is offsetting and deforming the main viewer very bad)\n    // DANI: Hay un botn pero funciona mal: intenta abrir un desplegable con ms botones pero colapsa al momento\n    left: 'none',\n    // DANI: No se que hace esto pero he visto que alguien lo pona as que yo tambin\n    remoteState: 'none',\n  },\n};\n\n// Set the number of bytes per element in trajectory data\nconst BYTES_PER_COORDINATE = 4; // float 32\nconst COORDINATES_PER_ATOM = 3; // x, y and z\nconst BYTES_PER_ATOM = BYTES_PER_COORDINATE * COORDINATES_PER_ATOM;\n\n// Set the viewer player speed limits\n// The actual 'speed' input limits are 0-100\n// The speed set as the time to wait before moving to the next frame in miliseconds\nconst minimumSpeed = 0;\nconst maximumSpeed = 100;\nconst slowestTimeout = 1000;\nconst fastestTimeout = 50;\nconst interpolateSpeed = currentSpeed => (\n  slowestTimeout + (currentSpeed - minimumSpeed) *\n  ((fastestTimeout - slowestTimeout) / (maximumSpeed - minimumSpeed))\n);\n\n// Set representation types for the different types of highlights\nconst defaultHighlightTypes = {\n  atoms: 'spacefill',\n  residues: 'ball+stick',\n  chains: 'ball+stick',\n  selections: 'ball+stick',\n};\n\nconst MolstarViewer = memo(\n  forwardRef(\n    (\n      {\n        className,\n        playing,\n        spinning,\n        smooth,\n        onProgress,\n        bounce = false, // Set if the animation, when finished, starts again (false) or goes back (true)\n        selectedAtoms, // Atom index of the atom and residue to be represented\n        selectedResidueIndices, // Residue indices from residues to be highlighted\n        selectedChains, // Chain letters from chains to be represented\n        selectedCustom, // Free NGL selections to be directly represented\n        selectedDistances, // Groups of 2 atoms or residues to be represented as a distance\n        selectedAngles, // Groups of 3 atoms to be represented as an angle\n        selectedRepresentation, // String name of a representation to be painted in yellow color (only 1)\n        snapRepresentations,\n        noTrajectory, // True when only specific frames must be loaded\n        initialFocus, // The viewer selection to be focused by the camera initially\n        darkBackground,\n        perspective,\n        speed,\n        // Hooked values for changing representation parameters\n        drawingMethods,\n        coloringMethods,\n        opacities,\n        components,\n        showRepresentations,\n        nglSelections,\n        // Viewer data incluting both structure and coordinates\n        topologies,\n        trajectories,\n        anyLoadingTopology,\n        anyLoadingTrajectory,\n        // Set the highlight representations types\n        highlightTypes = defaultHighlightTypes,\n      },\n      ref,\n    ) => {\n      // Save the components object into a local constant which can be modified\n      const comps = useMemo(() => components, [components]);\n\n      // Get project data\n      const {\n        metadata,\n        topology: topologyManager,\n      } = useContext(ProjectCtx);\n\n      // The last automatic camera focus\n      const [focus, setFocus] = useState(initialFocus);\n      // Set the initial focus\n      useEffect(() => {\n        //console.log(initialFocus);\n        setFocus(initialFocus);\n      }, [initialFocus]);\n\n      // references\n      const parentRef = useRef(null);\n      const containerRef = useRef(null);\n      const stageRef = useRef(null);\n      const tooltipRef = useRef(null);\n\n      // in-view hook\n      const [inViewRef, isInView] = useInView();\n\n      // Set the content of the tooltip in JSX format\n      const [tooltipContent, setTooltipContent] = useState(null);\n\n      // Set the molstar instance\n      const [molstar, setMolstar] = useState(null);\n\n      // Setup molstar\n      useEffect(() => {\n        // This wrapper function is the most correct way to call awaits inside a use effect\n        const wrap = async () => {\n          // Create the plugin\n          const molstarInstance = await createPluginUI(\n            parentRef.current,\n            molstarSpec,\n          );\n          setMolstar(molstarInstance);\n        };\n        wrap();\n        // Cleanup function\n        return () => {\n          if (!molstar) return;\n          molstar.dispose();\n          molstar = null;\n        };\n      }, []);\n\n      // Set the molstar model reference\n      const [modelReference, setModelReference] = useState(null);\n\n      // Load topologies in molstar\n      useEffect(() => {\n        // Stop here if we are still loading topologies\n        if (anyLoadingTopology) return;\n        // Get the molstar reference\n        if (!molstar) return;\n        // Load each topology\n        topologies.forEach(async topology => {\n          // Download and apply data\n          const data = await molstar.builders.data.rawData(\n            { data: topology.file } /* replace with your URL */,\n            { state: { isGhost: true } },\n          );\n          // DANI: Aunque no llegues a 'aplicarla' acabas teniendo una trayectoria de una frame en la data\n          const trajectory = await molstar.builders.structure.parseTrajectory(data, 'pdb');\n          // WARNING: Do not modify this model\n          // WARNING: Althought it should be the same model\n          const model = await molstar.builders.structure.createModel(trajectory);\n\n          // DANI: Esta funcin te acepta igual una trayectory que un model que una structure\n          // await molstar.builders.structure.hierarchy.applyPreset(structure, \"default\");\n\n          // console.log(molstar);\n          // console.log(molstar.managers.structure.hierarchy.current);\n\n          // // Set the representations (https://github.com/molstar/molstar/issues/68)\n          // // WARNING: Default MolStar representation is not the most efficient one so we have to tweak it\n          // // First set the different features we may encounter within the structure\n          // const components = {\n          //     polymer: await molstar.builders.structure.tryCreateComponent(structure, 'polymer'),\n          //     ligand: await molstar.builders.structure.tryCreateComponent(structure, 'ligand'),\n          //     //water: await molstar.builders.structure.tryCreateComponent(structure, 'water'),\n          // };\n          // // Now\n          // const builder = molstar.builders.structure.representation;\n          // const update = molstar.build();\n          // if (components.polymer) builder.buildRepresentation(update, components.polymer, {\n          //   type: 'line',\n          //   //typeParams: { alpha: 0.51 } // Make it transparent\n          // }, { tag: 'polymer' });\n          // if (components.ligand) builder.buildRepresentation(update, components.ligand, {\n          //   type: 'ball-and-stick'\n          // }, { tag: 'ligand' });\n          // //if (components.water) builder.buildRepresentation(update, components.water, { type: 'ball-and-stick', typeParams: { alpha: 0.6 } }, { tag: 'water' });\n          // await update.commit();\n\n          // Save the model reference inside the molstar reference\n          setModelReference(model.ref);\n        });\n      }, [molstar, anyLoadingTopology, topologies]);\n\n      // Load trajectories in molstar\n      // Once the trajectories are downloaded, load them in corresponding viewer representations\n      // Every time the trajectory payloads change this useEffect must be rerun\n      useEffect(() => {\n        // Wait for the molstar reference to be available\n        if (!molstar) return;\n        // If there must be no trajectory then stop here\n        if (noTrajectory) return;\n        // This wrapper function is the most correct way to call awaits inside a use effect\n        const wrap = async () => {\n          // Check if trajectories are\n          if (!topologies || !trajectories || trajectories.length === 0) return;\n\n          // If molstar or the main model are not set yet then we must wait\n          if (!modelReference) return;\n\n          const trajectory = trajectories[0];\n\n          let trajectoryAtoms;\n          let trajectoryFinalExpectedFrames = 0;\n\n          trajectoryAtoms = trajectory.atoms;\n          if (trajectoryAtoms !== trajectory.atoms)\n            throw new Error(\n              `Atoms number in the different trajectories do not match`,\n            );\n\n          // Add the final expected frames for all frames in the component\n          trajectoryFinalExpectedFrames += trajectory.frames;\n\n          const payload = trajectory.payload;\n          const bytesPerFrame = trajectoryAtoms * BYTES_PER_ATOM;\n          const fitLength =\n            Math.floor(payload.byteLength / bytesPerFrame) * bytesPerFrame;\n          const totalPayload = payload.slice(0, fitLength);\n\n          // If the total payload is empty then stop here\n          if (totalPayload.byteLength === 0) return;\n\n          // Calculate how many frames are there in total\n          const totalFrames = totalPayload.byteLength / bytesPerFrame;\n          const lastFrameIndex = totalFrames - 1;\n\n          // Check if all required data is already downloaded\n          const completedTrajectory =\n            totalFrames === trajectoryFinalExpectedFrames;\n          if (!completedTrajectory) return;\n\n          // Load coordinates as they are parsed\n          const coords = await molstar\n            .build()\n            .toRoot()\n            .apply(TrajectoryFromCustomData, {\n              data: totalPayload,\n              natoms: trajectory.atoms,\n            })\n            .commit();\n\n          // Get the current loaded trajectories\n          // DANI: No te fies de este nmero\n          // DANI: Aqu aparecen todas las trayectorias declaradas, incluido aquellas que no han sido 'aplicadas'\n          const loadedTrajectories =\n            molstar.managers.structure.hierarchy.current.trajectories;\n\n          const molstarTrajectory = await molstar\n            .build()\n            .toRoot()\n            .apply(\n              TrajectoryFromModelAndCoordinates,\n              {\n                modelRef: modelReference,\n                coordinatesRef: coords.ref,\n              },\n              { dependsOn: [modelReference, coords.ref] },\n            )\n            .commit();\n\n          // Get the current trajectory model\n          // From now on, this is the model to be modified and not the model in modelReference\n          const newModel = await molstar.builders.structure.createModel(\n            molstarTrajectory,\n          );\n\n          // Set the default representation\n          // Use a lightweighted representation type\n          const structure = await molstar.builders.structure.createStructure(\n            newModel,\n          );\n          const components = molstar.build().to(structure);\n          const lightRepresentation = createStructureRepresentationParams(\n            molstar,\n            void 0,\n            {\n              type: 'cartoon',\n              typeParams: {\n                // Quality options: custom, auto, highest, higher, high, medium, low, lower, lowest\n                // https://github.com/molstar/molstar/blob/0e197b18857d59c27f51d4aa0226cd772bc872ca/src/mol-geo/geometry/base.ts\n                // DANI: 'lowest' se ve muy feo y no mejora mucho el rendimiento\n                quality: 'lower',\n                ignoreHydrogens: 'all',\n                ignoreHydrogensVariant: 'all',\n                ignoreLight: true,\n              },\n            },\n          );\n\n          components.apply(\n            StateTransforms.Representation.StructureRepresentation3D,\n            lightRepresentation,\n          );\n          await components.commit();\n\n          // DANI: Hay 2 presets: 'default' y 'all-models'. Aparecen siempre, aunque tu no los hayas creado\n          //const currentPresets = molstar.builders.structure.hierarchy.getPresetsWithOptions(molstarTrajectory);\n          //console.log(currentPresets);\n\n          // DANI: El apply preset puede hacerse a 'default' o a 'all-models'\n          // DANI: El 'all-models' te representa todas las frames superpuestas (y tarda)\n          // await molstar.builders.structure.hierarchy.applyPreset(\n          //   molstarTrajectory,\n          //   'default',\n          // );\n\n          // If there is a trajectory already update it with new data\n          if (loadedTrajectories.length > 0) {\n            //if (loadedTrajectories.length > 1) throw new Error('Molstar error: There should be only 1 trajectory');\n            //console.log('already loaded traj!!');\n          }\n          // If there is not trajectory yet then create a new trajectory\n          else {\n            //console.log('loading for the first time');\n          }\n        };\n        wrap();\n      }, [molstar, modelReference, topologies, trajectories, comps, noTrajectory]);\n\n      // play/pause button effect\n      useEffect(() => {\n        // If molstar has not been yet initiated then stop here\n        if (!molstar) return;\n\n        // If there is no trajectory then there is nothing to play\n        if (noTrajectory) return;\n\n        // Play\n        if (playing && isInView) {\n          molstar.managers.animation.play(AnimateModelIndex, {\n            // Select the time it takes to switch between frames\n            //duration: { name: 'fixed', params: { durationInS: 10 } },\n            //duration: { name: 'computed', params: { targetFps: 10 } },\n            duration: { name: 'sequential', params: { maxFps: 10 } },\n            // Select the mode it switches frames\n            //mode: { name: 'once', params: { direction: 'forward' } }\n            mode: { name: 'loop', params: { direction: 'forward' } },\n            //mode: { name: 'palindrome', params: {} }\n          });\n        }\n        // Pause\n        else {\n          molstar.managers.animation.stop();\n        }\n      }, [molstar, playing, isInView, noTrajectory, bounce]);\n\n      // Resize logic\n      // declare handler\n      const handleResize = useCallback(async () => {\n        if (!stageRef.current) return;\n        const canvas = containerRef.current.querySelector('canvas');\n        if (canvas) {\n          canvas.style.height = '';\n          canvas.style.cursor = 'default';\n        }\n        // WARNING: This sleep here is to fix a bug\n        // When we open/close settings we trigger this function but it takes the size of the window before changing\n        // The sleep fixes this problem altought the delay is 0\n        await sleep(0);\n        stageRef.current.handleResize();\n      }, []);\n      // connect the handle to events\n      useEffect(() => {\n        window.addEventListener('resize', handleResize);\n        return () => {\n          window.removeEventListener('resize', handleResize);\n        };\n      }, [handleResize]);\n\n      // Expose public methods and getters/setters\n      useImperativeHandle(\n        ref,\n        () => ({\n          autoResize: handleResize,\n          // Output the current orientation/focus in console\n          // Note: this is for the developer, not for the regular user\n          displayFocus() {\n            const orientation = stageRef.current.viewerControls.getOrientation();\n            const stringifiedArray = `[${orientation.elements.toString()}]`;\n            console.log(stringifiedArray);\n          },\n          centerFocus() {\n            setFocus({ comp: 0, sele: 'all' });\n            // Use the provided orientation, if any\n            // DANI: Sin hacer\n          },\n          get currentFrame() {\n            if (!(molstar && trajectories.length)) return -1;\n            try {\n              return stageRef.current.compList[0].trajList[0].trajectory\n                .currentFrame;\n            } catch (_) {\n              return -1;\n            }\n          },\n          set currentFrame(value) {\n            if (!(molstar && trajectories.length)) return;\n            try {\n              const total = this.totalFrames;\n              let frame = value;\n              if (frame < 0) frame = 0;\n              if (frame >= total) frame = total - 1;\n              stageRef.current.compList[0].trajList[0].trajectory.setFrame(\n                frame,\n              );\n            } catch (_) {\n              /* */\n            }\n          },\n          get totalFrames() {\n            if (!(molstar && trajectories.length)) return 1;\n            try {\n              return stageRef.current.compList[0].trajList[0].trajectory.frames\n                .length;\n            } catch (_) {\n              return 1;\n            }\n          },\n          get totalExpectedFrames() {\n            try {\n              return stageRef.current.compList[0].trajList[0].expectedFrames;\n            } catch (_) {\n              return 1;\n            }\n          },\n        }),\n        [molstar, trajectories, handleResize],\n      );\n\n      // workaround to have multiple ref logic on one element\n      // https://github.com/thebuilder/react-intersection-observer/issues/186#issuecomment-468641525\n      const handleRef = node => {\n        inViewRef(node);\n        parentRef.current = node;\n      };\n\n      // Finally, render the viewer window\n      return (\n        <>\n          <div\n            ref={handleRef}\n            className={cn(className, style.container, {\n              [style['loading-structure']]: anyLoadingTopology,\n              [style['loading-trajectory']]:\n                !noTrajectory && anyLoadingTrajectory,\n              [style['light-theme']]: !darkBackground,\n            })}\n            // Display loading status data in the upper left corner of the viewer window\n            data-loading={undefined}\n          />\n          <div ref={tooltipRef} className={style.tooltip}>\n            {tooltipContent}\n          </div>\n        </>\n      );\n    },\n  ),\n);\n\nexport default MolstarViewer;\n","import { Frames } from 'ngl';\n\n// Set the number of bytes per element in trajectory data\nconst BYTES_PER_COORDINATE = 4; // float 32\nconst COORDINATES_PER_ATOM = 3; // x, y and z\nconst BYTES_PER_ATOM = BYTES_PER_COORDINATE * COORDINATES_PER_ATOM;\n\n// This converts the trajectory payload (i.e. atom coordinates in raw binary data) into NGL formatted coordinates\nconst payloadToNGLCoordinates = (\n  trajectoryData,\n  trajectoryAtoms,\n  trajectoryFrames,\n) => {\n  // Parse binary to coordinates\n  const trajectoryCoordinates = new Float32Array(trajectoryData);\n  try {\n    // Save all coordinates here\n    // This array is to be returned at the end\n    const overallCoordinates = [];\n    for (let i = 0; i < trajectoryFrames; i++) {\n      // Create a new array with the length of the number of atoms in the pdbFile * 3\n      const coordinates = new Float32Array(\n        trajectoryAtoms * COORDINATES_PER_ATOM,\n      );\n      coordinates.set(\n        trajectoryCoordinates.subarray(\n          i * trajectoryAtoms * COORDINATES_PER_ATOM,\n          (i + 1) * trajectoryAtoms * COORDINATES_PER_ATOM,\n        ),\n      );\n      // Push the new coordinates each frame\n      overallCoordinates.push(coordinates);\n    }\n    return overallCoordinates;\n  } catch (error) {\n    // If this fails the topology may not match the trajectory in atom number\n    return null;\n  }\n};\n\n// This converts the trajectory payload (i.e. atom coordinates in raw binary data) into NGL formatted coordinates\n// This alternative function is used when the trajectory has less atoms than the structure\n// This may happen when trajectory data contains only heavy or backbone atoms (e.g. pca projections)\nconst payloadToNGLCoordinatesFiltered = (\n  atomCount,\n  atomIndices,\n  trajectoryData,\n  trajectoryAtoms,\n  trajectoryFrames,\n) => {\n  // Parse binary to coordinates\n  const trajectoryCoordinates = new Float32Array(trajectoryData);\n  // Check atom number to be as expected\n  const expectedAtomNumber =\n    trajectoryCoordinates.length / COORDINATES_PER_ATOM / trajectoryFrames;\n  if (expectedAtomNumber !== trajectoryAtoms) {\n    console.log('Number of coordinates: ' + trajectoryCoordinates.length);\n    console.log('Number of frames: ' + trajectoryFrames);\n    console.log('Expected number of atoms: ' + expectedAtomNumber);\n    console.log('Actual number of atoms: ' + trajectoryAtoms);\n    throw new Error(`Trajectory atom number is wrong`);\n  }\n\n  try {\n    // Save all coordinates here\n    // This array is to be returned at the end\n    const overallCoordinates = [];\n    for (let i = 0; i < trajectoryFrames; i++) {\n      // Create a new array with the length of the number of atoms in the structure * 3\n      const coordinates = new Float32Array(atomCount * COORDINATES_PER_ATOM);\n      let k = 0;\n      // Create our own trajectory with coordinates only for the specified atoms\n      // The coordinates of the excluded atoms are set to 0\n      // This makes the trajectory compatible with the structure\n      for (let j = 0; j < atomCount; j++) {\n        //if (k >= trajectoryAtoms) break;\n        if (atomIndices.indexOf(j) !== -1) {\n          coordinates[j * COORDINATES_PER_ATOM] =\n            trajectoryCoordinates[\n              i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                k * COORDINATES_PER_ATOM\n            ];\n          coordinates[j * COORDINATES_PER_ATOM + 1] =\n            trajectoryCoordinates[\n              i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                k * COORDINATES_PER_ATOM +\n                1\n            ];\n          coordinates[j * COORDINATES_PER_ATOM + 2] =\n            trajectoryCoordinates[\n              i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                k * COORDINATES_PER_ATOM +\n                2\n            ];\n          k++;\n        }\n      }\n      // Push the new coordinates each frame\n      overallCoordinates.push(coordinates);\n    }\n    return overallCoordinates;\n  } catch (e) {\n    // If this fails the topology may not match the trajectory in atom number\n    return null;\n  }\n};\n\n// This converts the trajectory payload (i.e. atom coordinates in raw binary data) into NGL formatted coordinates\n// This alternative function is used when the trajectory has less atoms than the structure\n// This may happen when trajectory data contains only heavy or backbone atoms (e.g. pca projections)\nconst payloadToNGLCoordinatesAlternative = (\n  pdbFile,\n  trajectoryData,\n  trajectoryAtoms,\n  trajectoryFrames,\n) => {\n  // Parse binary to coordinates\n  const trajectoryCoordinates = new Float32Array(trajectoryData);\n  // Check atom number to be as expected\n  if (\n    trajectoryCoordinates.length / COORDINATES_PER_ATOM / trajectoryFrames !==\n    trajectoryAtoms\n  )\n    throw new Error(`Trajectory atom number is wrong`);\n\n  let format = '';\n\n  // Then count different combinations of atoms in the pdbFile\n  let k = 0;\n  let backboneAtoms = 0;\n  let heavyAtoms = 0;\n  for (let a = 0; a < pdbFile.atomCount; a++) {\n    // DANI: He probado a quitar esta condicin. hay que probar que funcione bien en la vieja model\n    // DANI: En las trayectorias del Shaw el 'isProtein' no funcionaba y devolva siempre 'false'\n    //if (!pdbFile.getAtomProxy(a).isProtein()) break;\n    if (k >= trajectoryAtoms) break;\n    if (\n      pdbFile.getAtomProxy(a).atomname === 'C' ||\n      pdbFile.getAtomProxy(a).atomname === 'CA' ||\n      pdbFile.getAtomProxy(a).atomname === 'N'\n    ) {\n      backboneAtoms += 1;\n    }\n    if (pdbFile.getAtomProxy(a).element !== 'H') {\n      heavyAtoms += 1;\n    }\n  }\n  // Finally check which count matches the expected number of atoms\n  if (trajectoryAtoms === backboneAtoms) format = 'backbone';\n  else if (trajectoryAtoms === heavyAtoms) format = 'heavy';\n  else\n    console.error(\n      `Number of atoms does not match any defined atoms selection\n      Number of atoms in trajectory: ${trajectoryAtoms}\n      Expected backbone atoms: ${backboneAtoms}\n      Expected heavy atoms: ${heavyAtoms}`,\n    );\n  try {\n    // Save all coordinates here\n    // This array is to be returned at the end\n    const overallCoordinates = [];\n    for (let i = 0; i < trajectoryFrames; i++) {\n      // Create a new array with the length of the number of atoms in the pdbFile * 3\n      const coordinates = new Float32Array(\n        pdbFile.atomCount * COORDINATES_PER_ATOM,\n      );\n      let k = 0;\n      // Create our own trajectory with coordinates only for the specified atoms\n      // The coordinates of the excluded atoms are set to 0\n      // This makes the trajectory compatible with the pdbFile\n      if (format === 'backbone') {\n        for (let j = 0; j < pdbFile.atomCount; j++) {\n          if (k >= trajectoryAtoms) break;\n          if (\n            pdbFile.getAtomProxy(j).atomname === 'C' ||\n            pdbFile.getAtomProxy(j).atomname === 'CA' ||\n            pdbFile.getAtomProxy(j).atomname === 'N'\n          ) {\n            coordinates[j * COORDINATES_PER_ATOM] =\n              trajectoryCoordinates[\n                i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                  k * COORDINATES_PER_ATOM\n              ];\n            coordinates[j * COORDINATES_PER_ATOM + 1] =\n              trajectoryCoordinates[\n                i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                  k * COORDINATES_PER_ATOM +\n                  1\n              ];\n            coordinates[j * COORDINATES_PER_ATOM + 2] =\n              trajectoryCoordinates[\n                i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                  k * COORDINATES_PER_ATOM +\n                  2\n              ];\n            k++;\n          }\n        }\n      }\n      if (format === 'heavy') {\n        for (let j = 0; j < pdbFile.atomCount; j++) {\n          if (k >= trajectoryAtoms) break;\n          if (pdbFile.getAtomProxy(j).element !== 'H') {\n            coordinates[j * COORDINATES_PER_ATOM] =\n              trajectoryCoordinates[\n                i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                  k * COORDINATES_PER_ATOM\n              ];\n            coordinates[j * COORDINATES_PER_ATOM + 1] =\n              trajectoryCoordinates[\n                i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                  k * COORDINATES_PER_ATOM +\n                  1\n              ];\n            coordinates[j * COORDINATES_PER_ATOM + 2] =\n              trajectoryCoordinates[\n                i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                  k * COORDINATES_PER_ATOM +\n                  2\n              ];\n            k++;\n          }\n        }\n      }\n      // Push the new coordinates each frame\n      overallCoordinates.push(coordinates);\n    }\n    return overallCoordinates;\n  } catch (e) {\n    // If this fails the topology may not match the trajectory in atom number\n    return null;\n  }\n};\n\n// This converts the trajectory payload (i.e. atom coordinates in raw binary data) into an NGL object\n// This object can be further added to a NGL stage component\nexport const setNGLFile = (\n  topology,\n  trajectoryData,\n  trajectoryAtoms,\n  trajectoryFrames,\n  atomIndices,\n) => {\n  if (!(topology && trajectoryData)) return;\n\n  let coordinates;\n  // In case topology and trajectory atoms match go for the canonical parsing\n  if (trajectoryAtoms === topology.atomCount)\n    coordinates = payloadToNGLCoordinates(\n      trajectoryData,\n      trajectoryAtoms,\n      trajectoryFrames,\n    );\n  else if (atomIndices)\n    coordinates = payloadToNGLCoordinatesFiltered(\n      topology.atomCount,\n      atomIndices,\n      trajectoryData,\n      trajectoryAtoms,\n      trajectoryFrames,\n    );\n  // Otherwise it may mean the trajectory has only heavy/backbone atoms\n  // Then parse it taking this in count\n  // DANI: Esto es ms un arreglo que no algo permanente\n  // DANI: Lo suyo sera que en estos casos se pida la estructura solo con los tomos que hacen falta\n  else\n    coordinates = payloadToNGLCoordinatesAlternative(\n      topology,\n      trajectoryData,\n      trajectoryAtoms,\n      trajectoryFrames,\n    );\n\n  // If we do not have coordinates at this point it may mean the topology and trajectory are not matching in atom number\n  if (!coordinates)\n    throw new Error(`Topology and trajectory data may not match`);\n\n  // If coordinates are all the same then stop here\n  // Representing many atoms in the same place may stress NGL a lot for some reason\n  // This can make the whole navigator crash if tried with many atoms\n  // Check only the first 10 coordinates to make it faster\n  const sampleFrame = coordinates[0];\n  const sampleCoordinates = new Set(sampleFrame.slice(0, 30))\n  if (sampleCoordinates.size <= 3)\n    throw new Error('Trajectory coordinates are repeated');\n\n  // Finally build the NGL object and add the parsed coordinates\n  const file = new Frames('Dynamically generated trajectory', '');\n  file.coordinates = coordinates;\n  return file;\n};\n\n// This updates an already set NGL object by adding new trajectory data\nexport const updateNGLFile = (\n  file,\n  topology,\n  trajectoryData,\n  trajectoryAtoms,\n  trajectoryFrames,\n  atomIndices,\n) => {\n  if (!(file && topology && trajectoryData)) return;\n\n  // The NGL file may already have trajectory data\n  // There is no need to process those coordinates again, so they must discarded from the parsing\n\n  // Find out how many frames are already loaded\n  const currentFrames = file.frames.length;\n\n  // If there are as many frames already as the new trajectory frames then we have nothing to do\n  if (currentFrames >= trajectoryFrames) return;\n\n  // Calculate how many bytes we must discard and discard them from the begining of the array buffer\n  const discardBytes = currentFrames * trajectoryAtoms * BYTES_PER_ATOM;\n  const newTrajectoryData = trajectoryData.slice(discardBytes);\n  const newTrajectoryFrames = trajectoryFrames - currentFrames;\n\n  let coordinates;\n  // In case topology and trajectory atoms match go for the canonical parsing\n  if (trajectoryAtoms === topology.atomCount)\n    coordinates = payloadToNGLCoordinates(\n      newTrajectoryData,\n      trajectoryAtoms,\n      newTrajectoryFrames,\n    );\n  else if (atomIndices)\n    coordinates = payloadToNGLCoordinatesFiltered(\n      topology.atomCount,\n      atomIndices,\n      newTrajectoryData,\n      trajectoryAtoms,\n      newTrajectoryFrames,\n    );\n  // Otherwise it may mean the trajectory has only heavy/backbone atoms\n  // Then parse it taking this in count\n  // DANI: Esto es ms un arreglo que no algo permanente\n  // DANI: Lo suyo sera que en estos casos se pida la estructura solo con los tomos que hacen falta\n  else\n    coordinates = payloadToNGLCoordinatesAlternative(\n      topology,\n      newTrajectoryData,\n      trajectoryAtoms,\n      newTrajectoryFrames,\n    );\n\n  // If we do not have coordinates at this point it may mean the topology and trajectory are not matching in atom number\n  if (!coordinates)\n    throw new Error(`Topology and trajectory data may not match`);\n\n  // Finally update the NGL file coordinates\n  file.frames = file.frames.concat(coordinates);\n};\n","// extracted by mini-css-extract-plugin\nexport default {\"container\":\"style_container__7Ceta\",\"light-theme\":\"style_light-theme__H4DPh\",\"loading-trajectory\":\"style_loading-trajectory__2DP4d\",\"loading-structure\":\"style_loading-structure__E1dyl\",\"tooltip\":\"style_tooltip__eJTpx\"};","import React, {\n  forwardRef,\n  memo,\n  useState,\n  useRef,\n  useImperativeHandle,\n  useCallback,\n  useMemo,\n  useEffect,\n  useContext,\n} from 'react';\n// Hook to download viewer data from the API according to the components configuration\nimport { useInView } from 'react-intersection-observer';\nimport { clamp } from 'lodash-es';\nimport cn from 'classnames';\nimport { autoLoad, Stage, Shape, ColormakerRegistry, Matrix4 } from 'ngl';\n\nimport { frame } from 'timing-functions';\n\nimport { setNGLFile, updateNGLFile } from './payload-to-ngl-file';\n\nimport { EXPLICIT_BONDING_NGL_DRAWING_METHODS } from '../viewer-with-controls/constants';\n\nimport { ProjectCtx } from '../../contexts';\n\nimport { setTooltipPosition } from '../../utils/tooltip-position-manager';\n\nimport { appendBuffer } from '../../utils/auxiliar-functions';\n\nimport style from './style.module.css';\n\n// Make a deep copy of an object even with cyclic references\nimport { cloneDeep } from 'lodash-es';\n\n// Used to just wait\nimport { sleep } from 'timing-functions';\n\nconst DEFAULT_ORIENTATION_TRANSITION_DURATION = 750; // 750 ms\n\nconst CHAIN_SELECTION = 'polymer and not hydrogen ';\n\nconst isValidColor = colorName => {\n  var s = new Option().style;\n  s.color = colorName;\n  return s.color === colorName;\n};\n\n// Set the number of bytes per element in trajectory data\nconst BYTES_PER_COORDINATE = 4; // float 32\nconst COORDINATES_PER_ATOM = 3; // x, y and z\nconst BYTES_PER_ATOM = BYTES_PER_COORDINATE * COORDINATES_PER_ATOM;\n\n// Set the NGL player speed limits\n// The actual 'currentSpeed' input limits are 0-100\n// The speed set as the time to wait before moving to the next frame in miliseconds\nconst minimumSpeed = 0;\nconst maximumSpeed = 100;\nconst slowestTimeout = 1000;\nconst fastestTimeout = 50;\nconst interpolateSpeed = currentSpeed => (\n  slowestTimeout + (currentSpeed - minimumSpeed) *\n  ((fastestTimeout - slowestTimeout) / (maximumSpeed - minimumSpeed))\n);\n\n// Set representation types for the different types of highlights\nconst defaultHighlightTypes = {\n  atoms: 'spacefill',\n  residues: 'ball+stick',\n  chains: 'ball+stick',\n  selections: 'ball+stick',\n};\n\nconst NGLViewer = memo(\n  forwardRef(\n    (\n      {\n        className,\n        playing,\n        spinning,\n        smooth,\n        onProgress,\n        bounce = false, // Set if the animation, when finished, starts again (false) or goes back (true)\n        selectedAtoms, // Atom index of the atom and residue to be represented\n        selectedResidueIndices, // Residue indices from residues to be highlighted\n        selectedChains, // Chain letters from chains to be represented\n        selectedCustom, // Free NGL selections to be directly represented\n        selectedDistances, // Groups of 2 atoms or residues to be represented as a distance\n        selectedAngles, // Groups of 3 atoms to be represented as an angle\n        selectedRepresentation, // String name of a representation to be painted in yellow color (only 1)\n        snapRepresentations,\n        noTrajectory, // True when only specific frames must be loaded\n        initialFocus, // The ngl selection to be focused by the camera initially\n        darkBackground,\n        perspective,\n        speed,\n        xSelection, // To display planes for density analysis\n        rotateX,   // To rotate the stage so the Z axis goes from bottom to top\n        xAxisStep,\n        // Final components and representations prepared for the viewer\n        components,\n        representations,\n        // Viewer data incluting both structure and coordinates\n        topologies,\n        trajectories,\n        anyLoadingTopology,\n        anyLoadingTrajectory,\n        // Set the highlight representations types\n        highlightTypes = defaultHighlightTypes,\n      },\n      ref,\n    ) => {\n\n      // Get project data\n      const {\n        metadata,\n        topology: topologyManager,\n      } = useContext(ProjectCtx);\n\n      // Set the curated orientation in NGL format\n      const curatedOrientation = useMemo(() => {\n        // If we do not have metadata yet then stop\n        if (!metadata) return;\n        const ori = metadata.ORIENTATION;\n        // If no curated orientation is set in metadata then stop\n        if (!ori) return;\n        // The matrix 4 resorts values in the input list\n        // In order to make it match the original focus display we must sort them before\n        const sortedOrientation = [\n          ori[0], ori[4], ori[8], ori[12],\n          ori[1], ori[5], ori[9], ori[13],\n          ori[2], ori[6], ori[10], ori[14],\n          ori[3], ori[7], ori[11], ori[15],\n        ];\n        return new Matrix4().set(...sortedOrientation);\n      }, [metadata])\n\n      // Save the main component once it is staged\n      // This components is used by several functions\n      const [mainComponent, setMainComponent] = useState(null);\n      const [mainNglFile, setMainNglFile] = useState(null);\n      // The last automatic camera focus\n      const [focus, setFocus] = useState(initialFocus);\n      // Set the initial focus\n      useEffect(() => {\n        //console.log(initialFocus);\n        setFocus(initialFocus);\n      }, [initialFocus]);\n\n      // references\n      const containerRef = useRef(null);\n      const stageRef = useRef(null);\n      const tooltipRef = useRef(null);\n      const firstTime = useRef(true);\n\n      // in-view hook\n      const [inViewRef, isInView] = useInView();\n\n      // Set the content of the tooltip in JSX format\n      const [tooltipContent, setTooltipContent] = useState(null);\n\n      // Set the NGL parsed topologies\n      const [ parsedTopologies, setParsedTopologies ] = useState([]);\n      // Store the URLs of those topologies already started to be parsed\n      // This is to avoid processing twice the same topology\n      // Note that the processing is async, so we can not rely in the parsedTopologies state\n      // A topology may be parsing and not be included in this state yet for a brief moment\n      const alreadyParsedTopologies = useRef(new Set());\n      // Update the parsed topologies every time the downloaded topologies change\n      useEffect(() => {\n        // Iterate downloaded topologies\n        topologies.forEach(topology => {\n          // If the topology still has not the data then skip it\n          if (!topology.file) return;\n          // If the topology is already among the parsed topologies then skip it\n          if (topology.url in alreadyParsedTopologies.current) return;\n          alreadyParsedTopologies.current.add(topology.url);\n          // Parse the structure to a NGL file\n          const stringBlob = new Blob( [ topology.file ], { type: 'text/plain'} );\n          autoLoad(stringBlob, { defaultRepresentation: false, ext: \"pdb\" })\n            // Once the parse has been completed update the parsed topologies state\n            .then(prasedFile => {\n              // Copy the content of the topology object\n              const newParsedTopology = { ...topology };\n              // Replace the original file by the parsed file\n              newParsedTopology.file = prasedFile;\n              // Now push it to the parsed topologies\n              setParsedTopologies(previous => [...previous, newParsedTopology]);\n            })\n            // If there is any problem then log it to the console\n            .catch(error => { console.error(error) });\n        });\n        setParsedTopologies(previousParsedTopologies => {\n          // Set a new array to trigger the render when setting the new state\n          const newParsedTopologies = [ ...previousParsedTopologies ];\n          return newParsedTopologies;\n        });\n      }, [topologies]);\n\n      // Set a state to keep track of the current working tasks in the viewer\n      // This is useful to update the upper left corner logs in the viewer\n      const [runningTasks, setRunningTasks] = useState(0);\n\n      // Update the running tasks count\n      const handleTasksChange = useCallback(\n        value => {\n          setRunningTasks(current => current + value);\n        },\n        [setRunningTasks],\n      );\n\n      // Stage creation and removal on mounting and unmounting\n      useEffect(() => {\n        // set-up\n        const stage = new Stage(containerRef.current);\n        // wait for a render to screen, then\n        frame().then(() => {\n          if (!stage) return;\n          // make sure NGL knows the size it has available\n          stage.handleResize();\n        });\n        // Set a signal function to handle the update of running tasks count\n        stage.tasks.signals.countChanged.add(handleTasksChange);\n        // Save the stage reference\n        stageRef.current = stage;\n        // clean-up\n        return () => {\n          // NOTE: following line causes to fail when loading a new viewer with\n          // NOTE: previous structure data\n          // stageRef.current.removeAllComponents();\n          stageRef.current.dispose();\n          stageRef.current = null;\n        };\n      }, []);\n\n      // Handle the upper left corner viewer logs\n      const viewerLogs = useMemo(() => {\n        if (!topologyManager) return 'Waiting for the main topology';\n        if (!mainComponent) return `Waiting for the main component`;\n        if (!trajectories.length && !noTrajectory)\n          return `No trajectory available`;\n        if (runningTasks > 0) return `Rendering...`;\n        return undefined; // Show nothing when everything was finished and fine\n      }, [\n        mainComponent,\n        trajectories,\n        noTrajectory,\n        runningTasks,\n      ]);\n\n      // background (with transition)\n      useEffect(() => {\n        const beginning = Date.now();\n        let duration = 1000;\n        if (firstTime.current) {\n          duration = 0;\n          firstTime.current = false;\n        }\n        (async () => {\n          while (true) {\n            await frame(); // async, should check if we still have the viewer\n            if (!stageRef.current) return;\n            let currentTick = Date.now() - beginning;\n            // exit condition from 'while (true)' loop\n            // if we've gone over the full time of the animation\n            if (currentTick > duration) break;\n            if (darkBackground) currentTick = duration - currentTick;\n            const color = `#${Math.round((currentTick * 0xff) / duration)\n              .toString('16')\n              .padStart(2, '0')\n              .repeat(3)}`;\n            stageRef.current.viewer.setBackground(color);\n          }\n          await frame(); // async, should check if we still have the viewer\n          if (!stageRef.current) return;\n          // make sure we're set to the final colour\n          // (in case the transition was stopped halfway through)\n          stageRef.current.viewer.setBackground(\n            darkBackground ? 'black' : 'white',\n          );\n        })();\n        // set duration to 0 to cancel possibly ongoing loop\n        return () => (duration = 0);\n      }, [darkBackground]);\n\n      // perspective\n      useEffect(() => {\n        stageRef.current &&\n          stageRef.current.viewer &&\n          stageRef.current.viewer.setCamera &&\n          stageRef.current.viewer.setCamera(\n            perspective ? 'perspective' : 'orthographic',\n          );\n      }, [perspective]);\n\n      // frames\n      // Update the controls progress\n      useEffect(() => {\n        // Check if we are prepared to add the frame change handler and if t is required\n        if (!onProgress || noTrajectory || !mainNglFile) return;\n        // Get the frame count of the final number of frames (once the whole trajectory is loaded)\n        const frameCount = mainNglFile.expectedFrames;\n        // Set the actual function to handle frame change internally in the component\n        const frameHandler = frame => {\n          //console.log('NGL frameCount: ' + frameCount);\n          const progress = clamp(frame / (frameCount - 1), 0, 1);\n          onProgress(progress);\n        };\n        // Add the frame handler to the component signals\n        mainNglFile.signals.frameChanged.add(frameHandler);\n        // Set a cleanup function to remove the frame handler when there is need\n        return () => {\n          mainNglFile.signals.frameChanged.remove(frameHandler);\n        };\n      }, [mainNglFile, noTrajectory, onProgress]);\n\n      // Resize logic\n      // declare handler\n      const handleResize = useCallback(async () => {\n        if (!stageRef.current) return;\n        const canvas = containerRef.current.querySelector('canvas');\n        if (canvas) {\n          canvas.style.height = '';\n          canvas.style.cursor = 'default';\n        }\n        // WARNING: This sleep here is to fix a bug\n        // When we open/close settings we trigger this function but it takes the size of the window before changing\n        // The sleep fixes this problem altought the delay is 0\n        await sleep(0);\n        stageRef.current.handleResize();\n      }, []);\n      // connect the handle to events\n      useEffect(() => {\n        window.addEventListener('resize', handleResize);\n        return () => {\n          window.removeEventListener('resize', handleResize);\n        };\n      }, [handleResize]);\n\n      // PDB file, base structure\n      // Set the representations in each component\n      useEffect(() => {\n        if (!components || !representations || !topologyManager) return;\n        components.forEach((comp, c) => {\n          // Set the NGL component\n          let stageComp = stageRef.current.compList.find(stc => stc.myName == comp.name);\n          if (!stageComp) {\n            // Find the topology which matches the component urlpath\n            // If a component has no urlpath it will match a topology with no urlpath: the default topology\n            const urlpath = comp.topologyURL || null;\n            const topology = parsedTopologies.find(topology => topology.urlpath === urlpath);\n            // If the topology has not been loaded yet then we have a problem\n            // DANI: Todas las topologas deben estar ya listas antes de cargarlas, lee los mensajes de arriba\n            if (!topology) return;\n            // Stop here if it is not downloaded yet\n            if (topology.error)\n              throw new Error(`Topology from '${urlpath}' returned error ${topology.error}`);\n            if (!topology.file)\n              throw new Error(`Topology data from '${urlpath}' is missing`);\n            // Atom occupancy is a field which is not used anywhere but in the electrostatic representation\n            // The electrostatic surface scheme color does not work if the occupancy is 0 (ngl code, not ours)\n            // We set all occupancies to 1, since some topologies may have all occupancies as 0 by default\n            topology.file.atomStore.occupancy = new Array(\n              topology.file.atomStore.occupancy.length,\n            ).fill(1);\n            // Set atom bonds according to our topology\n            const safeBonds = topologyManager.atomBonds;\n            if (safeBonds) {\n              const bondStore = topology.file.bondStore;\n              // Remove default bonds\n              bondStore.length = 0;\n              bondStore.count = 0;\n              bondStore.atomIndex1 = new Int32Array;\n              bondStore.atomIndex2 = new Int32Array;\n              bondStore.bondOrder = new Int32Array;\n              // Add every bond in the topology\n              safeBonds.forEach((bondedAtomsIndices, atomIndex) => {\n                const atom1 = topology.file.getAtomProxy(atomIndex);\n                bondedAtomsIndices.forEach(bondedAtomIndex => {\n                  const atom2 = topology.file.getAtomProxy(bondedAtomIndex);\n                  // The '1' stands for the bond order (idk what this is)\n                  bondStore.addBond(atom1, atom2, 1);\n                });\n              });\n            }\n            // Add the topology to the NGL\n            // Make a deep copy of the topology object to prevent NGL internal bugs\n            // This object will store data which is component exclusive\n            const componentObject = cloneDeep(topology.file);\n            //const componentObject = topology.file;\n            stageComp = stageRef.current.addComponentFromObject(componentObject);\n            stageComp.myName = comp.name;\n            if (!stageComp) return;\n            stageComp.onlyTopology = comp.onlyTopology;\n            setMainComponent(stageComp);\n          }\n\n          // Get current component representations\n          const componentRepresentations = representations.filter(rep => rep.component === comp.name);\n\n          // Set each representation\n          // Delete previous representations which are not requested anymore\n          const registredNames = [];\n          componentRepresentations.forEach((rep, r) => {\n            // The name here is used to indetify previous existing representations\n            const name = r + '-' + rep.name;\n            registredNames.push(name);\n\n            // Adapt a few representation values to the context\n            const show = rep.show\n            let sele = rep.selection;\n            // DANI: This solves a lot of silent and shaddy errors\n            // DANI: If you select 'all' or '*' you may see wrong bonding patterns\n            // DANI: If there are no bonds and you represent in licorice or ball+stick the NGL may crash\n            // DANI: However, if you type a wrong selection then everythin is represented properly\n            // DANI: And that is exactly the behaviour we want when we type all, so this is the solution\n            if (sele === 'all' || sele === '*') sele = 'patata';\n            // In the other hand, if the selection is empty then all would be represented by default\n            // A selection should never be empty so if it happens then it is a bug\n            // To avoid showing everythin in a buggy representation we set an empty selection as None\n            if (sele === '' || sele == null) sele = 'None';\n            const type = rep.type\n            const color = rep.color;\n            const opacity = show ? rep.opacity : 0;\n\n            const customColorScheme = rep.customScheme;\n\n            // If the representation is selected then the color is yellow\n            const colorScheme = rep.name === selectedRepresentation\n              ? ColormakerRegistry.addSelectionScheme(\n                  [['yellow', 'all']],\n                  'custom label',\n                )\n              // If the colorScheme is in the passed custom schemes use it\n              : customColorScheme && color === 'custom'\n                ? customColorScheme\n                // If the colorScheme is a defined color, create a custom colorScheme for this color\n                : isValidColor(color)\n                  ? ColormakerRegistry.addSelectionScheme(\n                      [[color, 'all']],\n                      'custom label',\n                    )\n                  // Otherwise let the color scheme as it is\n                  : color;\n\n            // Set some additional parameters which are to be modified depending on the type\n            const colorDomain = type === 'surface' ? [-200, 200] : undefined;\n            const surfaceType = type === 'surface' ? 'av' : undefined;\n            //const background = type === 'surface' && opacity < 1 ? true : false;\n            const depthWrite = type === 'surface' && opacity < 1 ? false : true;\n\n            // Join all parameters into a single input object\n            const parameters = {\n              sele,\n              name,\n              opacity,\n              colorScheme,\n              colorDomain,\n              surfaceType,\n              side: 'front',\n              //background,\n              depthWrite,\n              //opaqueBack: true,\n              //forceTransparent: true,\n              ...rep.other,\n            };\n\n            // Find the previous representation\n            const previousRepresentation = stageComp.reprList.find(\n              previous => previous.name === name,\n            );\n\n            // Update the previous representation if exists\n            if (previousRepresentation) {\n              const previousType = previousRepresentation.repr.type;\n              const previousSelection =\n                previousRepresentation.repr.selection.string;\n              // If the 'drawingMethod' has been changed we have to remake the whole representation\n              // WARNING: Representations with 'trace' type must be remade always\n              // WARNING: Reseting their parameters returns a fatal error. It is an internal NGL bug.\n              if (\n                previousType !== type ||\n                previousSelection !== sele ||\n                previousType === 'trace'\n              ) {\n                stageComp.removeRepresentation(previousRepresentation);\n                stageComp.addRepresentation(type, parameters);\n              }\n              // Otherwise it is faster just to update the parameters\n              else {\n                previousRepresentation.setParameters(parameters);\n              }\n            }\n            // If there is no previous representation then set a new one\n            else {\n              stageComp.addRepresentation(type, parameters);\n            }\n\n            // Add a floating label over the representation when it is specified\n            const label = rep.label;\n            if (label) {\n              const labelName = rep.label + '-' + name;\n              // Find the equivalent previous label\n              const previous = stageComp.annotationList.find(\n                annotation => annotation.name === labelName,\n              );\n              //console.log(previous);\n              // If the representation is shown\n              if (show) {\n                // If there is a previous representation then just update the label\n                // The rest should be always the same\n                if (previous) {\n                  previous.element.label = rep.label;\n                }\n                // If there is not previous label then set it\n                else {\n                  var elm = document.createElement('div');\n                  elm.innerText = rep.label;\n                  elm.style.color = '#76FF03';\n                  elm.style.backgroundColor = '#607D8B';\n                  elm.style.padding = '8px';\n                  // get the geometrical center of the representation\n                  const center = stageComp.reprList[r].repr.structureView.center;\n                  const annotation = stageComp.addAnnotation(center, elm);\n                  annotation.name = labelName;\n                }\n              }\n              // If the representation is hidden\n              else {\n                // If there is a previous representation then remove it\n                if (previous) {\n                  stageComp.removeAnnotation(previous);\n                }\n              }\n            }\n\n            // Set this representation as the focus if it is selected\n            if (rep.name === selectedRepresentation) {\n              setFocus({ comp: c, sele: rep.selection });\n              //focused = true;\n            }\n          });\n\n          // Delete all representations which are not required anymore\n          // WARNING: It is very important to save apart the stageComp.reprList\n          // WARNING: Do not iterate over stageComp.reprList while removing representations\n          // WARNING: If so, representations would jump of index in the list\n          const previousRepresentations = [...stageComp.reprList];\n          previousRepresentations.forEach(rep => {\n            const name = rep.name;\n            // Representations with name starting with '*' are never removed by this way\n            // Those representations are automatic highlights\n            if (name.charAt(0) === '*') return;\n            for (const registredName of registredNames) {\n              if (name === registredName) return;\n            }\n            // If the name is not in the list the representation must be removed\n            stageComp.removeRepresentation(rep);\n          });\n\n          // If nothing has been focused at the end then focus the whole first component\n          setFocus(previous => {\n            if (previous) return previous; // This will not trigger any rerender\n            return { comp: 0, sele: 'all' };\n          });\n        });\n      }, [\n        components,\n        representations,\n        parsedTopologies,\n        selectedRepresentation,\n        setMainComponent,\n        topologyManager,\n      ]);\n\n      // Highlight specific atoms\n      useEffect(() => {\n        if (!topologyManager) return;\n        // DANI: He tenido que quitar la condicion de 'instanceof Set' porque sino no me entraba en el heatmap\n        //if (!(selectedAtoms instanceof Set) || !selectedAtoms) {\n        if (!mainComponent || !selectedAtoms) return;\n\n        // Set a representation name\n        // This is useful to find previous representations in further renders\n        const nameHighlight = '*highlightedAtoms';\n        const previousHighlightRepresentation = mainComponent.reprList.find(\n          representation => representation.name === nameHighlight,\n        );\n        if (previousHighlightRepresentation) {\n          mainComponent.removeRepresentation(\n            previousHighlightRepresentation,\n          );\n        }\n\n        // Name for residues representation\n        const nameContextHighlight = '*highlightedAtomResidues';\n        const previousContextRepresentation = mainComponent.reprList.find(\n          representation => representation.name === nameContextHighlight,\n        );\n        if (previousContextRepresentation) {\n          mainComponent.removeRepresentation(\n            previousContextRepresentation,\n          );\n        }\n\n        const atoms = Array.from(selectedAtoms);\n        if (!atoms.length) return;\n\n        // ngl starts counting at 0\n        const seleHighlight = `@${atoms.map(atomIndex => atomIndex).join(',')}`;\n\n        mainComponent.addRepresentation(highlightTypes.atoms, {\n          sele: seleHighlight,\n          opacity: 0.5,\n          scale: 1.5,\n          name: nameHighlight,\n        });\n\n        const otherResidueAtomsSelection = Array.from(\n          new Set(\n            // 'atoms' are in abolsute numeration\n            atoms.map(atomIndex => {\n              const atom = topologyManager.getAtomByIndex(atomIndex);\n              const atomIndices = atom.residue.atomIndices;\n              const nglAtomSelection = '@' + atomIndices.join(',');\n              return nglAtomSelection;\n            }),\n          ),\n        ).join(' or ');\n\n        mainComponent.addRepresentation(\n          highlightTypes.residues,\n          {\n            sele: otherResidueAtomsSelection,\n            name: nameContextHighlight,\n          },\n        );\n\n        // Focus the highlighted zone with the camera\n        setFocus({ comp: 0, sele: otherResidueAtomsSelection });\n      }, [\n        mainComponent,\n        topologyManager,\n        selectedAtoms,\n        darkBackground,\n        highlightTypes,\n      ]);\n\n      // Highlight specific residues\n      useEffect(() => {\n        if (!topologyManager || !mainComponent || !selectedResidueIndices) return;\n        // Set a representation name. This is useful to find this representation further\n        const nameHighlight = '*highlightedResidues';\n        const previousHighlightRepresentation = mainComponent.reprList.find(\n          representation => representation.name === nameHighlight,\n        );\n        if (previousHighlightRepresentation)\n        mainComponent.removeRepresentation(\n            previousHighlightRepresentation,\n          );\n        // If there are no selected residues at all we stop here\n        if (selectedResidueIndices.length === 0) return;\n        // Get the residues input\n        const residueNglSelections = selectedResidueIndices.map(\n          residueIndex =>\n            topologyManager.getResidueByIndex(residueIndex).nglSelection,\n        );\n        // Transform the residues list into an NGL selection\n        const overallNglSelection = Array.from(\n          new Set(residueNglSelections),\n        ).join(' or ');\n        // Represent the previous selection in ball+sticks drawing method\n        mainComponent.addRepresentation(\n          highlightTypes.residues,\n          {\n            sele: overallNglSelection,\n            name: nameHighlight,\n          },\n        );\n\n        // Focus the highlighted zone with the camera\n        setFocus({ comp: 0, sele: overallNglSelection });\n      }, [\n        mainComponent,\n        selectedResidueIndices,\n        topologyManager,\n        highlightTypes,\n      ]);\n\n      // Highlight specific chains\n      // DANI: NO Probado\n      useEffect(() => {\n        if (!mainComponent || !selectedChains) return;\n        // Set a representation name. This is useful to find this representation further\n        const nameHighlight = '*highlightedChains';\n        const previousHighlightRepresentation = mainComponent.reprList.find(\n          representation => representation.name === nameHighlight,\n        );\n        if (previousHighlightRepresentation)\n        mainComponent.removeRepresentation(\n            previousHighlightRepresentation,\n          );\n\n        // Get the residues input\n        const chains = selectedChains.map(c => ':' + c);\n        if (!chains.length) return;\n        // Transform the residues list into an NGL selection\n        const nglSelection = Array.from(new Set(chains)).join(' or ');\n\n        // Represent the previous selection in ball+sticks drawing method\n        mainComponent.addRepresentation(highlightTypes.chains, {\n          sele: nglSelection,\n          name: nameHighlight,\n        });\n        // Focus the highlighted zone with the camera\n        setFocus({ comp: 0, sele: nglSelection });\n      }, [mainComponent, selectedChains, highlightTypes]);\n\n      // Highlight specific free NGL selections\n      useEffect(() => {\n        if (!mainComponent || !snapRepresentations) return;\n        const currentRepresentations = mainComponent.reprList;\n        snapRepresentations.forEach(snapRepresentation => {\n          mainComponent.addRepresentation(snapRepresentation.type, {\n            sele: snapRepresentation.selection,\n            name: snapRepresentation.name,\n            color: snapRepresentation.color,\n            opacity: snapRepresentation.opacity,\n          });\n        });\n        return () => {\n          snapRepresentations.forEach(snapRepresentation => {\n            // Find if the current snap representation already exists by its name\n            const previousSnapRepresentation = currentRepresentations.find(\n              currentRepresentation =>\n                currentRepresentation.name === snapRepresentation.name,\n            );\n            // If so, remove it\n            if (previousSnapRepresentation)\n            mainComponent.removeRepresentation(previousSnapRepresentation);\n          });\n        };\n      }, [mainComponent, snapRepresentations]);\n\n      // Add specific NGL representations which are added or removed apart from the main component\n      // They are faster to update but they are not shown in the representations manager\n      useEffect(() => {\n        if (!mainComponent || !selectedCustom) return;\n        // Set a representation name. This is useful to find this representation further\n        const nameHighlight = '*highlightedCustom';\n        const previousHighlightRepresentation = mainComponent.reprList.find(\n          representation => representation.name === nameHighlight,\n        );\n        if (previousHighlightRepresentation)\n        mainComponent.removeRepresentation(\n            previousHighlightRepresentation,\n          );\n\n        if (!selectedCustom.length) return;\n        // Transform the residues list into an NGL selection\n        const nglSelection = Array.from(new Set(selectedCustom)).join(' or ');\n\n        // Represent the previous selection in ball+sticks drawing method\n        mainComponent.addRepresentation(\n          highlightTypes.selections,\n          {\n            sele: nglSelection,\n            name: nameHighlight,\n          },\n        );\n        // Focus the highlighted zone with the camera\n        setFocus({ comp: 0, sele: nglSelection });\n      }, [mainComponent, selectedCustom, highlightTypes]);\n\n      // Highlight specific distances\n      // When 'selectedDistances' is numeric it is taken as atoms\n      // When 'selectedDistances' is string it is taken as residues\n      // In both cases it works with residue indices\n      useEffect(() => {\n        if (!mainComponent || !selectedDistances) return;\n        // Set a representation name. This is useful to find this representation further\n        const name = '*distance';\n        const previousRepresentation = mainComponent.reprList.find(\n          representation => representation.name === name,\n        );\n        // Remove the previous representation\n        if (previousRepresentation)\n        mainComponent.removeRepresentation(\n            previousRepresentation,\n          );\n\n        // Display the new distance representation\n        mainComponent.addRepresentation('distance', {\n          atomPair: selectedDistances,\n          color: 'skyblue',\n          labelUnit: 'angstrom',\n          name: name,\n          // Label color is the opposite of the background color\n          labelColor: darkBackground ? 16777215 : 1, // 16777215 is white, 1 is black\n        });\n      }, [mainComponent, selectedDistances, darkBackground]);\n      \n      // Display a plane\n      useEffect(() => {\n        if (!mainComponent || !xSelection) return;\n        // Set a representation name. This is useful to find this representation further\n        const name = '*density';\n        const previousComponent= stageRef.current.compList.find(\n          component => component  .name === name,\n        );\n        // Remove the previous representation\n        if (previousComponent)\n          stageRef.current.removeComponent(\n            previousComponent,\n          );\n        else {\n          stageRef.current.viewer.rotationGroup.rotateY(-1.6);\n        };\n        var shape = new Shape(\"shape\", {radialSegments: 10 });\n        const boxCenter = mainComponent.object.center;\n        const bBox = mainComponent.object.boundingBox;\n        shape.addBox(\n          [boxCenter.x, boxCenter.y, xSelection*xAxisStep - xAxisStep/2], \n          [0, 0, 0], \n          bBox.max.x - bBox.min.x, \n          [0, bBox.max.y - bBox.min.y, 0], \n          [0, 0, 0.01]\n        );\n        shape.addBox(\n          [boxCenter.x, boxCenter.y, xSelection*xAxisStep + xAxisStep/2], \n          [0, 0, 0], \n          bBox.max.x - bBox.min.x, \n          [0, bBox.max.y - bBox.min.y, 0], \n          [0, 0, -0.01]\n        );\n        var shapeComp = stageRef.current.addComponentFromObject(shape, {name: name});\n        var rep = shapeComp.addRepresentation(\"buffer\", {opacity: 0.1 , roughness: 1});\n        // console.log(stageRef.current.viewer.rotationGroup.rotation);\n      }, [mainComponent, xSelection]);\n      \n      // Rotate the stage\n      useEffect(() => {\n        if (!mainComponent || !rotateX) return;\n        stageRef.current.viewer.rotationGroup.rotateX(-1.57);\n      }, [mainComponent, rotateX]);\n\n      // Highlight specific angles\n      useEffect(() => {\n        if (!mainComponent || !selectedAngles) return;\n        // Set a representation name. This is useful to find this representation further\n        const name = '*angles';\n        const previousRepresentation = mainComponent.reprList.find(\n          representation => representation.name === name,\n        );\n        if (previousRepresentation)\n        mainComponent.removeRepresentation(\n            previousRepresentation,\n          );\n\n        mainComponent.addRepresentation('angle', {\n          atomTriple: selectedAngles,\n          name: name,\n          labelColor: darkBackground ? 16777215 : 1, // 16777215 is white, 1 is black\n        });\n      }, [mainComponent, selectedAngles, darkBackground]);\n\n      // DCD file, trajectory\n      // Once the trajectories are downloaded, load them in corresponding NGL representations\n      // Every time the trajectory payloads change this useEffect must be rerun\n      useEffect(() => {\n        // Check if trajectories are\n        if (parsedTopologies.length === 0 || trajectories.length === 0 || !components) return;\n        components.forEach((comp, c) => {\n          // Find the topology which matches the component urlpath\n          // If a component has no urlpath it will match a topology with no urlpath: the default topology\n          const topologyUrlpath = comp.topologyURL || null;\n          const topology = parsedTopologies.find(topology => topology.urlpath === topologyUrlpath);\n          if (!topology) return;\n\n          // DANI: Aqu me he quedado\n          // DANI: Con la linea de arriba funciona (a veces) con la de abajo no funciona cuando yo pensaba que funcionara\n          // DANI: Si sigues tirando del hilo se puede hacer que las topologas vayan cargando a medida que llegan\n          // DANI: y no todas de golpe al final\n          //const stageComp = stageRef.current.compList[c];\n          const stageComp = stageRef.current.compList.find(stc => stc.myName == comp.name);\n\n          // Wait if the topology has not been loaded yet\n          if (!stageComp) return;\n          // Abort if the component is marked as 'only topology'\n          if (comp.onlyTopology) return;\n          // Find the trajectory payload from the component urls and join them\n          const trajectoryPayloads = [];\n          // Save the combined urls of all trajectories and their lengths\n          // This is used in further renders to know if current trajectory is new or the same\n          let combinedURL = '';\n          let combinedProgress = '';\n          // Record also the atoms for each trajectory and check that they match\n          let trajectoryAtoms;\n          let trajectoryFinalExpectedFrames = 0;\n          // Record also the frames for each trajectory and add them\n          for (const framedUrlpath of comp.framedURLs) {\n            const trajectory = trajectories.find(trajectory => trajectory.urlpath === framedUrlpath);\n            // If the trajectory is not downloaded yet then exit\n            if (!trajectory) return;\n            // Get atom counts from different trajectories and check they match\n            if (!trajectoryAtoms) trajectoryAtoms = trajectory.atoms;\n            if (trajectoryAtoms !== trajectory.atoms)\n              throw new Error( `Atoms number in the different trajectories do not match`);\n            // Add the final expected frames for all frames in the component\n            trajectoryFinalExpectedFrames += trajectory.frames;\n            // Add the main data to the array of payloads\n            // Substract data from not completed frames\n            const payload = trajectory.payload;\n            const bytesPerFrame = trajectoryAtoms * BYTES_PER_ATOM;\n            const fitLength = Math.floor(payload.byteLength / bytesPerFrame) * bytesPerFrame;\n            const fitPayload = payload.slice(0, fitLength);\n            trajectoryPayloads.push(fitPayload);\n            combinedURL += trajectory.url;\n            combinedProgress += '/' + trajectory.progress;\n          }\n\n          // Check if we are loading the same trajectory than before\n          const sameTrajectory = stageComp.combinedURL === combinedURL;\n\n          // If we are loading a different trajectory then remove all possibly already existing trajectories\n          // This return an error in console: \"updateStructure: traj disposed\"\n          // This may be a bug but it is actually working\n          // See https://github.com/arose/ngl/issues/680\n          if (!sameTrajectory)\n            stageComp.trajList.forEach(\n              stageComp.removeTrajectory.bind(stageComp),\n            );\n\n          // If both URL and progress are matching then exit here\n          if (sameTrajectory && stageComp.combinedProgress === combinedProgress)\n            return;\n\n          // Save current URL in the staged component\n          stageComp.combinedURL = combinedURL;\n          stageComp.combinedProgress = combinedProgress;\n\n          // Join all payloads into a single trajectory\n          let totalPayload;\n          if (trajectoryPayloads.length === 0) return;\n          else if (trajectoryPayloads.length === 1)\n            totalPayload = trajectoryPayloads[0];\n          // DANI: Esto no est bien ahora que hay streaming\n          // DANI: Si hubiese dos trayectorias combinadas sus frames quedaran entrelazadas\n          // DANI: Pero las trayectorias combinadas no se usan, as que no me merece la pena mantenerlo\n          else\n            totalPayload = trajectoryPayloads.reduce((cb, nb) =>\n              appendBuffer(cb, nb),\n            );\n          // If the total payload is empty then stop here\n          if (totalPayload.byteLength === 0) return;\n          // Calculate how many frames are there in total\n          const bytesPerFrame = trajectoryAtoms * BYTES_PER_ATOM;\n          const totalFrames = totalPayload.byteLength / bytesPerFrame;\n          const lastFrameIndex = totalFrames - 1;\n          // Check if all required data is already downloaded\n          const completedTrajectory =\n            totalFrames === trajectoryFinalExpectedFrames;\n\n          // Get the atom indices whom the trajectory coordinates belong to, in case it is passed\n          const trajectoryAtomIndices = comp.atomIndices;\n\n          // Make sure the number of atoms is as expected\n          if (trajectoryAtomIndices && trajectoryAtomIndices.length !== trajectoryAtoms)\n            throw new Error('Unexpected number of trajectory atoms');\n\n          // Get the current NGL loaded trajectories\n          const compTrajectories = stageComp.trajList;\n\n          // If there is a trajectory already update it with new data\n          if (compTrajectories.length > 0) {\n            // There must be only one trajectory\n            if (compTrajectories.length > 1)\n              throw new Error(`Multiple trajectories in one component`);\n            const nglFile = compTrajectories[0];\n            const nglTrajectory = nglFile.trajectory;\n            updateNGLFile(\n              nglTrajectory,\n              topology.file,\n              totalPayload,\n              trajectoryAtoms,\n              totalFrames,\n              trajectoryAtomIndices,\n            );\n            // Adjust some parameters after the trajectory data has been changed\n            nglTrajectory._frameCount = totalFrames;\n            if (c === 0) {\n              // Save the expected frames number here in the NGL file\n              // This is further use by the frame change handler\n              nglFile.expectedFrames = trajectoryFinalExpectedFrames;\n              const nglPlayer = nglTrajectory.player;\n              // Set animation player parameters\n              const timeout = interpolateSpeed(speed);\n              nglPlayer.setParameters({\n                end: lastFrameIndex,\n                interpolateStep: 100 / trajectoryFinalExpectedFrames, // This must be set every time\n                mode: completedTrajectory ? 'loop' : 'once',\n                timeout: timeout,\n              });\n              // If the trajectory was paused because it had no more frames to load then resume it\n              if (!noTrajectory && playing && !nglPlayer.isRunning) {\n                const currentFrame = nglTrajectory._currentFrame;\n                const endingFrame = lastFrameIndex;\n                if (currentFrame < endingFrame) nglPlayer.play();\n              }\n            }\n          }\n          // If there is not trajectory yet then create a new NGL trajectory\n          else {\n            // Transform the binary trajectory data to an NGL friendly format\n            const file = setNGLFile(\n              topology.file,\n              totalPayload,\n              trajectoryAtoms,\n              totalFrames,\n              trajectoryAtomIndices,\n            );\n            if (!file) return;\n            const nglFile = stageComp.addTrajectory(file);\n            const nglTrajectory = nglFile.trajectory;\n            // Add the frame change handler only if it is the main component\n            if (c === 0) {\n              // Save the expected frames number here in the NGL file\n              // This is further use by the frame change handler\n              nglFile.expectedFrames = trajectoryFinalExpectedFrames;\n              // Set animation player parameters\n              const timeout = interpolateSpeed(speed);\n              nglTrajectory.player.setParameters({\n                interpolateStep: 100 / trajectoryFinalExpectedFrames,\n                mode: completedTrajectory ? 'loop' : 'once',\n                timeout: timeout,\n              });\n              // Update the main NGL file\n              setMainNglFile(nglFile);\n            }\n            // Set trajectory frame\n            nglTrajectory.setFrame(0);\n          }\n        });\n      }, [\n        parsedTopologies,\n        trajectories,\n        components,\n        noTrajectory,\n        setMainNglFile,\n        // This playing here is just to avoid the warning\n        // I can't disable the warning with \"// eslint-disable-line react-hooks/exhaustive-deps\"\n        // This is because the automatic formatter puts the warning one line down because it is stupid\n        // Anyway the warning is also stupid, because using the playing as dependency is counterproductive\n        // To sum up: when eslint gets smarter and stops complaining you can remove playing from dependencies\n        playing,\n        // It is the same with the speed that with the playing\n        speed,\n      ]);\n\n      // Add a signaled handler to the main NGl file, which contains the mian trajectory\n      useEffect(() => {\n        // Set a function to make the trajectory never stop at any interpolation step\n        // If it is stopped in the middle of an interpolation then jump to the next frame\n        if (!mainNglFile) return;\n        const nglTrajectory = mainNglFile.trajectory;\n        const goToNextFrame = () => {\n          const currentFrame = nglTrajectory._currentFrame;\n          nglTrajectory.setFrame(currentFrame);\n        };\n        nglTrajectory.player.signals.haltedRunning.add(goToNextFrame);\n        // Removing NGL without removing signals from the trajectory player is fatal\n        // This raises the error \"Uncaught TypeError: this._bindings is undefined\"\n        // Set a cleanup function to prevent fatal errors\n        return () => {\n          nglTrajectory.player.signals.haltedRunning.remove(goToNextFrame);\n        }\n      }, [mainNglFile]);\n\n      // play/pause\n      useEffect(() => {\n        if (!mainNglFile) return;\n        const { player } = mainNglFile.trajectory;\n        player.setParameters({\n          // Set the interpolate step according to the total number of frames to show 1 by 1\n          interpolateStep: 100 / mainNglFile.trajectory.frameCount,\n          // Set the animation to go forward and then backward instead of restart if required\n          direction: bounce ? 'bounce' : 'forward',\n        });\n        // WARNING: Pausing the player when there is no trajectory may seem redundant\n        // However, if not paused, the surface representations never stop to be calculated\n        if (noTrajectory) player.pause();\n        else player[playing && isInView ? 'play' : 'pause']();\n        // Remvoing NGL while the animation is playing is fatal\n        // This raises the error \"Uncaught TypeError: this._bindings is undefined\"\n        // Set a cleanup function to prevent fatal errors\n        return () => player.pause();\n      }, [\n        mainNglFile,\n        playing,\n        isInView,\n        noTrajectory,\n        bounce,\n      ]);\n\n      // Handle the speed\n      // The speed is also self-regulated by NGL\n      // If the topology is too big to reach the required speed it will work as fast as possible\n      useEffect(() => {\n        // Get the current trajectory\n        if (!mainComponent) return;\n        const nglFile = mainComponent.trajList[0];\n        if (!nglFile) return;\n        // Set the player speed\n        // The 'speed' input ranges from 0 to 100\n        // The NGL 'timeout' parameter stands from the time to wait before moving to the next frame in miliseconds\n        //const timeout = 500 / (Math.log2(speed + 1) + 1);\n        const timeout = interpolateSpeed(speed);\n        nglFile.trajectory.player.setParameters({ timeout: timeout });\n      }, [mainComponent, speed]);\n\n      // spinning\n      useEffect(() => {\n        if (\n          stageRef.current &&\n          stageRef.current.spinAnimation &&\n          spinning === stageRef.current.spinAnimation.paused\n        ) {\n          stageRef.current.toggleSpin();\n        }\n      }, [spinning]);\n\n      // smoothing, player interpolation\n      useEffect(() => {\n        if (!mainNglFile) return;\n        mainNglFile.trajectory.player.parameters.interpolateType = smooth ? 'linear' : '';\n      }, [mainNglFile, smooth]);\n\n      // to avoid sometimes when it's not rendering after loading\n      useEffect(() => {\n        if (!(mainComponent && trajectories.length)) return;\n        handleResize();\n        return handleResize.cancel;\n      }, [mainComponent, trajectories, handleResize]);\n\n      // Highlight the selected chain region\n      // This useEffect seems to be special:\n      // It is run just once but some parts inside keep running on change events\n      // listen to change event from nightingale component\n      useEffect(() => {\n        if (!mainComponent || !topologyManager) return;\n        const handler = ({ detail }) => {\n          // escape case for event listener\n          if (!detail || !(detail.eventtype === 'click' || detail.eventtype === 'reset')) return;\n          let highlight = '';\n          for (const manager of document.querySelectorAll('protvista-manager')) {\n            // get highlight value for each manager\n            const thisHiglight = manager.attributeValues.get('highlight');\n            // Get the chain letter to know which chain has been selected\n            const chain = manager.attributes.chain.value;\n            // if none, escape\n            if (!thisHiglight) continue;\n            // Start and end values are in model numeration\n            // DANI: This is totally by chance. I didn't program this previous part\n            const [start, end] = thisHiglight.split(':');\n            const sourceStart = topologyManager.getResidueByParameters(chain, +start);\n            const sourceEnd = topologyManager.getResidueByParameters(chain, +end);\n            if (sourceStart.chainName !== sourceEnd.chainName)\n              throw new Error(`Range from multiple chains is not supported`);\n            highlight += ` or :${sourceStart.chainName} and ${sourceStart.number}-${sourceEnd.number}`;\n          }\n          highlight = highlight.substr(4); // remove initial ' or '\n\n          const previousStructureRepresentation = mainComponent &&\n          mainComponent.reprList.find(\n              representation => representation.name === 'structure',\n            );\n          if (previousStructureRepresentation)\n          mainComponent.removeRepresentation(previousStructureRepresentation);\n          // no highlight, then default coloring\n          if (!highlight) {\n            mainComponent.addRepresentation('cartoon', {\n              sele: CHAIN_SELECTION,\n              name: 'structure',\n              opacity: 1,\n            });\n            if (curatedOrientation) {\n              stageRef.current.animationControls.orient(\n                curatedOrientation,\n                DEFAULT_ORIENTATION_TRANSITION_DURATION,\n              );\n            }\n            return;\n          }\n\n          // otherwise, highlight accordingly\n          const colorSchemeID = ColormakerRegistry.addSelectionScheme(\n            [['yellow', highlight], ['white', '*']],\n            'custom label',\n          );\n          mainComponent.addRepresentation('cartoon', {\n            sele: CHAIN_SELECTION,\n            name: 'structure',\n            opacity: 1,\n            color: colorSchemeID,\n          });\n          mainComponent.autoView(\n            highlight,\n            DEFAULT_ORIENTATION_TRANSITION_DURATION,\n          );\n        };\n        window.addEventListener('change', handler);\n        return () => window.removeEventListener('change', handler);\n      }, [mainComponent, topologyManager, curatedOrientation]);\n\n      // Customize the NGL tooltip\n      useEffect(() => {\n        if (!topologyManager) return;\n        // Set a new tooltip\n        const tooltip = tooltipRef.current;\n        // WARNING: The following line is dangerous since you are manipulating the DOM outside of React\n        // If the tooltip component is not child of the viewer and you change to molstar then you have the following error:\n        // Node.removeChild: The node to be removed is not a child of this node\n        containerRef.current.appendChild(tooltip);\n\n        // Remove the original tooltip\n        stageRef.current.mouseControls.remove('hoverPick');\n\n        // Set a function which is used further to write a formatted output message to refer an atom\n        const formatOutput = atom => {\n          // a.residueIndex starts at 0\n          // WARNING: a.residueIndex is correct but we must convert it to source first\n          // In some cases 1 residue can have multiple residue indices\n          // (e.g. hydrogens at the end)\n          const residue = topologyManager.getResidueByIndex(atom.residueIndex);\n          const chainName = residue.chain.metadataChainName;\n          // Get the residue reference id\n          const referenceId = residue.referenceId;\n          return (\n            <>\n              {`Atom ${atom.index} (${atom.atomname})\n                Chain ${residue.chainName} ${chainName ? '(' + chainName + ')' : ''}\n                Residue ${residue.number} (${atom.resname})`}\n              {(() => {\n                // If there is not reference at all it means it is not even a protein\n                if (!referenceId) return;\n                // No referable flag is for proteins which are not to be referenced\n                // e.g. antibodies, synthetic constructs, etc.\n                if (referenceId === 'noref') return (\n                  <div style={{ color: 'orange' }}>{'No referable'}</div>\n                );\n                // The not found flag is for proteins which failed to be aligned in a blast\n                if (referenceId === 'notfound') return (\n                  <div style={{ color: 'salmon' }}>{'Reference not found'}</div>\n                );\n                // If the reference is missing in the database then show a disclaimer\n                if (residue.referenceData === null) return (\n                  <div style={{ color: 'red' }}>{`Missing data for ${referenceId}`}</div>\n                );\n                // Show the reference and its residue references number\n                return (\n                  <div>\n                    <div style={{ color: 'lightGreen' }}>{residue.referenceName}</div>\n                    {residue.referenceType === 'protein' && <div>{`- Residue ${residue.referenceNumber}`}</div>}\n                  </div>\n                )\n              })()}\n            </>\n          );\n        };\n\n        // Save a timeout before displaying the tooltip\n        // This way we can kill the display in case the mouse is out before the timeout is over\n        let timeout;\n\n        // Set a function that both prevents the tooltip if it is about to appear and hides it is already displayed\n        const hideTooltip = () => {\n          clearTimeout(timeout);\n          tooltip.style.display = 'none';\n        };\n\n        // Show our tooltip with the corresponding values when the mouse hovers an atom/bond\n        stageRef.current.signals.hovered.add(function(pickingProxy) {\n          // When mouse is over something (i.e. bonds or atoms)\n          if (pickingProxy) {\n            // Set a timeout for the hover to do not be instantaneous\n            hideTooltip();\n            timeout = setTimeout(() => {\n              // handle tooltip text\n              let description;\n              const bond = pickingProxy.bond;\n              const atom = pickingProxy.atom;\n              // When we hover a bond\n              if (bond) {\n                const atom1 = bond.atom1;\n                const atom2 = bond.atom2;\n                description = (\n                  <>\n                    <div>{`Bond ${atom1.index} - ${atom2.index}`}</div>\n                    <hr style={{ color: 'lightGrey' }} />\n                    {formatOutput(atom1)}\n                    <hr style={{ color: 'lightGrey' }} />\n                    {formatOutput(atom2)}\n                  </>\n                );\n              }\n              // When we hover an atom\n              else if (atom) {\n                description = formatOutput(atom);\n              }\n              setTooltipContent(description);\n              // Handle tooltip position\n              // WARNING: It is important to make the display block before calculating the position\n              // This is because the position is calculated from the tooltip size, which would be 0 otherwise\n              tooltip.style.display = 'block';\n              const { x, y } = setTooltipPosition(\n                containerRef.current,\n                tooltip,\n                pickingProxy.mouse.position,\n                3,\n              );\n              tooltip.style.top = y + 'px';\n              tooltip.style.left = x + 'px';\n            }, 400); // Wait 0,4 secs before showing the tooltip\n          }\n          // When mouse is over nothing\n          else {\n            hideTooltip();\n          }\n        });\n\n        // Remove the tooltip when the mouse is out of the NGL viewer container\n        containerRef.current.addEventListener('mouseleave', hideTooltip, false);\n\n        // Cleaning function\n        return () => {\n          tooltip.remove();\n          containerRef.current.removeEventListener('mouseleave', hideTooltip);\n        };\n      }, [topologyManager, setTooltipContent]);\n\n      // Track when the first focus has been performed, since first focus is instantaneous\n      const firstFocus = useRef(true);\n      // Focus the specified ngl selection with the camera automatically\n      useEffect(() => {\n        if (!focus) return;\n        // The selected region may be in any component, not only the main component\n        // If a component name is passed then search for it\n        const comp = focus.comp\n          ? stageRef.current.compList.find(c => c.myName === focus.comp)\n          : mainComponent;\n        if (!comp) return;\n        let transition = DEFAULT_ORIENTATION_TRANSITION_DURATION;\n        // First transition is instantaneous\n        if (firstFocus.current) {\n          transition = 0;\n          // if an original orientation was aleady defined\n          // (manually created, and stored in the API)\n          if (curatedOrientation) {\n            // use it to set the initial orientation\n            stageRef.current.animationControls.orient(\n              curatedOrientation,\n              0,\n            );\n          }\n          firstFocus.current = false;\n        }\n        comp.autoView(focus.sele, transition);\n      }, [mainComponent, focus, curatedOrientation]);\n\n      // Expose public methods and getters/setters\n      useImperativeHandle(\n        ref,\n        () => ({\n          autoResize: handleResize,\n          drawMesh(position, color_offset, name = \"test\") {\n            const previousComponent = stageRef.current.compList.find(\n              (component) => component.name === name\n            );\n            if (previousComponent) {\n              stageRef.current.removeComponent(previousComponent);\n            }\n            if (!position || position.length === 0) return;\n            const shape = new Shape(name, { disableImpostor: true });\n            let colors = new Float32Array(position.length);\n            colors = colors.map((v, i) => {\n              if (i > color_offset[1] && i % 3 === 2) {\n                return 1.0;\n              } else if (i > color_offset[0] && i <= color_offset[1] && i % 3 === 1) {\n                return 1.0;\n              } else if (i <= (color_offset[0]) && i % 3 === 0) {\n                return 1.0;\n              } else {\n                return 0.0;\n              }\n            });\n            shape.addMesh(position, colors);\n            var shapeComp = stageRef.current.addComponentFromObject(shape, { name: name });\n            var rep = shapeComp.addRepresentation(\"buffer\", { opacity: 0.8, roughness: 1 });\n          },\n          // Output the current orientation/focus in console\n          // Note: this is for the developer, not for the regular user\n          displayFocus() {\n            const orientation = stageRef.current.viewerControls.getOrientation();\n            const stringifiedArray = `[${orientation.elements.toString()}]`;\n            console.log(stringifiedArray);\n          },\n          centerFocus() {\n            setFocus({ comp: 0, sele: 'all' });\n            // Use the provided orientation, if any\n            if (!curatedOrientation) return;\n            stageRef.current.animationControls.orient(\n              curatedOrientation,\n              DEFAULT_ORIENTATION_TRANSITION_DURATION,\n            );\n          },\n          get currentFrame() {\n            if (!(mainComponent && trajectories.length)) return -1;\n            try {\n              return mainComponent.trajList[0].trajectory.currentFrame;\n            } catch (_) {\n              return -1;\n            }\n          },\n          set currentFrame(value) {\n            if (!(mainComponent && trajectories.length)) return;\n            try {\n              const total = this.totalFrames;\n              let frame = value;\n              if (frame < 0) frame = 0;\n              if (frame >= total) frame = total - 1;\n              mainComponent.trajList[0].trajectory.setFrame(frame);\n            } catch (_) {\n              /* */\n            }\n          },\n          get totalFrames() {\n            if (!(mainComponent && trajectories.length)) return 1;\n            try {\n              return mainComponent.trajList[0].trajectory.frames\n                .length;\n            } catch (_) {\n              return 1;\n            }\n          },\n          get totalExpectedFrames() {\n            try {\n              return mainComponent.trajList[0].expectedFrames;\n            } catch (_) {\n              return 1;\n            }\n          },\n        }),\n        [mainComponent, trajectories, handleResize],\n      );\n\n      // workaround to have multiple ref logic on one element\n      // https://github.com/thebuilder/react-intersection-observer/issues/186#issuecomment-468641525\n      const handleRef = node => {\n        // If node does not exist then do not assign null to containerRef\n        // This way cleanup functions from some useEffects can properly clean the last reference\n        if (!node) return;\n        inViewRef(node);\n        containerRef.current = node;\n      };\n\n      // Finally, render the ngl window\n      return (\n        <>\n          <div\n            ref={handleRef}\n            className={cn(className, style.container, {\n              [style['loading-structure']]: !mainComponent,\n              [style['loading-trajectory']]:\n                !noTrajectory && anyLoadingTrajectory,\n              [style['light-theme']]: !darkBackground,\n            })}\n            // Display loading status data in the upper left corner of the NGL window\n            data-loading={viewerLogs}\n          >\n            <div ref={tooltipRef} className={style.tooltip}>\n              {tooltipContent}\n            </div>\n          </div>\n        </>\n      );\n    },\n  ),\n);\nNGLViewer.displayName = 'NGLViewer'\nexport default NGLViewer;\n","import React, {\n    useContext,\n    useState,\n    useRef,\n    useEffect,\n} from 'react';\n\nimport { ProjectCtx } from '../../contexts';\n\n// To make API requests\nimport { BASE_PATH_PROJECTS } from '../../utils/constants';\n\n// Auxiliar functions\nimport { appendBuffer } from '../../utils/auxiliar-functions';\n\n// HTTP utils\nimport https from 'https-browserify';\nimport http from 'stream-http';\nimport { parse as urlParse } from 'url';\n\nconst frameRangeFormat = /\\?frames=(?<start>\\d+):(?<end>\\d+)(:(?<step>\\d+))?/;\nconst parseFrameRange = frameRange => {\n  // Search in the function's parameter value \"string\" by using a specified regexp format: STEP_FORMAT\n  const parsed = frameRangeFormat.exec(frameRange);\n  if (!parsed) return null;\n  // The 'frameRangeFormat' has 3 defined groups: start, end and step\n  // Use the value from the 3 groups to define and save the desired frames\n  const start = +parsed.groups.start;\n  const end = Math.max(+parsed.groups.end, start); // If the end is less than the start then just use the start\n  const step = +(parsed.groups.step || 1);\n  const frames = Math.floor((end - start) / step) + 1;\n  return { start, end, step, frames };\n};\n\n// This function expects to receive a specific frame or the number of frames to load\n// This function returns a string which specifies the frames to be loaded\n// This string is standarized in a API friendly format\nconst getFrames = (trajectoryFrames, requestedFrames, requestedFrame) => {\n    // only one specific frame loaded, as a projection\n    if (requestedFrame) return { range: (requestedFrame + 1).toString(), frames: 1 };\n    // multiple frames loaded, as a trajectory\n    if (!trajectoryFrames) throw new Error('Missing number of frames in the trajectory');\n    if (!requestedFrames) throw new Error('Missing number of requested frames');\n    const frameStep = Math.floor(trajectoryFrames / requestedFrames);\n    // Predict how many frames will be returned, which may be different from the requested frames number\n    const returnedFrames = Math.ceil(trajectoryFrames / frameStep);\n    return {\n        range: `${1}:${trajectoryFrames}:${frameStep}`,\n        frames: returnedFrames,\n    };\n};\n\n// This is a custom hook\n// Download all data required for the molecular viewer: topologies and trajectories\n// The exact topologies and trajectories to be downloaded are configured in the components\n// The maximum number of frames to load is passed through the \"requestedFramesNumber\"\n// The \"onLoad\" hook is helpful to return feedback of the current load progress\nconst useViewerData = (components, requestedFramesNumber, onLoad) => {\n\n    // If no URL is provided then use the main trajectory // URL to find the trajectory data in the API\n    // True when we just want to display a static structure // Requeste number of frames to display\n    // data from context\n    const { accessionAndMdNumber, fileDescriptors, structureData } = useContext(ProjectCtx);\n\n    // Download topologies ----------------------------------------------------------------------\n\n    // Download all requested topologies: Each component may have a different structure URL\n\n    // Set a state to store the topology requests\n    const [requestedTopologies, setRequestedTopologies] = useState([]);\n    // Set also a state to track whenever there is still a downloading topology\n    // LORE: This was useful when we had to wait for all stages to be mounted at the same time\n    // LORE: It does nothing now but its value is still valid and it may be useful for logs\n    const [anyLoadingTopology, setAnyLoadingTopology] = useState(false);\n\n    // Find if there are new topology to be requested in the components:\n    // Collect the topology on each component\n    // If the component has no topology specified use the main topology\n    useEffect(() => {\n        // Make sure we already have components\n        if (!components) return;\n        setRequestedTopologies(previousRequestedTopologies => {\n            const newRequestedTopologies = [];\n            components.forEach(comp => {\n                const urlpath = comp.topologyURL || null;\n                const selection = comp.atomSelection || null;\n                const atomIndices = comp.atomIndices || null;\n                // Check if the url is new\n                // Else, skip this url since it has been requested already\n                const allRequestedTopologies = [\n                    ...previousRequestedTopologies,\n                    ...newRequestedTopologies,\n                ];\n                const current = allRequestedTopologies.find(topology => topology.urlpath === urlpath);\n                if (current) return;\n                // Some urls may be missing\n                // This happens when the component wants the default structure\n                if (urlpath === null) {\n                    // Add a request with null url in order to get the main structure as topology\n                    // Do it only once for all components\n                    newRequestedTopologies.push({\n                        urlpath: null,\n                        loading: false,\n                        error: null,\n                    });\n                } else {\n                    // Add the topology to the list, so it will be requested to the API\n                    newRequestedTopologies.push({\n                        urlpath: urlpath,\n                        selection: selection,\n                        atomindices: atomIndices,\n                        loading: true,\n                        requested: false,\n                        error: null,\n                    });\n                    setAnyLoadingTopology(true);\n                }\n            });\n            return [...previousRequestedTopologies, ...newRequestedTopologies];\n        });\n    }, [components, setRequestedTopologies]);\n\n    // Set a state to store the downloaded topologies\n    const [topologies, setTopologies] = useState([]);\n    // Keep track of all requests in case we have to abort them further\n    const currentRequests = useRef([]);\n\n    // Download all requested topologies/structures from the API\n    useEffect(() => {\n        requestedTopologies.forEach(topology => {\n            // Check if the requested url has the data already downloaded\n            // If so, skip this request\n            if (topology.file) return;\n            // If the topology failed to load do not try it again\n            if (topology.error) return;\n            // If the topology has been already requested do not request it again\n            if (topology.requested && topology.source === accessionAndMdNumber) return;\n            // If there is no URL then load the main structure\n            // WARNING: The '[...previous]' is essential to make the array object change\n            // This is important, since the 'topologies' object is used as a dependency further\n            // And if we do not change the array then the change is not detected\n            if (topology.urlpath === null) setTopologies(previousTopologies => {\n                // The topology with the main structure data has not url\n                const newTopology = {\n                    url: null,\n                    source: accessionAndMdNumber,\n                    urlpath: null,\n                    file: structureData,\n                };\n                return [...previousTopologies, newTopology];\n            });\n            // If there is an URL\n            else {\n                topology.requested = true;\n                topology.source = accessionAndMdNumber;\n                // Create the POST body\n                const postData = JSON.stringify({\n                    selection : topology.selection,\n                    atomindices: topology.atomindices,\n                });\n                // Request the API\n                // http exception is added for local testing in http://localhost\n                const protocol = BASE_PATH_PROJECTS.substring(0, 5) === 'https' ? https : http;\n                const actualUrl = `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}${topology.urlpath}`;\n                const requestOptions = urlParse(actualUrl);\n                // We use the POST method instead of the regular GET method to allow long atom selections when requesting structure\n                // However, if we are requesting a file the POST method is not supported\n                const isStructureEndpoint = requestOptions.path.endsWith('/structure')\n                requestOptions.method = isStructureEndpoint ? 'POST' : 'GET';\n                requestOptions.headers = {\n                    'Content-Type': 'application/json',\n                    'Content-Length': postData.length\n                }\n                const request = protocol.request(requestOptions, response => {\n                    // Track the amout of bytes already downloaded\n                    let responseContent = '';\n                    response .on('data', chunk => {\n                        responseContent += chunk;\n                    }).on('end', () => {\n                        // Update the topologies state by adding the new topology with its content\n                        setTopologies(previousTopologies => {\n                            const newTopology = {\n                                url: actualUrl,\n                                source: accessionAndMdNumber,\n                                urlpath: topology.urlpath,\n                                file: responseContent\n                            };\n                            return [...previousTopologies, newTopology];\n                        });\n                        // Update the requested topology loading state\n                        topology.loading = false;\n                        // Check the loading state of all requested topologies\n                        // Then update the overall loading state\n                        const anyLoading = requestedTopologies.some(t => t.loading);\n                        setAnyLoadingTopology(anyLoading);\n                    });\n                });\n                // Send the request data (POST method feature)\n                if (requestOptions.method === 'POST'){\n                    request.write(postData);\n                }\n                // Close the request for it to actually start\n                // Note that this is required for the https.request altought it was not by https.get\n                request.end();\n                currentRequests.current.push(request);\n            }\n        });\n    }, [requestedTopologies, structureData, accessionAndMdNumber]);\n\n    // Download trajectories ------------------------------------------------------------------------------------------------\n\n    // First we find all trajectory URLs (i.e. all requests to API)\n    // Then we ask the API skipping repeated URLs\n\n    // Set a function to modify an url by adding the frames range according to requestedFramesNumber\n    // The only exception are those trajectories whose frame number is lower than requestedFramesNumber\n\n    // Set a state to store requested trajectories and their loading status\n    const [requestedTrajectories, setRequestedTrajectories] = useState([]);\n    // Set also a state to track whenever there is still a downloading trajectory\n    const [anyLoadingTrajectory, setAnyLoadingTrajectory] = useState(false);\n\n    // Find if there are new trajectories to be requested in the components:\n    // Collect trajectories on each component\n    // If the component has no trajectory specified use the main trajectory\n    // If the component is not the main component and has no frame specified, use the first frame\n    // Only the main component (the first) is allowed to load multiple frames by the moment\n    useEffect(() => {\n        // Make sure we already have components\n        if (!components) return;\n        // Send a request to the API with the file descriptor\n        const { loading, payload, error } = fileDescriptors;\n        // If we do not have file descritors yet then stop here\n        if (loading) return;\n        // Throw it in case something went wrong with the donwload\n        else if (error) throw error;\n        else if (!payload) throw new Error('Something bad happened with file descriptors');\n        // Finally update the trajectories state\n        setRequestedTrajectories(currentTrajectories => {\n            // Save the new requetsed trajectories\n            const newTrajectories = [];\n            // Set the urlpath to ask the API\n            // Here, if you ask for the trajectory.bin instead of just trajectory, you get the whole file\n            // This is because the only route of the API accepting frames selection is the \"trajectory\" endpoint\n            // Other paths such as \"trajectory.bin\" will be processed as \"/:files\"\n            const defaultUrlpath = `/trajectory`;\n            components.forEach((comp, c) => {\n                if (comp.onlyTopology) return;\n                // Set the first component as the 'principal' component\n                const isPrincipal = c === 0;\n                const requestedFrame = comp.frame;\n                // Get the trajectory urls\n                // If the component has no trajectory urlpath specified then use the default trajectory\n                const urlpaths = comp.trajectoryURLs || [ defaultUrlpath ];\n                // Add the frames number of all the component requested trajectories\n                comp.frameCount = 0;\n                urlpaths.forEach((urlpath, u) => {\n                    // Check if the urlpath is already framed\n                    const framed = parseFrameRange(urlpath);\n                    // Get the name of the trajectory file inside the database\n                    // i.e. the end of the requested URL\n                    // The exception is the API endpoint 'trajectory', which uses the 'trajectory.bin' file\n                    let trajectoryFilename = urlpath.split('/').slice(-1)[0];\n                    if (framed) trajectoryFilename = trajectoryFilename.split('?frames=')[0];\n                    if (trajectoryFilename === 'trajectory') trajectoryFilename = 'trajectory.bin';\n                    // Get the file descriptor of the required trajectory\n                    const trajectoryFileDescriptor = payload.find(file => \n                        file.filename === trajectoryFilename);\n                    if (!trajectoryFileDescriptor)\n                        throw new Error( `Trajectory \"${trajectoryFilename}\" is missing`);\n                    const trajectoryMetadata = trajectoryFileDescriptor.metadata;\n                    // Get the number of frames in the whole trajectory\n                    const trajectoryFrames = trajectoryMetadata.frames;                \n                    // Set the number of frames to be requested from the whole trajectory\n                    let requestedFrames = requestedFramesNumber;\n                    if (requestedFramesNumber > trajectoryFrames) requestedFrames = trajectoryFrames;\n                    if (Number.isFinite(requestedFrame)) requestedFrames = 1;\n                    else if (framed) requestedFrames = framed.frames;\n                    // Components which are not the principal must include a 'frame' value\n                    if (!isPrincipal && requestedFrames > 1) \n                        throw new Error(`Only the main component is allowed to load multiple frames`);\n                    // Frames are added to any urlpath which is missing the frames range according to requestedFramesNumber\n                    // The only exception are those trajectories whose frame number is lower than requestedFramesNumber\n                    let finalUrlpath = urlpath;\n                    // Get the expected number of frames returned, which may not be exactly the requested number\n                    let returnedFrames;\n                    // In case the urlpath is already framed\n                    if (framed) {\n                        // Find maximum number of frames to be returned (trajectory frames or requetsed frames)\n                        const maximumFrames = Math.min(trajectoryFrames, framed.end);\n                        returnedFrames = Math.ceil(maximumFrames / framed.step);\n                    }\n                    // Modify the urlpath if it is not framed yet\n                    else {\n                        // Get the string frames range according to requestedFramesNumber\n                        const { range: framesRange, frames: framesCount } = getFrames(\n                            trajectoryFrames,\n                            requestedFrames,\n                            requestedFrame,\n                        );\n                        returnedFrames = framesCount;\n                        // Add the frames range to the original urlpath\n                        if (framesRange) finalUrlpath = urlpath + `?frames=${framesRange}`;\n                    }\n                    // Set the component framed urlpath if it doesn't exists\n                    if (!comp.framedURLs) comp.framedURLs = [];\n                    // Save this final urlpath in the framedURL in the component\n                    // Overwrite the previous framed urlpath if exists\n                    comp.framedURLs[u] = finalUrlpath;\n                    // Add the requested frames number to the frame count\n                    comp.frameCount += requestedFrames;\n                    // Check if the requested urlpath is already in the list\n                    // If so, skip this request\n                    // If not, save the request urlpath and proceed\n                    const current = currentTrajectories.find(\n                        trajectory => trajectory.urlpath === finalUrlpath);\n                    if (!current) {\n                        newTrajectories.push({\n                            urlpath: finalUrlpath,\n                            frames: returnedFrames,\n                            // Add also the atoms number, which is used further\n                            atoms: trajectoryMetadata.atoms,\n                            loading: true,\n                            requested: false,\n                        });\n                        setAnyLoadingTrajectory(true);\n                    }\n                });\n            });\n            // In case there are new requested trajectories we return a new array to trigger dependencies\n            if (newTrajectories.length > 0) return [...currentTrajectories, ...newTrajectories];\n            // Otherwise we return the previous array to do no trigger dependencies\n            return currentTrajectories;\n        });\n    }, [components, fileDescriptors, requestedFramesNumber]);\n\n    // Set a state to store trajectories data\n    const [trajectories, setTrajectories] = useState([]);\n\n    // Download the requested trajectory data (frames)\n    useEffect(() => {\n        requestedTrajectories.forEach(trajectory => {\n            // Check if the trajectory has been requested already\n            // If so, skip this request\n            if (trajectory.requested && trajectory.source === accessionAndMdNumber) return;\n            trajectory.requested = true;\n            trajectory.source = accessionAndMdNumber;\n            // Set the loading status as true\n            trajectory.loading = true;\n            trajectory.progress = 0;\n            // DANI: Todava no me ha hecho falta hacer una seleccin larga de atomos/frames\n            // DANI: Todo est listo a nivel de API\n            // DANI: Solo har falta reformar un poco el viewer-with-controls y este script\n            const postData = JSON.stringify({});\n            // Request the API\n            // http exception is added for local testing in http://localhost\n            const protocol = BASE_PATH_PROJECTS.substring(0, 5) === 'https' ? https : http;\n            const actualUrl = `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}${trajectory.urlpath}`;\n            const requestOptions = urlParse(actualUrl);\n            // Check if the request points to the /trajectory endpoint or it is pointing to a file\n            const requestPathsteps = requestOptions.pathname.split('/')\n            const isTrajectoryEndpoint = requestPathsteps[requestPathsteps.length -1] === 'trajectory'\n            // We use the POST method instead of the regular GET method to allow long atom selections\n            // However, if we are retrieving a specific file the the POST method is not implemented\n            requestOptions.method = isTrajectoryEndpoint ? 'POST' : 'GET';\n            requestOptions.headers = {\n                'Content-Type': 'application/json',\n                'Content-Length': postData.length\n            }\n            const request = protocol.request(requestOptions, response => {\n            const totalBytes = response.headers['content-length'];\n            // Set the new trajectory\n            setTrajectories(previousTrajectories => {\n                const newTrajectory = {\n                    url: actualUrl,\n                    source: accessionAndMdNumber,\n                    urlpath: trajectory.urlpath,\n                    frames: trajectory.frames,\n                    atoms: trajectory.atoms,\n                    payload: new ArrayBuffer(0),\n                    progress: 0,\n                };\n                return [...previousTrajectories, newTrajectory];\n            });\n            // Track the amout of bytes already downloaded\n            let byteCount = 0;\n            response\n                .on('data', chunk => {\n                    byteCount += chunk.byteLength;\n                    trajectory.progress = byteCount / totalBytes;\n                    // Update trajectories with the current partial data we have\n                    setTrajectories(previousTrajectories => {\n                        const currentTrajectory = previousTrajectories.find(\n                            traj => traj.url === actualUrl);\n                        currentTrajectory.payload = appendBuffer(currentTrajectory.payload, chunk);\n                        currentTrajectory.progress = trajectory.progress;\n                        return [...previousTrajectories];\n                    });\n                })\n                .on('end', () => {\n                    // Save the main data in the ref\n                    trajectory.loading = false;\n                    // Then check the loading state of all requested trajectories and update the overall loading state\n                    const anyLoading = requestedTrajectories.some(\n                        trajectory => trajectory.loading,\n                    );\n                    setAnyLoadingTrajectory(anyLoading);\n                });\n            });\n            // Send the request data (POST method feature)\n            if (requestOptions.method === 'POST') request.write(postData);\n            // Close the request for it to actually start\n            // Note that this is required for the https.request altought it was not by https.get\n            request.end();\n            currentRequests.current.push(request);\n        });\n    }, [requestedTrajectories, accessionAndMdNumber]);\n\n    // If the accession or MD changes then we must clear old data to free up memory\n    // Purge old topologies and trajectories not belonging to the current accession and MD number\n    useEffect(() => {\n        setTopologies(previousTopologies => [\n            ...previousTopologies.filter(top => top.source === accessionAndMdNumber)\n        ]);\n        setTrajectories(previousTrajectories => [\n            ...previousTrajectories.filter(traj => traj.source === accessionAndMdNumber)\n        ]);\n    }, [accessionAndMdNumber]);\n\n    // If the whole component is removed then abort all requests in case they were not finished\n    // DANI: No he verificado que esto funcione bien a nivel de API\n    useEffect(() => {\n        // I save it in a constant to avoid a non-sense warning\n        const redundantList = currentRequests.current;\n        return () => {\n            redundantList.forEach(request => {\n                request.abort();\n            });\n        };\n    }, []);\n\n    // Update the load progress\n    useEffect(() => {\n        // Make sure we already have components\n        if (!components) return;\n        const mainComponentTrajectoryURLs = components[0] && components[0].framedURLs;\n        if (!mainComponentTrajectoryURLs) return;\n        // Get all trajectories to be used as the current main trajecotry\n        const mainTrajectories = [];\n        mainComponentTrajectoryURLs.forEach(urlpath => {\n            const trajectory = trajectories.find(trajectory => trajectory.urlpath === urlpath);\n            if (trajectory) mainTrajectories.push(trajectory);\n        });\n        if (mainTrajectories.length === 0) return;\n        // Then calculate the average progress in all loading trajectories and update the progress state\n        const overallFrames = mainTrajectories\n            .map(trajectory => trajectory.frames)\n            .reduce((a, b) => a + b, 0);\n        const overallProgress = mainTrajectories\n            .map(trajectory => trajectory.progress * trajectory.frames)\n            .reduce((a, b) => a + b, 0) / overallFrames;\n        onLoad(overallProgress);\n    }, [components, trajectories, onLoad]);\n\n    // Return downloaded data\n    return { topologies, trajectories, anyLoadingTopology, anyLoadingTrajectory };\n}\n\nexport default useViewerData;","export const LOW = Symbol('low');\nexport const MEDIUM = Symbol('medium');\nexport const HIGH = Symbol('high');\n\n// Check how fast the connection is and send the corresponding symbol\n// WARNING: This is done for Chrome. i.e. Firefox will always return MEDIUM\nconst connectionLevel = () => {\n  if (!(navigator && navigator.connection)) return MEDIUM;\n  const { effectiveType, saveData } = navigator.connection;\n  if (saveData === true) return LOW;\n  if (!effectiveType) return MEDIUM;\n  switch (effectiveType) {\n    case 'slow-2g':\n    case '2g':\n      return LOW;\n    case '3g':\n      return MEDIUM;\n    case '4g':\n      return HIGH;\n    default:\n      return HIGH;\n  }\n};\n\nexport default connectionLevel;\n","// extracted by mini-css-extract-plugin\nexport default {\"background-toggle\":\"style_background-toggle__aAj32\",\"dark\":\"style_dark__e5mDQ\",\"adapter\":\"style_adapter__+rjEA\",\"ngl-with-settings\":\"style_ngl-with-settings__k93CW\",\"ngl-without-settings\":\"style_ngl-without-settings__qTooi\",\"settings-left\":\"style_settings-left__Wvi5a\",\"settings-controls\":\"style_settings-controls__kLLNo\",\"ngl-alone\":\"style_ngl-alone__5TmnB\",\"stacked-icons\":\"style_stacked-icons__OoF+a\",\"extra-top-margin\":\"style_extra-top-margin__vaEmm\",\"settings-right\":\"style_settings-right__NDIcU\",\"hidden\":\"style_hidden__D+3lX\",\"fullscreen-toggle\":\"style_fullscreen-toggle__f4Bk2\",\"expand\":\"style_expand__brMFA\",\"is-fullscreen\":\"style_is-fullscreen__RtQvN\",\"compress\":\"style_compress__xLnUE\",\"settings\":\"style_settings__87jIw\",\"fullscreen-target\":\"style_fullscreen-target__VO3Yh\",\"card-content\":\"style_card-content__Y2hw3\",\"progress\":\"style_progress__LNzos\",\"container\":\"style_container__ERsvh\",\"controls\":\"style_controls__0ugFi\",\"slider\":\"style_slider__FgVYz\",\"flip-container\":\"style_flip-container__dGHQ+\",\"flip-card-container\":\"style_flip-card-container__wgyMe\",\"flipped\":\"style_flipped__DhDpU\",\"flip-card\":\"style_flip-card__g+agx\",\"front\":\"style_front__g9FOf\",\"back\":\"style_back__UfiiZ\",\"progressContainer\":\"style_progressContainer__kQ85K\",\"timeInfo\":\"style_timeInfo__wEsXY\"};","// React logic\nimport React, {\n  useCallback,\n  useState,\n  useEffect,\n  useRef,\n  useMemo,\n  forwardRef,\n  useImperativeHandle,\n  useContext,\n} from 'react';\nimport cn from 'classnames';\nimport screenfull from 'screenfull';\n// Visual assets\nimport {\n  Card,\n  CardContent,\n  Grid,\n  LinearProgress,\n  Icon,\n  IconButton,\n  Slider,\n} from '@mui/material';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport {\n  faDotCircle,\n  faImages,\n  faSquare,\n} from '@fortawesome/free-regular-svg-icons';\nimport {\n  faStepBackward,\n  faStepForward,\n  faPause,\n  faPlay,\n  faExpand,\n  faCompress,\n  faSyncAlt,\n  faVideo,\n  faAdjust,\n  faCog,\n  faCube,\n  faWalking,\n  faBiking,\n  faTimes,\n  faLock,\n  faUnlock,\n  faStarOfLife,\n  faShareAlt, // It looks like connected atoms\n} from '@fortawesome/free-solid-svg-icons';\n\nimport RepresentationsManager from './representations-manager';\n\nimport { get, setAsync } from '../../utils/storage';\n\n// To ask the API\nimport { BASE_PATH_PROJECTS } from '../../utils/constants';\n\n// The main component of the viewer itself\nimport MolstarViewer from '../molstar-viewer';\nimport NGLViewer from '../ngl-viewer';\n\n// Hooks\nimport useToggleState from '../../hooks/use-toggle-state';\nimport useViewerData from '../../hooks/use-viewer-data';\n\nimport connectionLevel, {\n  LOW,\n  MEDIUM,\n  HIGH,\n} from '../../utils/connection-level';\nimport reducedMotion from '../../utils/reduced-motion';\n\nimport style from './style.module.css';\n\nimport { ProjectCtx } from '../../contexts';\nimport { copyObject, round2cents } from 'src/utils/auxiliar-functions';\n\n// Decide that the default should be to play the trajectory only on \"big enough\"\n// screens (as a proxy for performance and low-end device detection)\nconst DEFAULT_STARTS_PLAYING = !reducedMotion() && window.innerWidth > 750;\n\nconst DEFAULT_FRAME_NUMBER = (() => {\n  switch (connectionLevel()) {\n    case HIGH:\n      return 50;\n    case MEDIUM:\n      return 25;\n    case LOW:\n    default:\n      return 10;\n  }\n})();\n\n// Set the possible number of frames the user can request\nconst DEFAULT_FRAME_NUMBERS = [\n  { value: 1, label: '1' },\n  { value: 10, label: '10' },\n  { value: 25, label: '25' },\n  { value: 50, label: '50' },\n  { value: 100, label: '100' },\n];\n\n// Set the default component parameters\n// These values are used to fill missing fields in input components\nconst DEFAULT_COMPONENT_PARAMETERS = {\n  name: 'Unnamed component',\n  topologyURL: 'auto', // This is assigned further\n  trajectoryURLs: 'auto', // This is assigned further\n  atomSelection: null,\n  atomIndices: null,\n  frame: null,\n  onlyTopology: false\n}\n\n// Set the default representation parameters\n// These values are used to fill missing fields in input representations\nconst DEFAULT_REPRESENTATION_PARAMETERS = {\n  name: 'Unnamed representation',\n  selection: 'all',\n  show: true,\n  type: 'cartoon',\n  color: 'chainid',\n  opacity: 1,\n  component: 'auto' // This is assigned further\n}\n\n// DANI: falta representation.index y custom\n\n// Set a function to fill the missing values within an object using default values\n// Return true if there was any change\nconst completeMissingFields = (targetObject, defaultValuesObject) => {\n  let anyChange = false;\n  for (const [fieldName, defaultValue] of Object.entries(defaultValuesObject)) {\n    if (targetObject[fieldName] === undefined) {\n      targetObject[fieldName] = defaultValue;\n      anyChange = true;\n    }\n  }\n  return anyChange;\n}\n\n// Set an NGL view window which is managed by some controls\n// There are different ways to call this script\n// 1 - With components: Used for situations where more than a topology or trajectory are required\n// 2 - With representations: Which internally means there will be only 1 component\n// 3 - With no parameters: In which case a default representation in set up\n// * In case of both components and representations passed, the valid argument will be the components\n// WARNING: There are many important hooks which have components/representations as a dependency\n// Avoid passing an object which is created every render. Use a somehow memoized array.\n// WARNING: The style of this component and its parent is very important. Use a reference to call it\nconst ViewerWithControls = forwardRef(\n  (\n    {\n      // The viewer starting components\n      // Components are objects which may include the following values:\n      // All values are optional since missing values will be set by default\n      //  {\n      //    name: name of the component used to link representations with it\n      //    topologyURL: string, (used in pockets analysis)\n      //    trajectoryURLs: [ string ], (used in pca)\n      //    atomSelection: string, (not used anymore but still supported)\n      //    atomIndices: [ int ], (used in pca)\n      //    frame: int, (used in rmsd pairwise analysis)\n      //    onlyTopology: bool, (used in pockets analysis)\n      //  }\n      startingComponents,\n      // The viewer starting representations\n      // It is an array of objects with the following structure:\n      // All values are optional since missing values will be set by default\n      // {\n      //   name: ('representation' by default) The string label of this representation,\n      //   show: ('true' by default) Boolean to set if this representation is shown or not,\n      //   selection: ('all' by default) The NGL selection string to define the atom selection,\n      //   type: ('cartoon' by default) The initial representation 'type',\n      //   color: ('chainid' by default) The initial representation 'colorScheme',\n      //   opacity: ('1' by default) The initial representation opacity\n      //   other: object with any other ngl options to be passed for the representation (e.g. radius)\n      //   component: name of the component this representation belongs to (main component when missing)\n      // }\n      startingRepresentations,\n      // Alternatively you may pass bot components and representations as states\n      // Thus the parent component may also control them\n      // Note that these states will be still controled by the child components anyway\n      componentsState,\n      representationsState,\n      // Style\n      className,\n      // Set if the viewer must play the simulation as soon as it appears\n      startsPlaying = DEFAULT_STARTS_PLAYING,\n      // Closing callback\n      close,\n      // Nailing callback\n      nail,\n      // Set which frame must be loaded. It may be undefined, if the whole trajectory is desired.\n      requestedFrame,\n      // Set if the frame number selector is allowed for trajectories (false in PCA projections)\n      framesSelect = true,\n      // Set a special option to force the 'noTrajectory' condition\n      // This is used to avoid the trajectory playing in pockets since there are surfaced representations\n      // This is only to be passed when having a trajectory loaded in the main component\n      // If a single frame is forced then this is redundant\n      preventTrajectory = false,\n      // Set a state setter to handle the frame progress\n      onProgress,\n      // The rest of properties paased to the NGLViewer\n      ...props\n    },\n    ref,\n  ) => {\n    // Make sure we are not having incompatible inputs\n    if (startingComponents && componentsState)\n      throw new Error('startingComponents and componentsState are not compatilbe inputs. Choose one.');\n    if (startingRepresentations && representationsState)\n      throw new Error('startingRepresentations and representationsState are not compatilbe inputs. Choose one.');\n    // Set which viewer is used: NGL or MolStar (the default is NGL)\n    const [Viewer, setViewer] = useState(NGLViewer);\n    // Get project metadata\n    const { metadata, accessionAndMdNumber, topology } = useContext(ProjectCtx);\n    // Track the current frame and time\n    const [currentFrameInfo, setCurrentFrameInfo] = useState({ frame: 0, time: 0 });\n    // Use metadata to limit available frames number\n    const frameNumbers = useMemo(() => {\n      const maximumSnapshots = metadata.mdFrames;\n      const frameNumbers = [...DEFAULT_FRAME_NUMBERS];\n      // Remove values over the maximim number of frames\n      for (let i = frameNumbers.length - 1; i >= 0; i--) {\n        if (frameNumbers[i].value > maximumSnapshots) frameNumbers.pop();\n        else break;\n      }\n      // In case no value was removed we are done\n      if (frameNumbers.length === DEFAULT_FRAME_NUMBERS.length)\n        return frameNumbers;\n      // Otherwise, if the maximum number of frames is not one of the options already, then add it\n      if (frameNumbers[frameNumbers.length - 1].value !== maximumSnapshots)\n        frameNumbers.push({\n          value: maximumSnapshots,\n          label: maximumSnapshots.toString(),\n        });\n      return frameNumbers;\n    }, [metadata.mdFrames]);\n    // Do not use the start object but make a copy to avoid a lot of silent errors\n    const fixedStartingComponents = useMemo(() => {\n      // If there are no starting components then just leave it as null\n      // The defualt completer logic will take over\n      if (!startingComponents) return null;\n      return startingComponents.map(comp => copyObject(comp));\n    }, [startingComponents]);\n\n    // Set the final components to be passed to the viewer\n    const [finalComponents, setFinalComponents] =\n      componentsState || useState(fixedStartingComponents);\n\n    // Set the missing value completer for components including URLs\n    // Return true if there was any change\n    const completeComponentMissingFields = useCallback(targetObject => {\n      if (!accessionAndMdNumber) return false;\n      const defaults = {...DEFAULT_COMPONENT_PARAMETERS};\n      defaults.topologyURL = `/structure`;\n      defaults.trajectoryURLs = [ `/trajectory` ];\n      return completeMissingFields(targetObject, defaults);\n    }, [accessionAndMdNumber]);\n\n    // Anytime components change, check if there are any missing values and fill them with default values\n    useEffect(() => {\n      // Wait for the default completer to be ready\n      if (!completeComponentMissingFields) return;\n      // If there are no components then set a default configuration\n      if (!finalComponents) {\n        const defComponents = [{ name: 'Main' }];\n        defComponents.forEach(comp => { completeComponentMissingFields(comp) });\n        return setFinalComponents(defComponents);\n      }\n      // Make sure we have no components with the same name\n      const componentNames = finalComponents.map(comp => comp.name);\n      const uniqueComponentNames = new Set(componentNames);\n      if (componentNames.length !== uniqueComponentNames.size)\n        throw new Error(`We have multiple components with the same name: ${componentNames.join(', ')}`);\n      // Fill missing values among components with default values\n      const changes = finalComponents.map(comp => \n        completeComponentMissingFields(comp, DEFAULT_COMPONENT_PARAMETERS));\n      // If there was any value filled then update the state to trigger a rerender\n      if (changes.some(v => v === true)) setFinalComponents([...finalComponents]);\n    }, [finalComponents, completeComponentMissingFields]);\n\n    // Anytime the requested frame changes update the main component\n    useEffect(() => {\n      if (!finalComponents) return;\n      if (requestedFrame === undefined) return;\n      if (finalComponents[0].frame === requestedFrame) return;\n      finalComponents[0].frame = requestedFrame;\n      setFinalComponents([...finalComponents]);\n    }, [finalComponents, requestedFrame]);\n\n    // Do not use the start object but make a copy to avoid a lot of silent errors\n    const fixedStartingRepresentations = useMemo(() => {\n      // If there are no starting representations then just leave it as null\n      // The defualt completer logic will take over\n      if (!startingRepresentations) return null;\n      return startingRepresentations.map(rep => copyObject(rep));\n    }, [startingRepresentations]);\n\n    // Set the final representations to be passed to the viewer\n    const [finalRepresentations, setFinalRepresentations] =\n      representationsState || useState(fixedStartingRepresentations);\n\n    // Use this hook to get the memoized NGL default representations\n    const defaultRepresentations = topology && topology.defaultRepresentations;;\n\n    // Set the missing value completer for representations including the main component name\n    // Return true if there was any change\n    const completeRepresentationMissingFields = useCallback(targetObject => {\n      if (!finalComponents) return false;\n      const defaults = {...DEFAULT_REPRESENTATION_PARAMETERS};\n      defaults.component = finalComponents[0].name;\n      return completeMissingFields(targetObject, defaults);\n    }, [finalComponents]);\n\n    // Anytime representations change, check if there are any missing values and fill them\n    // WARNING: Note that this must be a useEffect, not a useMemo, or you will get the following error:\n    //   Warning: Cannot update a component (`Pockets`) while rendering a different component (`ForwardRef`).\n    //   To locate the bad setState() call inside `ForwardRef`, follow the stack trace as described in \n    //   https://reactjs.org/link/setstate-in-render\n    useEffect(() => {\n      // If we still have no default references then stop here\n      if (!defaultRepresentations || defaultRepresentations.length === 0) return;\n      // If there are no representations then set a default configuration\n      if (!finalRepresentations) {\n        // Unless the representations state has been passed from another component above\n        // If it has been passed then delegate the job to that component\n        // Otherwise, we could interfere as it happend with pockets (it was hard to track the problem)\n        if (representationsState) return;\n        const defRepresentations = [...defaultRepresentations];\n        defRepresentations.forEach(rep => \n          completeRepresentationMissingFields(rep));\n        return setFinalRepresentations(defRepresentations);\n      }\n      // Fill missing values among representations with default values\n      const changes = finalRepresentations.map(rep => \n        completeRepresentationMissingFields(rep));\n      // If there was any value filled then update the state to trigger a rerender\n      // DANI: Este es el responsable de esto:\n      //   Warning: Cannot update a component (`blablabla`) while rendering a different component (`ForwardRef`).\n      //   To locate the bad setState() call inside `ForwardRef`, follow the stack trace as described in \n      //   https://reactjs.org/link/setstate-in-render\n      if (changes.some(v => v === true)) setFinalRepresentations([...finalRepresentations]);\n    }, [finalRepresentations, defaultRepresentations, completeRepresentationMissingFields]);\n\n    // references\n    const containerRef = useRef(null);\n    const viewerRef = useRef(null);\n\n    // toggle states\n    const [nailed, toggleNailed] = useToggleState(false);\n    const [playing, togglePlaying] = useToggleState(startsPlaying);\n    const [spinning, toggleSpinning] = useToggleState(false);\n    const [smooth, setSmooth] = useState(true);\n    const [darkBackground, toggleDarkBackground] = useToggleState(\n      useMemo(() => get('dark-background', false), []),\n    );\n    const [perspective, togglePerspective] = useToggleState(\n      useMemo(() => get('perspective', false), []),\n    );\n\n    // states\n    const [progress, setProgress] = useState(0);\n    const [load, setLoad] = useState(0);\n    const [isFullscreen, setIsFullscreen] = useState(screenfull.isFullscreen);\n    const [requestedFramesNumber, setRequestedFramesNumber] = useState(\n      Math.min(DEFAULT_FRAME_NUMBER, metadata.mdFrames),\n    );\n    const [speed, setSpeed] = useState(useMemo(() => get('speed', 50), []));\n    const [settings, openSettings] = useState(false);\n\n    // handlers\n\n    // Handle the automatic progress\n    const handleProgress = useCallback(\n      prog => {\n        if (onProgress) onProgress(prog);\n        setProgress(prog);\n        \n        // Calculate the current frame and time\n        if (viewerRef.current) {\n          const currentFrame = viewerRef.current.currentFrame;\n          // Calculate time in nanoseconds using the frame step from metadata\n          const timeInNs = metadata.FRAMESTEP ? (metadata.timeLength * prog).toFixed(2) : 0;\n          setCurrentFrameInfo({ frame: currentFrame, time: timeInNs });\n        }\n      }, [setProgress, onProgress, metadata.FRAMESTEP],\n    );\n\n    // Patch to stop playback when URL changes\n    // LORE: this is a workaround to be able to change from the trajectory to other\n    // accesion pages when the player speed is high (ISSUE #24)\n    useEffect(() => {\n      // Save original history methods\n      const originalPushState = window.history.pushState;\n      const originalReplaceState = window.history.replaceState;\n      \n      // Override history methods to add our own handlers\n      window.history.pushState = function() {\n        // Call original method\n        originalPushState.apply(this, arguments);\n        // Stop playback if playing\n        if (playing) togglePlaying(false);\n      };\n      \n      window.history.replaceState = function() {\n        // Call original method\n        originalReplaceState.apply(this, arguments);\n        // Stop playback if playing\n        if (playing) togglePlaying(false);\n      };\n\n      // Clean up\n      return () => {\n        window.history.pushState = originalPushState;\n        window.history.replaceState = originalReplaceState;\n\n      };\n    }, [playing, togglePlaying]);\n    \n\n    // Handle the trajectory load\n    const handleLoad = useCallback(\n      load => {\n        setLoad(load);\n      }, [setLoad],\n    );\n\n    // handle click or click & drag progress bar\n    const handleManualProgress = useCallback(\n      ({ buttons, clientX, currentTarget, type }) => {\n        if (!viewerRef.current) return;\n        // if mousemove event, but the main button is not pressed, bail\n        if (type === 'mousemove' && buttons !== 1) return;\n        const { x, width } = currentTarget.getBoundingClientRect();\n        // Set pause\n        togglePlaying(false);\n        // Change the ngl viewer current ref from its exposed setter\n        // Then the ngl itself will update the 'progress' state\n        viewerRef.current.currentFrame = Math.floor(\n          ((clientX - x) / width) * viewerRef.current.totalExpectedFrames,\n        );\n      }, [togglePlaying],\n    );\n\n    // Frame change handler to interact with the child viewer\n    const handleFrameChange = useCallback(\n      value => {\n        if (!viewerRef.current) return;\n        togglePlaying(false);\n        viewerRef.current.currentFrame += value;\n      }, [togglePlaying],\n    );\n\n    // When the user requests the previous frame\n    const handlePreviousFrame = useCallback(() => handleFrameChange(-1), [handleFrameChange]);\n\n    // When the user requests the next frame\n    const handleNextFrame = useCallback(() => handleFrameChange(1), [handleFrameChange]);\n\n    // Enter/exit fullscreen\n    const handleFullscreenChange = useCallback(() => setIsFullscreen(screenfull.isFullscreen), []);\n    useEffect(() => {\n      screenfull.on('change', handleFullscreenChange);\n      return () => screenfull.off('change', handleFullscreenChange);\n    }, [handleFullscreenChange]);\n\n    // When the user clicks on the fullscreen button\n    const handlerFullscreenButton = useCallback(\n      () => { if (containerRef.current) screenfull.toggle(containerRef.current) }, []);\n\n    // Exit the options menu by pressing the escape key and handle spacebar for play/pause\n    useEffect(() => {\n      const handleKeyPress = event => {\n        if (event.key === 'Escape') {\n          openSettings(false);\n          viewerRef.current.autoResize();\n        }\n        // Only handle spacebar if not typing in an input field\n        if (event.key === ' ' && event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {\n          event.preventDefault(); // Prevent page scrolling\n          togglePlaying(prev => !prev);\n        }\n      };\n      document.addEventListener('keydown', handleKeyPress, false);\n      return () => document.removeEventListener('keydown', handleKeyPress, false);\n    }, []);\n\n    // Find out if there are residues under PBC (Periodic Boundary Conditions) in the topology\n    // In case we have atom selections in all components, check if at least one is under PBC\n    // Otherwise we consider there are no PBC since all represented atoms are not in PBC\n    // This is useful in PCA projections\n    // If there are PBC residues then stop the smooth to prevent misleading artifacts\n    const hasPbcResidues = useMemo(() => {\n      if (!topology || !topology.pbcResidues) return;\n      if (!finalComponents) return;\n      // Check if there is at least one residue in PBC\n      const anyPbcResidues = topology.pbcResidues.size > 0;\n      if (anyPbcResidues === false) return false;\n      // If there is at least one PBC residue...\n      // Check if we have atom indices in all components\n      const haveAllAtomIndices = finalComponents.every(comp => comp.atomIndices);\n      if (haveAllAtomIndices) {\n        // Check if any atom index is included among PBC residues\n        const allAtomIndices = finalComponents.reduce((acc, comp) => acc.concat(comp.atomIndices), []);\n        const anyPbcAtom = allAtomIndices.some(atomIndex => {\n          const atom = topology.getAtomByIndex(atomIndex);\n          return topology.pbcResidues.has(atom.residueIndex);\n        });\n        if (anyPbcAtom === false) return false;\n      }\n      setSmooth(false);\n      return true;\n    }, [topology, finalComponents]);\n\n    // This allows parent components to interact with this component\n    useImperativeHandle(ref,\n      () => ({\n        autoResize: viewerRef.current.autoResize,\n        centerFocus: viewerRef.current.centerFocus,\n        drawMesh: viewerRef.current.drawMesh,\n        get currentFrame() {\n          return viewerRef.current.currentFrame;\n        },\n        set currentFrame(value) {\n          viewerRef.current.currentFrame = value;\n        },\n        togglePlaying: togglePlaying,\n        setFinalComponents: setFinalComponents,\n        setFinalRepresentations: setFinalRepresentations\n      }),\n      [\n        togglePlaying,\n        setFinalComponents,\n        setFinalRepresentations,\n      ],\n    );\n\n    // Set the variable 'noTrajectory' as true when:\n    // The flag 'onlyTopology' is passed\n    // there is a selected unique frame to load from the main trajectory\n    // The main trajectory only has 1 frame (e.g. average.xtc)\n    const mainComponent = finalComponents && finalComponents[0];\n    const noTrajectory = preventTrajectory || (mainComponent && (mainComponent.onlyTopology ||\n      Number.isFinite(mainComponent.frame))); // May be 0\n\n    // Download viewer data from the API according to the components configuration\n    const {\n      topologies,\n      trajectories,\n      anyLoadingTopology,\n      anyLoadingTrajectory\n    } = useViewerData(finalComponents, requestedFramesNumber, handleLoad);\n\n    // DANI: Si no quieres buscarte problemas no cambies las \"Card\"s de aqu abajo por \"div\"s o similar\n    return (\n      <Card\n        className={cn(style['fullscreen-target'], {\n          [style['is-fullscreen']]: isFullscreen,\n        })}\n        ref={containerRef}\n      >\n        <div className={cn(style.adapter, className)}>\n          <Card\n            className={settings\n              ? style['ngl-with-settings']\n              : style['ngl-without-settings']\n            }\n            style={{ border: 'none', boxShadow: 'none' }}\n            // This id prevents the mouse to drag or resize the Rnd when it is over this element\n            id={'preventDragSize'}\n          >\n            <Card\n              className={settings\n                ? cn(style['settings-left'], className)\n                : cn(style['ngl-alone'], className)\n              }\n              style={{ border: 'none', boxShadow: 'none' }}\n            >\n              <Viewer\n                playing={playing}\n                spinning={spinning}\n                smooth={smooth}\n                onProgress={handleProgress}\n                ref={viewerRef}\n                noTrajectory={noTrajectory}\n                darkBackground={darkBackground}\n                perspective={perspective}\n                speed={speed}\n                components={finalComponents}\n                representations={finalRepresentations}\n                // Viewer data incluting both structure and coordinates\n                topologies={topologies}\n                trajectories={trajectories}\n                anyLoadingTopology={anyLoadingTopology}\n                anyLoadingTrajectory={anyLoadingTrajectory}\n                {...props}\n              />\n              {settings && (\n                <div className={style['settings-controls']}>\n                  <div className={style['stacked-icons']}>\n                    <IconButton\n                      title=\"Toggle spin\"\n                      onClick={toggleSpinning}\n                      size=\"large\"\n                    >\n                      <FontAwesomeIcon icon={faSyncAlt} />\n                    </IconButton>\n\n                    <IconButton\n                      title=\"Center focus\"\n                      onClick={event => {\n                        if (!viewerRef.current) return;\n                        // When the keys control, shift or command (ios) are hold while clicking\n                        const getFocus = event.shiftKey || event.ctrlKey || event.metaKey;\n                        if (getFocus) viewerRef.current.displayFocus();\n                        else viewerRef.current.centerFocus();\n                      }}\n                      size=\"large\"\n                    >\n                      <FontAwesomeIcon icon={faDotCircle} />\n                    </IconButton>\n\n                    {noTrajectory || (\n                      <div className={style['stacked-icons']} title={hasPbcResidues &&\n                        'Smooth interpolation is not allowed since there are residues under Periodic Boundary Conditions. ' +\n                        'The smoothing may result in misleading artifacts for those atoms jumping across boundaries.'}>\n                        <IconButton\n                          title={`Toggle smooth interpolation ${smooth ? 'off' : 'on'}`}\n                          onClick={() => setSmooth(previous => !previous)}\n                          // If there are PBC residues then forbid the smooth to prevent misleads\n                          // Note that the smoothing may result in artifacts for those atoms jumping across boundaries\n                          // This is very clear for solvent/counter ions (breathing effect) and also visible in membrane residues\n                          disabled={hasPbcResidues}\n                          size=\"large\"\n                        >\n                          <FontAwesomeIcon icon={smooth ? faImages : faVideo} />\n                        </IconButton>\n                      </div>\n                    )}\n\n                    <IconButton\n                      title=\"Invert background color\"\n                      onClick={() => {\n                        toggleDarkBackground();\n                        setAsync('dark-background', !darkBackground);\n                      }}\n                      size=\"large\"\n                    >\n                      <div\n                        className={cn(style['background-toggle'], {\n                          [style.dark]: darkBackground,\n                        })}\n                      >\n                        <FontAwesomeIcon icon={faAdjust} />\n                      </div>\n                    </IconButton>\n\n                    <IconButton\n                      title={`Switch to ${\n                        perspective ? 'ortographic' : 'perspective'\n                      } view`}\n                      onClick={() => {\n                        togglePerspective();\n                        setAsync('perspective', !perspective);\n                      }}\n                      size=\"large\"\n                    >\n                      <FontAwesomeIcon icon={perspective ? faSquare : faCube} />\n                    </IconButton>\n\n                    <IconButton\n                      title={`Switch viwer to ${\n                        Viewer === NGLViewer ? 'MolStar' : 'NGL'\n                      }`}\n                      onClick={() => {\n                        setViewer(currentViewer => {\n                          if (currentViewer === NGLViewer) return MolstarViewer;\n                          if (currentViewer === MolstarViewer) return NGLViewer;\n                          throw new Error('Unrecognized current viewer');\n                        });\n                      }}\n                      size=\"large\"\n                    >\n                      <FontAwesomeIcon\n                        icon={Viewer === NGLViewer ? faStarOfLife : faShareAlt}\n                      />\n                    </IconButton>\n                  </div>\n                  {noTrajectory || (\n                    <div>\n                      Speed:\n                      <Grid\n                        container\n                        spacing={2}\n                        className={style['extra-top-margin']}\n                      >\n                        <Grid item>\n                          <Icon>\n                            <FontAwesomeIcon icon={faWalking} />\n                          </Icon>\n                        </Grid>\n                        <Grid item xs>\n                          <Slider\n                            title=\"Change player speed\"\n                            value={speed}\n                            aria-labelledby=\"continuous-slider\"\n                            onChange={(_, value) => {\n                              setSpeed(value);\n                              setAsync('speed', value);\n                            }}\n                          />\n                        </Grid>\n                        <Grid item>\n                          <Icon>\n                            <FontAwesomeIcon icon={faBiking} />\n                          </Icon>\n                        </Grid>\n                      </Grid>\n                    </div>\n                  )}\n                  {noTrajectory || (\n                    <div>\n                      Frames:\n                      {framesSelect ? (\n                        <Slider\n                          title=\"Select frame number\"\n                          value={requestedFramesNumber}\n                          onChange={(_, value) =>\n                            setRequestedFramesNumber(value)\n                          }\n                          aria-labelledby=\"discrete-slider-restrict\"\n                          step={null}\n                          valueLabelDisplay=\"auto\"\n                          marks={frameNumbers}\n                          max={frameNumbers[frameNumbers.length - 1].value}\n                        />\n                      ) : (\n                        // DANI: Esto puede que no est bien. Deberan ser 20 frames cuando es una PCA projection\n                        ' ' + viewerRef.current.totalExpectedFrames\n                      )}\n                    </div>\n                  )}\n                </div>\n              )}\n            </Card>\n            {settings && (\n              <div className={style['settings-right']}>\n                <RepresentationsManager\n                  components={finalComponents}\n                  representations={finalRepresentations}\n                  setRepresentations={setFinalRepresentations}\n                />\n              </div>\n            )}\n          </Card>\n          <CardContent style={{ padding: 0 }}>\n            {noTrajectory\n              // Render an empty div to avoid a Warning message since CardContent expect a ReactNode and an undefuned is not\n              ? (<div />)\n              // Render the loading/progress bar in case there is a trajectory to be loaded\n              : (<div className={style.progressContainer}>\n                  <div\n                    className={cn(style.progress, { [style.dark]: darkBackground })}\n                    onClick={handleManualProgress}\n                    onMouseMove={handleManualProgress}\n                  >\n                    <LinearProgress\n                      variant=\"buffer\"\n                      color=\"primary\"\n                      value={progress * 100}\n                      valueBuffer={load * 100}\n                      style={{ height: '1ch' }}\n                      className=\"prevent-drag\"\n                    />\n                  </div>\n                  {metadata.FRAMESTEP && (\n                    <div className={cn(style.timeInfo, { [style.dark]: darkBackground })}>\n                      Time: {currentFrameInfo.time} / {round2cents(metadata.timeLength)} ns \n                    </div>\n                  )}\n                </div>)\n            }\n            <div className={style.controls}>\n              <div>\n                <IconButton\n                  title=\"Close viewer\"\n                  className={cn({ [style.hidden]: !close })}\n                  disabled={!close}\n                  onClick={close}\n                  size=\"large\"\n                >\n                  <FontAwesomeIcon icon={faTimes} />\n                </IconButton>\n\n                <IconButton\n                  title={nailed ? 'Nailed viewer' : 'Nail viewer'}\n                  className={cn({ [style.hidden]: !nail })}\n                  disabled={!nail || nailed}\n                  onClick={() => {\n                    nail();\n                    toggleNailed();\n                  }}\n                  size=\"large\"\n                >\n                  <div className={style['flip-container']}>\n                    <div\n                      className={cn(style['flip-card-container'], {\n                        [style.flipped]: nailed,\n                      })}\n                    >\n                      <FontAwesomeIcon\n                        className={cn(style['flip-card'], style.front)}\n                        icon={faUnlock}\n                      />\n                      <FontAwesomeIcon\n                        className={cn(style['flip-card'], style.back)}\n                        icon={faLock}\n                      />\n                    </div>\n                  </div>\n                </IconButton>\n              </div>\n              <div>\n                {noTrajectory || (\n                  <>\n                    <IconButton\n                      title=\"Previous frame\"\n                      onClick={handlePreviousFrame}\n                      size=\"large\"\n                    >\n                      <FontAwesomeIcon icon={faStepBackward} />\n                    </IconButton>\n                    <IconButton\n                      title={playing ? 'Pause' : 'Play'}\n                      onClick={togglePlaying}\n                      size=\"large\"\n                    >\n                      <div className={style['flip-container']}>\n                        <div\n                          className={cn(style['flip-card-container'], {\n                            [style.flipped]: playing,\n                          })}\n                        >\n                          <FontAwesomeIcon\n                            className={cn(style['flip-card'], style.front)}\n                            icon={faPlay}\n                          />\n                          <FontAwesomeIcon\n                            className={cn(style['flip-card'], style.back)}\n                            icon={faPause}\n                          />\n                        </div>\n                      </div>\n                    </IconButton>\n                    <IconButton\n                      title=\"Next frame\"\n                      onClick={handleNextFrame}\n                      size=\"large\"\n                    >\n                      <FontAwesomeIcon icon={faStepForward} />\n                    </IconButton>\n                  </>\n                )}\n              </div>\n              <div>\n                <IconButton\n                  title={`${isFullscreen ? 'Exit' : 'Go'} fullscreen`}\n                  onClick={handlerFullscreenButton}\n                  className={cn(style['fullscreen-toggle'], {\n                    [style.hidden]: !screenfull.isEnabled,\n                    [style['is-fullscreen']]: isFullscreen,\n                    [style['settings']]: settings,\n                  })}\n                  disabled={!screenfull.isEnabled}\n                  size=\"large\"\n                >\n                  <FontAwesomeIcon\n                    icon={isFullscreen ? faCompress : faExpand}\n                  />\n                </IconButton>\n                <IconButton\n                  title={'Settings'}\n                  onClick={() => {\n                    openSettings(previous => !previous);\n                    viewerRef.current.autoResize();\n                  }}\n                  size=\"large\"\n                >\n                  <FontAwesomeIcon icon={faCog} />\n                </IconButton>\n              </div>\n            </div>\n          </CardContent>\n        </div>\n      </Card>\n    );\n  },\n);\n\nViewerWithControls.displayName = 'ViewerWithControls'\nexport default ViewerWithControls;\n"],"names":["setTooltipPosition","parent","tooltip","reference","offset","arguments","length","undefined","limits","getBoundingClientRect","size","x","Math","abs","left","right","y","top","bottom","NGL_DRAWING_METHODS","label","value","NGL_COLORING_METHODS","NGL_COLORS","DrawingMethodExists","opt","memo","_ref","components","representations","setRepresentations","_jsx","_Fragment","children","_jsxs","Table","padding","stickyHeader","TableHead","TableRow","TableCell","align","style","whiteSpace","Info","href","target","rel","className","TableBody","map","representation","index","component","scope","name","IconButton","title","onClick","previousRepresentations","show","color","FontAwesomeIcon","icon","faEye","faEyeSlash","TextField","defaultValue","selection","variant","onKeyPress","event","key","disabled","custom","margin","Select","native","type","onChange","_ref2","cm","i","_ref3","customScheme","word","toUpperCase","slice","Slider","opacity","_","colSpan","Chip","faPlusCircle","KEY","concat","get","storedValue","localStorage","getItem","JSON","parse","setAsync","async","schedule","set","setItem","stringify","TrajectoryFromCustomData","StateTransformer","builderFactory","CreateTransformer","display","from","PluginStateObject","Root","to","Molecule","Coordinates","params","data","PD","Value","Uint8Array","isHidden","natoms","apply","Task","create","Error","frameSize","coordSize","byteLength","nframes","coordinates","Float32Array","frameCoordinates","count","frame","x_coords","y_coords","z_coords","atom","push","z","elementCount","time","Time","xyzOrdering","isIdentity","molstarCoords","customParse","molstarSpec","DefaultPluginUISpec","layout","initial","isExpanded","controlsDisplay","showControls","controls","remoteState","defaultHighlightTypes","atoms","residues","chains","selections","MolstarViewer","forwardRef","ref","playing","spinning","smooth","onProgress","bounce","selectedAtoms","selectedResidueIndices","selectedChains","selectedCustom","selectedDistances","selectedAngles","selectedRepresentation","snapRepresentations","noTrajectory","initialFocus","darkBackground","perspective","speed","drawingMethods","coloringMethods","opacities","showRepresentations","nglSelections","topologies","trajectories","anyLoadingTopology","anyLoadingTrajectory","highlightTypes","comps","useMemo","metadata","topology","topologyManager","useContext","ProjectCtx","focus","setFocus","useState","useEffect","parentRef","useRef","containerRef","stageRef","tooltipRef","inViewRef","isInView","useInView","tooltipContent","setTooltipContent","molstar","setMolstar","molstarInstance","createPluginUI","current","wrap","dispose","modelReference","setModelReference","forEach","builders","rawData","file","state","isGhost","trajectory","structure","parseTrajectory","model","createModel","trajectoryAtoms","trajectoryFinalExpectedFrames","frames","payload","bytesPerFrame","BYTES_PER_COORDINATE","fitLength","floor","totalPayload","totalFrames","coords","build","toRoot","commit","loadedTrajectories","managers","hierarchy","molstarTrajectory","TrajectoryFromModelAndCoordinates","modelRef","coordinatesRef","dependsOn","newModel","createStructure","lightRepresentation","createStructureRepresentationParams","typeParams","quality","ignoreHydrogens","ignoreHydrogensVariant","ignoreLight","StateTransforms","Representation","StructureRepresentation3D","animation","play","AnimateModelIndex","duration","maxFps","mode","direction","stop","handleResize","useCallback","canvas","querySelector","height","cursor","sleep","window","addEventListener","removeEventListener","useImperativeHandle","autoResize","displayFocus","orientation","viewerControls","getOrientation","stringifiedArray","elements","toString","console","log","centerFocus","comp","sele","currentFrame","compList","trajList","total","this","setFrame","totalExpectedFrames","expectedFrames","node","cn","payloadToNGLCoordinates","trajectoryData","trajectoryFrames","trajectoryCoordinates","overallCoordinates","subarray","error","payloadToNGLCoordinatesFiltered","atomCount","atomIndices","expectedAtomNumber","k","j","indexOf","e","payloadToNGLCoordinatesAlternative","pdbFile","format","backboneAtoms","heavyAtoms","a","getAtomProxy","atomname","element","DEFAULT_ORIENTATION_TRANSITION_DURATION","CHAIN_SELECTION","interpolateSpeed","currentSpeed","NGLViewer","xSelection","rotateX","xAxisStep","curatedOrientation","ori","ORIENTATION","sortedOrientation","Matrix4","mainComponent","setMainComponent","mainNglFile","setMainNglFile","firstTime","parsedTopologies","setParsedTopologies","alreadyParsedTopologies","Set","url","add","stringBlob","Blob","autoLoad","defaultRepresentation","ext","then","prasedFile","newParsedTopology","_objectSpread","previous","catch","previousParsedTopologies","runningTasks","setRunningTasks","handleTasksChange","stage","Stage","tasks","signals","countChanged","viewerLogs","beginning","Date","now","currentTick","round","padStart","repeat","viewer","setBackground","setCamera","frameCount","frameHandler","progress","clamp","frameChanged","remove","c","stageComp","find","stc","myName","urlpath","topologyURL","atomStore","occupancy","Array","fill","safeBonds","atomBonds","bondStore","atomIndex1","Int32Array","atomIndex2","bondOrder","bondedAtomsIndices","atomIndex","atom1","bondedAtomIndex","atom2","addBond","componentObject","cloneDeep","addComponentFromObject","onlyTopology","componentRepresentations","filter","rep","registredNames","r","customColorScheme","colorScheme","ColormakerRegistry","addSelectionScheme","colorName","s","Option","isValidColor","colorDomain","surfaceType","depthWrite","parameters","side","other","previousRepresentation","reprList","previousType","repr","previousSelection","string","removeRepresentation","addRepresentation","setParameters","labelName","annotationList","annotation","elm","document","createElement","innerText","backgroundColor","center","structureView","addAnnotation","removeAnnotation","charAt","registredName","nameHighlight","previousHighlightRepresentation","nameContextHighlight","previousContextRepresentation","seleHighlight","join","scale","otherResidueAtomsSelection","getAtomByIndex","residue","residueNglSelections","residueIndex","getResidueByIndex","nglSelection","overallNglSelection","currentRepresentations","snapRepresentation","previousSnapRepresentation","currentRepresentation","atomPair","labelUnit","labelColor","previousComponent","removeComponent","rotationGroup","rotateY","shape","Shape","radialSegments","boxCenter","object","bBox","boundingBox","addBox","max","min","roughness","atomTriple","topologyUrlpath","trajectoryPayloads","combinedURL","combinedProgress","framedUrlpath","framedURLs","fitPayload","sameTrajectory","removeTrajectory","bind","reduce","cb","nb","appendBuffer","lastFrameIndex","completedTrajectory","trajectoryAtomIndices","compTrajectories","nglFile","nglTrajectory","updateNGLFile","currentFrames","discardBytes","newTrajectoryData","newTrajectoryFrames","_frameCount","nglPlayer","player","timeout","end","interpolateStep","isRunning","_currentFrame","setNGLFile","sampleFrame","Frames","addTrajectory","goToNextFrame","haltedRunning","pause","spinAnimation","paused","toggleSpin","interpolateType","cancel","handler","detail","eventtype","highlight","manager","querySelectorAll","thisHiglight","attributeValues","chain","attributes","start","split","sourceStart","getResidueByParameters","sourceEnd","chainName","number","substr","previousStructureRepresentation","animationControls","orient","colorSchemeID","autoView","appendChild","mouseControls","formatOutput","metadataChainName","referenceId","resname","referenceData","referenceName","referenceType","referenceNumber","hideTooltip","clearTimeout","hovered","pickingProxy","setTimeout","description","bond","mouse","position","firstFocus","transition","drawMesh","color_offset","disableImpostor","colors","v","addMesh","displayName","frameRangeFormat","_wrapRegExp","step","useViewerData","requestedFramesNumber","onLoad","accessionAndMdNumber","fileDescriptors","structureData","requestedTopologies","setRequestedTopologies","setAnyLoadingTopology","previousRequestedTopologies","newRequestedTopologies","atomSelection","loading","atomindices","requested","setTopologies","currentRequests","source","previousTopologies","postData","protocol","BASE_PATH_PROJECTS","substring","https","http","actualUrl","requestOptions","urlParse","isStructureEndpoint","path","endsWith","method","headers","request","response","responseContent","on","chunk","anyLoading","some","t","write","requestedTrajectories","setRequestedTrajectories","setAnyLoadingTrajectory","currentTrajectories","newTrajectories","isPrincipal","requestedFrame","urlpaths","trajectoryURLs","u","framed","frameRange","parsed","exec","groups","parseFrameRange","trajectoryFilename","trajectoryFileDescriptor","filename","trajectoryMetadata","requestedFrames","Number","isFinite","returnedFrames","finalUrlpath","maximumFrames","ceil","range","framesRange","framesCount","getFrames","frameStep","setTrajectories","requestPathsteps","pathname","isTrajectoryEndpoint","totalBytes","previousTrajectories","ArrayBuffer","byteCount","currentTrajectory","traj","redundantList","abort","mainComponentTrajectoryURLs","mainTrajectories","overallFrames","b","overallProgress","LOW","Symbol","MEDIUM","HIGH","connectionLevel","navigator","connection","effectiveType","saveData","DEFAULT_STARTS_PLAYING","reducedMotion","innerWidth","DEFAULT_FRAME_NUMBER","DEFAULT_FRAME_NUMBERS","DEFAULT_COMPONENT_PARAMETERS","DEFAULT_REPRESENTATION_PARAMETERS","completeMissingFields","targetObject","defaultValuesObject","anyChange","fieldName","Object","entries","ViewerWithControls","startingComponents","startingRepresentations","componentsState","representationsState","startsPlaying","close","nail","framesSelect","preventTrajectory","props","_objectWithoutProperties","_excluded","Viewer","setViewer","currentFrameInfo","setCurrentFrameInfo","frameNumbers","maximumSnapshots","mdFrames","pop","fixedStartingComponents","copyObject","finalComponents","setFinalComponents","completeComponentMissingFields","defaults","defComponents","componentNames","uniqueComponentNames","fixedStartingRepresentations","finalRepresentations","setFinalRepresentations","defaultRepresentations","completeRepresentationMissingFields","defRepresentations","viewerRef","nailed","toggleNailed","useToggleState","togglePlaying","toggleSpinning","setSmooth","toggleDarkBackground","togglePerspective","setProgress","load","setLoad","isFullscreen","setIsFullscreen","screenfull","setRequestedFramesNumber","setSpeed","settings","openSettings","handleProgress","prog","timeInNs","FRAMESTEP","timeLength","toFixed","originalPushState","history","pushState","originalReplaceState","replaceState","handleLoad","handleManualProgress","buttons","clientX","currentTarget","width","handleFrameChange","handlePreviousFrame","handleNextFrame","handleFullscreenChange","handlerFullscreenButton","handleKeyPress","tagName","preventDefault","prev","hasPbcResidues","pbcResidues","every","acc","has","Card","border","boxShadow","id","faSyncAlt","shiftKey","ctrlKey","metaKey","faDotCircle","faImages","faVideo","faAdjust","faSquare","faCube","currentViewer","faStarOfLife","faShareAlt","Grid","container","spacing","item","Icon","faWalking","xs","faBiking","valueLabelDisplay","marks","RepresentationsManager","CardContent","onMouseMove","LinearProgress","valueBuffer","round2cents","faTimes","faUnlock","faLock","faStepBackward","faPlay","faPause","faStepForward","faCompress","faExpand","faCog"],"ignoreList":[],"sourceRoot":""}