{"version":3,"file":"static/js/942.a38ff42d.chunk.js","mappings":"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","sources":["webpack://mdposit/./src/components/interaction-selector/style.module.css?5392","components/interaction-selector/index.js","webpack://mdposit/./src/components/viewer-spawner/style.module.css?df6e","components/viewer-spawner/index.js","pages/accession/dist-perres/index.js","webpack://mdposit/./src/pages/accession/dist-perres/style.module.css?77de","hooks/use-remfo/index.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"horizontal\":\"style_horizontal__2DIWx\",\"horizontal-margined\":\"style_horizontal-margined__e9fQR\"};","import React, { Suspense } from 'react';\n\nimport {\n  FormControlLabel,\n  Radio,\n  RadioGroup,\n  Select,\n  MenuItem,\n  TextField,\n  IconButton,\n} from '@mui/material';\n\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faExchangeAlt } from '@fortawesome/free-solid-svg-icons';\n\nimport Loading from '../loading';\n\nimport style from './style.module.css';\n\nconst residueOptions = [\n  { label: 'All residues', value: 'residue_indices' },\n  { label: 'Interface residues', value: 'interface_indices' },\n];\n\n// Render a panel which allows to select the desired interaction\n// If the user selects a new interaction then the 'setSelectedInteraction' is set as its index\n// Interactions have the following structure:\n// { name: string, label: string, ... }\n// The 'label' field will replace the 'name' in the selector labels if exists\n// When 'selectedResidues' is passed, render also tools to select interaction residues\n// Residue options are 'all' or 'interface' residues\n// DANI: La guinda sería un 'custom' en las opciones de residuos\n// DANI: La idea sería desplegar dos residue selectors, uno para cada interaction agent\nconst InteractionSelector = ({\n  interactions,\n  selectedInteraction,\n  setSelectedInteraction,\n  selectedResidues,\n  setSelectedResidues,\n  selectedOrder,\n  handleToggleOrder,\n  firstOrderLabel, // The label to be represented over the first order rectangle\n  firstOrderTooltip, // The tooltip to be shown for the first order rectangle\n  secondOrderLabel, // The label to be represented over the second order rectangle\n  secondOrderTooltip, // The tooltip to be shown for the second order rectangle\n  toggleOrderTooltip, // The tooltip to be shown for the toggle order button\n  interfaceOnly = false, // Set if the 'All residues' button is enabled\n}) => {\n  const changeInteraction = event => {\n    setSelectedInteraction(event.target.value);\n  };\n\n  const changeResidues = event => {\n    setSelectedResidues(event.target.value);\n  };\n\n  const changeOrder = () => {\n    handleToggleOrder();\n  };\n\n  const currentInteraction = interactions[selectedInteraction];\n\n  // Render\n  return (\n    <Suspense fallback={<Loading />}>\n      <Select\n        value={selectedInteraction}\n        onChange={changeInteraction}\n        className={style['horizontal-margined']}\n      >\n        {interactions.map((interaction, i) => (\n          <MenuItem key={i} value={i} disabled={interaction.failed}>\n            {interaction.label || interaction.name}\n          </MenuItem>\n        ))}\n      </Select>\n      {selectedResidues && (\n        <RadioGroup\n          value={selectedResidues}\n          onChange={changeResidues}\n          className={style.horizontal}\n        >\n          {residueOptions.map((opt, i) => (\n            <FormControlLabel\n              key={i}\n              value={opt.value}\n              control={<Radio color=\"primary\" />}\n              label={opt.label}\n              disabled={opt.label === 'All residues' && interfaceOnly}\n            />\n          ))}\n        </RadioGroup>\n      )}\n      {selectedOrder !== undefined && (\n        <>\n          <TextField\n            //margin=\"dense\"\n            label={firstOrderLabel}\n            title={firstOrderTooltip}\n            value={\n              selectedOrder\n                ? currentInteraction.agent_1\n                : currentInteraction.agent_2\n            }\n          />\n          <IconButton\n            title={toggleOrderTooltip}\n            onClick={changeOrder}\n            size=\"large\"\n          >\n            <FontAwesomeIcon icon={faExchangeAlt} />\n          </IconButton>\n          <TextField\n            //margin=\"dense\"\n            label={secondOrderLabel}\n            title={secondOrderTooltip}\n            value={\n              selectedOrder\n                ? currentInteraction.agent_2\n                : currentInteraction.agent_1\n            }\n          />\n        </>\n      )}\n    </Suspense>\n  );\n};\n\nexport default InteractionSelector;\n","// extracted by mini-css-extract-plugin\nexport default {\"rnd\":\"style_rnd__Txifm\",\"floating-card\":\"style_floating-card__HHpby\"};","import React, { lazy, Suspense, useRef, useState } from 'react';\n\n// Rnd is the resizable and draggable system where the ngl viewer is placed\nimport { Rnd } from 'react-rnd';\n\nimport Card from '../animated-card';\n\nimport style from './style.module.css';\n\nconst ViewerWithControls = lazy(() =>\n  import(\n    /* webpackChunkName: 'viewer-with-controls' */ '../viewer-with-controls'\n  ),\n);\n\n// Minimal ngl window height\nconst MIN_NGL_DIMENSION = 150;\n\n// Counter to get always the maximum zIndex\n// This is useful to set a new or currently dragged/resized ngl window over the others\nlet maxZ = 0;\nconst nextZ = () => {\n  maxZ += 1;\n  return maxZ;\n};\n\n// This function spawns all the NGL viewers needed\n// i.e. one viewer with the requested 'props' and all previous viewers which have been nailed\nconst ViewerSpawner = ({ newViewer, nailing = true, onNail, onClose }) => {\n  // Store here all nailed NGL viewers\n  const [nailedViewers, setNailedViewers] = useState([]);\n\n  // Set the viewers as the nailed viewers and the new viewer\n  const viewers = [...nailedViewers];\n\n  // Keep listed all arrays which have been used (i.e. ngl viewers which have been nailed or closed)\n  const usedIds = useRef([]);\n\n  if (newViewer) {\n    // Find a new suitable Id that meet 2 conditions:\n    // - There is never 2 viewers with the same id, so we avoid errors\n    // - If we pick diferent frames in the graph without nailing anything, the current viewer has always the same id\n    // (This way the current viewer does not appear in the origin position every time)\n    const getNewId = () => {\n      let id = 0;\n      while (id < 999) {\n        if (usedIds.current.indexOf(id) === -1) return id;\n        id += 1;\n      }\n      console.error('Maximum number of viewers reached');\n    };\n\n    // Set a unique id for this props based in the last nailed viewer\n    newViewer.id = getNewId();\n    newViewer.close = () => {\n      if (nailing) {\n        setNailedViewers(nailed => {\n          const newNailed = [...nailed];\n          const index = nailed.indexOf(newViewer);\n          if (index !== -1) newNailed.splice(index, 1);\n          return newNailed;\n        });\n      }\n      if (onClose) onClose(newViewer);\n      usedIds.current.push(newViewer.id);\n    };\n    // If the nailer function is passed, add the logic for the viewer to be nailed further\n    if (nailing)\n      newViewer.nail = () => {\n        setNailedViewers(nailed => [...nailed, newViewer]);\n        if (onNail) onNail(newViewer);\n        usedIds.current.push(newViewer.id);\n      };\n    // Add the current viewer to the viewers list\n    viewers.push(newViewer);\n  }\n\n  // Render a viewer for each prop. Use the 'selected' parameter as unique id\n  return viewers.map(viewer => <NGLViewerInDND key={viewer.id} {...viewer} />);\n};\n\n// This component render a small NGL viewer\n// It is called when user clicks in a point in the projections component\n// Also it is called by the generic analysis page\nconst NGLViewerInDND = props => {\n  // Set a reference for the viewer\n  // If a reference is passed among the viewer arguments then use it instead\n  const viewerRef = props.viewerRef || useRef(null);\n\n  // Set the default position and size\n  const [place, setPlace] = useState(() => {\n    // Set an extra margin\n    const MARGIN = 20;\n    // Get the screen pixel sizes and vertical scroll position\n    const { innerWidth, innerHeight, scrollY } = window;\n    // The spawned elements are parented to the 'main' element, not to the 'body'\n    // We have to take this in count, since the header adds an extra offset in vertical position\n    const offsetHeight = document.querySelector('main').offsetTop;\n    // Set a reasonable dimension for the ngl window\n    const dimension = Math.max(\n      Math.min(innerWidth / 4, innerHeight / 4),\n      MIN_NGL_DIMENSION,\n    );\n    const reasonableHeight = 1.5 * dimension;\n    const reasonableWidth = 2 * dimension;\n    return {\n      // WARNING: If you set the width as 'auto' the window stays very wide when exiting fullscreen\n      width: reasonableWidth, // Let the Rnd logic set the width automatically\n      height: reasonableHeight, // Reasonable height\n      x: 0, // Left border\n      y: innerHeight - offsetHeight - reasonableHeight - MARGIN + scrollY, // Bottom border\n    };\n  });\n\n  return (\n    // Rnd is the draggable and resizable system where the ngl viewer is placed\n    <Rnd\n      position={{ x: place.x, y: place.y }}\n      size={{ width: place.width, height: place.height }}\n      // Update the zIndex to make this window the first visible\n      style={{ zIndex: nextZ() }}\n      className={style.rnd}\n      data-rnd\n      // Limits where the window can be dragged/resized to\n      // WARNING: bounds=\"main\" is problematic since the window may appear out of bounds\n      // WARNING: Then when it is moved for the first time it jumps inside the bonds, not elegant\n      bounds=\"window\"\n      // Prevent the mouse to drag/resize the window when it is over specific elements\n      cancel=\"canvas, [data-popover], #preventDragSize, .prevent-drag\"\n      // On drag/resize starts we do not change anything, but use the hook to re-render this component\n      // The Z Index is updated and the selected window becomes the first in the z axis automatically\n      // WARNING: Drag functions are also called when you just click (e.g. clicking buttons)\n      onDragStart={() => {\n        setPlace({ ...place });\n      }}\n      onResizeStart={() => {\n        setPlace({ ...place });\n      }}\n      onDragStop={(e, d) => {\n        // Use this to reject some bugged event calls: e.g. the frames number selector\n        if (e.layerX === 0 && e.layerY === 0) return;\n        // We re-render only if the new position does not equal the old position\n        if (place.x !== d.x || place.y !== d.y)\n          setPlace({\n            ...place,\n            x: d.x,\n            y: d.y,\n          });\n      }}\n      // Re-adapt the viewer and update the position/size when the window is resized\n      onResize={() => viewerRef.current && viewerRef.current.autoResize()}\n      onResizeStop={(e, direction, ref, delta, position) => {\n        setPlace({\n          width: ref.style.width,\n          height: ref.style.height,\n          ...position,\n        });\n        // if (!viewerRef.current) return;\n        // viewerRef.current.autoResize();\n        // viewerRef.current.autoResize.flush();\n      }}\n    >\n      <Card className={style['floating-card']} elevation={4}>\n        <Suspense fallback={null}>\n          <ViewerWithControls\n            className={style['floating-card']}\n            ref={viewerRef}\n            startsPlaying={false}\n            {...props}\n          />\n        </Suspense>\n      </Card>\n    </Rnd>\n  );\n};\n\nexport default ViewerSpawner;\n","import React, { useContext, useState, useMemo, useCallback } from 'react';\n// Import Material UI components\nimport { CardContent, Tabs, Tab, Typography } from '@mui/material';\n// Import custom hooks\nimport useAPI from '../../../hooks/use-api';\nimport useRemfo from 'src/hooks/use-remfo';\n// Import custom components\nimport Card from '../../../components/animated-card';\nimport Loading from '../../../components/loading';\nimport InteractionSelector from '../../../components/interaction-selector';\nimport Heatmap from '../../../components/heatmap';\nimport ViewerSpawner from '../../../components/viewer-spawner';\n// Load context data\nimport { ProjectCtx } from '../../../contexts';\n// Load some constants\nimport { BASE_PATH_PROJECTS } from '../../../utils/constants';\n// Load CSS style\nimport style from './style.module.css';\n\n// Set the heatmap minimum and maximum colors\nconst heatmapMinimumColor = { r: 0, g: 0, b: 255 };\nconst heatmapMaximumColor = { r: 255, g: 0, b: 0 };\n\n// Distance per residue analysis\nconst DistPerres = () => {\n  // Get the current project data\n  const { accessionAndMdNumber, topology, interactions } = useContext(ProjectCtx);\n\n  // Send a request to the API with the url of the analyses index\n  const analysesUrlBase = `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/analyses`;\n  const indexUrl = `${analysesUrlBase}/dist-perres`;\n  const { loading: indexLoading, payload: indexPayload, error: indexError } = useAPI(indexUrl);\n\n  // The interaction to be displayed\n  const [selectedInteraction, setSelectedInteraction] = useState(0);\n\n  // The newest format has 4 fields: acceptors, donors, hydrogens and hbonds\n  // The hbonds includes arrays of true and false per frame\n  const interaction = interactions && interactions[selectedInteraction];\n\n  // Get analysis data from the API\n  // Set the target interaction name\n  const { interactionName, analysisName } = useMemo(() => {\n    // Wait for main data to be downloaded\n    if (!interaction || !indexPayload) return {};\n    // Check if the analysis is in the old or the new format\n    const isOld = indexPayload.data !== undefined;\n    // If so, there is no target analysis name, but the whole data is already in the payload\n    if (isOld) return { interactionName: interaction.name };\n    const targetEntry = indexPayload.find(entry => entry.name === interaction.name);\n    return { interactionName: interaction.name, analysisName: targetEntry.analysis }\n  }, [interaction, indexPayload]);\n\n  // Send a request to the API with the url of some specific analysis\n  const interactionAnalysisUrl = analysisName ? `${analysesUrlBase}/${analysisName}` : null;\n  const { loading, payload, error } = useAPI(interactionAnalysisUrl);\n\n  // Now set the actual dataset to be used\n  // Note that this is a compatibility layer between the old and the new system\n  const dataset = useRemfo(previous => {\n    // Wait for the download to finish\n    if (!indexPayload) return previous;\n    // Check if the analysis is in the old or the new format\n    const isOld = indexPayload.data !== undefined;\n    // If this is the new system then the dataset is the payload itself\n    if (!isOld) {\n      if (!payload) return previous;\n      return payload;\n    }\n    // If this is the old system then the dataset is in the index payload\n    const interactionData = indexPayload.data.find(entry => entry.name === interactionName);\n    if (!interactionData) return { error: `Dataset for interaction \"${interactionName}\" not found` };\n    return interactionData;\n  }, [indexPayload, payload, interactionName]);\n\n  // The interaction residues to be displayed\n  // May be all 'residue_indices' or only the 'interface_indices'\n  const [selectedResidues, setSelectedResidues] = useState('interface_indices');\n\n  // The graphic to be displayed ('mean' or 'stdv')\n  const [display, setDisplay] = useState('mean');\n\n  // Filter data by selected residues\n  const {\n    heatmapData,\n    residuesX,\n    residuesY,\n    xTitle,\n    yTitle,\n    isReduced,\n  } = useMemo(() => {\n    // Return if the dataset is not ready\n    if (!dataset || !topology) return {};\n\n    // Set the data to be displayed\n    const displayedData = display === 'mean' ? dataset.means : dataset.stdvs;\n\n    // Find out if the analysis contains data for all residues or just the interface residues\n    // It may happen in large interactions that only interface residues are saved in order to reduce data size\n    // WARNING: We must check both data dimensions\n    // WARNING: it may happen that one agent has the same number of total and interface residues\n    let isReduced;\n    const xDim = displayedData[0].length;\n    const yDim = displayedData.length;\n    if (\n      yDim === interaction['residue_indices_2'].length &&\n      xDim === interaction['residue_indices_1'].length\n    )\n      isReduced = false;\n    else if (\n      yDim === interaction['interface_indices_2'].length &&\n      xDim === interaction['interface_indices_1'].length\n    )\n      isReduced = true;\n    else throw new Error(\n      `The numbers of values in data does not match any number of residues in the interaction (neither all or interface)`,\n    );\n\n    // Select the interaction residues whosa data is to be represented in the heatmap\n    const residuesX = interaction[selectedResidues + '_1'];\n    const residuesY = interaction[selectedResidues + '_2'];\n\n    // Set data to be represented in the heatmap\n    let filteredData = [];\n    // If we have a reduced dataset\n    if (isReduced) {\n      // If interface residues are requested then we return the whole dataset\n      if (selectedResidues === 'interface_indices') {\n        filteredData = displayedData;\n      }\n      // If all residues are requested then we must build a new matrix and fill the gaps with 'null' values\n      // WARNING: Although this has been programmed, the button tu do this should be disabled from the client\n      // WARNING: This code is functional but it should never be called or you may run out of memory\n      // WARNING: If you allow to represent a whole heatmap for a reduced analysis you may be trying to build a huge heatmap\n      else {\n        const interfaceResiduesX = interaction['interface_indices_1'];\n        const interfaceResiduesY = interaction['interface_indices_2'];\n        for (const y of residuesY) {\n          const yIndex = interfaceResiduesY.indexOf(y);\n          let newRow;\n          // If the index is not in the interface then the whole row is full of nulls\n          if (yIndex === -1) {\n            const XResiduesCount = residuesX.length;\n            newRow = new Array(XResiduesCount).fill(10);\n            filteredData.push(newRow);\n            continue;\n          }\n          // Otherwise, we must check each column value\n          newRow = [];\n          for (const x of residuesX) {\n            const xIndex = interfaceResiduesX.indexOf(x);\n            if (xIndex === -1) {\n              newRow.push(10);\n              continue;\n            }\n            newRow.push(displayedData[yIndex][xIndex]);\n          }\n          filteredData.push(newRow);\n        }\n      }\n    }\n    // If we have the full dataset\n    else {\n      // If all residues are requested then we return all data\n      if (selectedResidues === 'residue_indices') {\n        filteredData = displayedData;\n      }\n      // If interface residues are requested then we must filter interface resdiues only\n      else {\n        const allResiduesX = interaction['residue_indices_1'];\n        const allResiduesY = interaction['residue_indices_2'];\n        for (const y of residuesY) {\n          const yIndex = allResiduesY.indexOf(y);\n          const newRow = [];\n          for (const x of residuesX) {\n            const xIndex = allResiduesX.indexOf(x);\n            newRow.push(displayedData[yIndex][xIndex]);\n          }\n          filteredData.push(newRow);\n        }\n      }\n    }\n\n    // Convert the residues from topology numeration to standard numeration to use them as labels\n    const [xLabels, yLabels] = [residuesX, residuesY].map(residueIndices =>\n      residueIndices.map(residueIndex => topology.getResidueByIndex(residueIndex).standardLabel),\n    );\n\n    // Get the titles from the interaction data\n    const xTitle = interaction['agent_1'];\n    const yTitle = interaction['agent_2'];\n\n    // Get the object to be passed to the heatmap as input\n    const heatmapData = { data: filteredData, xLabels, yLabels };\n\n    return {\n      heatmapData,\n      residuesX,\n      residuesY,\n      xTitle,\n      yTitle,\n      isReduced,\n    };\n  }, [\n    dataset,\n    topology,\n    selectedResidues,\n    display,\n  ]);\n\n  // Transform the raw reside tag to source numeration\n  // Also retrieve the residue index, since it is used to ask for the distance representation\n  // http://nglviewer.org/ngl/api/class/src/representation/distance-representation.js~DistanceRepresentation.html\n  const parseResidue = useCallback(\n    residueIndex => {\n      // Set the numeration\n      const residue = topology.getResidueByIndex(residueIndex);\n      return {\n        forResidue: residueIndex,\n        // We must check the residue has an alpha carbon\n        // If not, there is no atom to use a distance reference, so return null\n        forDistance: residue.hasCAlpha\n          ? residue.number.toString() + ':' + residue.chainName + '.CA'\n          : null,\n      };\n    },\n    [topology],\n  );\n\n  // The selected heatmap residues\n  const [selected, setSelected] = useState(null);\n\n  // Memoize heatmap handler functions\n  const handleHeatmapTooltip = useCallback(\n    ({ value, xAxisValue, yAxisValue }) =>\n      xAxisValue +\n      ' - ' +\n      yAxisValue +\n      '\\n' +\n      Math.round(value * 100) / 100 +\n      ' Å',\n    [],\n  );\n  const handleHeatmapClick = useCallback(\n    ({ xIndex, yIndex }) => {\n      const px = parseResidue(residuesX[xIndex]);\n      const py = parseResidue(residuesY[yIndex]);\n      setSelected({\n        residues: [px.forResidue, py.forResidue],\n        // There is no values \"for distance\" when any residues has no alpha carbon\n        distance: px.forDistance &&\n          py.forDistance && [[px.forDistance, py.forDistance]],\n      });\n    },\n    [residuesX, residuesY, parseResidue],\n  );\n\n  // Render loading or error messages according with the API response\n  if (indexError) return indexError.toString();\n  if (error) return error.toString();\n  if (dataset && dataset.error) return dataset.error;\n  if (!dataset) {\n    if (indexLoading || loading) return <Loading />;\n    if (!interactions) return 'There are no interactions';\n    if (!topology) return 'There is no topology';\n    return 'Something bad happened with the analysis data';\n  }\n\n  // Handles when the tabs are switched\n  const handleTabs = (event, newValue) => {\n    setDisplay(newValue);\n  };\n\n  // Render\n  return (\n    <>\n      <Card>\n        <CardContent className={style.horizontal}>\n          <Typography variant=\"h6\">Residues selection:</Typography>\n          <InteractionSelector\n            interactions={interactions}\n            selectedInteraction={selectedInteraction}\n            setSelectedInteraction={setSelectedInteraction}\n            selectedResidues={selectedResidues}\n            setSelectedResidues={setSelectedResidues}\n            interfaceOnly={isReduced}\n          />\n        </CardContent>\n      </Card>\n      <div className={indexLoading || loading ? style.disabled : style.enabled}>\n        <Card className={style.margined} id=\"heatmap\">\n          <CardContent>\n            <Tabs\n              value={display}\n              variant=\"fullWidth\"\n              indicatorColor=\"primary\"\n              textColor=\"primary\"\n              onChange={handleTabs}\n              className={style['margined-bottom']}\n            >\n              <Tab\n                value={'mean'}\n                label=\"Residues distance averages\"\n                //className={style['disabled-tab']}\n              />\n              <Tab value={'stdv'} label=\"Residues distance standard deviations\" />\n            </Tabs>\n            <Heatmap\n              inputData={heatmapData}\n              onTooltip={handleHeatmapTooltip}\n              onClick={handleHeatmapClick}\n              legendTitle={\n                display === 'mean'\n                  ? 'Distance average (Å)'\n                  : 'Distance standard deviation (Å)'\n              }\n              // Invert colors here, since minimum values belong to closer residues\n              maxValueColor={heatmapMinimumColor}\n              minValueColor={heatmapMaximumColor}\n              totalHeight={heatmapData.yLabels.length === 1 ? 30 : undefined}\n              xTitle={xTitle}\n              yTitle={yTitle}\n            />\n          </CardContent>\n        </Card>\n      </div>\n      \n      <ViewerSpawner\n        // Set the new viewer or null if there is not a proper \"selected\" value\n        newViewer={\n          selected\n            ? {\n                selectedResidueIndices: selected.residues,\n                // WARNING: Distance is not always available\n                // This only works when both residues have alpha carbon\n                // (i.e. both are protein residues)\n                selectedDistances: selected.distance,\n              }\n            : null\n        }\n        // If the nailed/closed viewer is the current viewer then reset the 'selected'\n        onNail={viewer =>\n          setSelected(previous => {\n            if (previous && previous.residues === viewer.selectedResidueIndices)\n              return null;\n            else return previous;\n          })\n        }\n        onClose={viewer =>\n          setSelected(previous => {\n            if (previous && previous.residues === viewer.selectedResidueIndices)\n              return null;\n            else return previous;\n          })\n        }\n      />\n    </>\n  );\n};\n\nexport default DistPerres;\n","// extracted by mini-css-extract-plugin\nexport default {\"margined\":\"style_margined__JbZJ6\",\"margined-bottom\":\"style_margined-bottom__WRBwE\",\"horizontal\":\"style_horizontal__NH+ZS\",\"enabled\":\"style_enabled__4JqEL\",\"disabled\":\"style_disabled__39iRt\"};","import { useMemo, useRef } from 'react';\n\n// Get a memoized value just like a useMemo would\n// However you can access the previous memoized value as the first (and only) function argument\nconst useRemfo = (func, deps) => {\n    const previousValue = useRef();\n    const newValue = useMemo(() => func(previousValue.current), deps);\n    previousValue.current = newValue;\n    return newValue;\n};\n\nexport default useRemfo;\n"],"names":["residueOptions","label","value","_ref","interactions","selectedInteraction","setSelectedInteraction","selectedResidues","setSelectedResidues","selectedOrder","handleToggleOrder","firstOrderLabel","firstOrderTooltip","secondOrderLabel","secondOrderTooltip","toggleOrderTooltip","interfaceOnly","currentInteraction","_jsxs","Suspense","fallback","_jsx","Loading","children","Select","onChange","event","target","className","style","map","interaction","i","MenuItem","disabled","failed","name","RadioGroup","opt","FormControlLabel","control","Radio","color","undefined","_Fragment","TextField","title","agent_1","agent_2","IconButton","onClick","changeOrder","size","FontAwesomeIcon","icon","faExchangeAlt","ViewerWithControls","lazy","maxZ","NGLViewerInDND","props","viewerRef","useRef","place","setPlace","useState","innerWidth","innerHeight","scrollY","window","offsetHeight","document","querySelector","offsetTop","dimension","Math","max","min","reasonableHeight","width","height","x","y","Rnd","position","zIndex","bounds","cancel","onDragStart","onResizeStart","onDragStop","e","d","layerX","layerY","onResize","current","autoResize","onResizeStop","direction","ref","delta","Card","elevation","startsPlaying","newViewer","nailing","onNail","onClose","nailedViewers","setNailedViewers","viewers","usedIds","getNewId","id","indexOf","console","error","close","nailed","newNailed","index","splice","push","nail","viewer","heatmapMinimumColor","r","g","b","heatmapMaximumColor","DistPerres","accessionAndMdNumber","topology","useContext","ProjectCtx","analysesUrlBase","BASE_PATH_PROJECTS","indexUrl","loading","indexLoading","payload","indexPayload","indexError","useAPI","interactionName","analysisName","useMemo","data","targetEntry","find","entry","analysis","interactionAnalysisUrl","dataset","useRemfo","previous","interactionData","display","setDisplay","heatmapData","residuesX","residuesY","xTitle","yTitle","isReduced","displayedData","means","stdvs","xDim","length","yDim","Error","filteredData","interfaceResiduesX","interfaceResiduesY","yIndex","newRow","XResiduesCount","Array","fill","xIndex","allResiduesX","allResiduesY","xLabels","yLabels","residueIndices","residueIndex","getResidueByIndex","standardLabel","parseResidue","useCallback","residue","forResidue","forDistance","hasCAlpha","number","toString","chainName","selected","setSelected","handleHeatmapTooltip","xAxisValue","yAxisValue","round","handleHeatmapClick","_ref2","px","py","residues","distance","CardContent","horizontal","Typography","variant","InteractionSelector","enabled","margined","Tabs","indicatorColor","textColor","handleTabs","newValue","Tab","Heatmap","inputData","onTooltip","legendTitle","maxValueColor","minValueColor","totalHeight","ViewerSpawner","selectedResidueIndices","selectedDistances","func","deps","previousValue"],"sourceRoot":""}