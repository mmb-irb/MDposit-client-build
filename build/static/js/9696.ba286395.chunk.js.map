{"version":3,"file":"static/js/9696.ba286395.chunk.js","mappings":"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","sources":["webpack://mdposit/./src/components/animated-card/style.module.css?d4d9","components/animated-card/index.js","../node_modules/@mui/material/Card/cardClasses.js","../node_modules/@mui/material/Card/Card.js","webpack://mdposit/./src/pages/accession/lipid-inter/style.module.css?4f5b","pages/accession/lipid-inter/index.js","webpack://mdposit/./src/components/color-legend/style.module.css?0c39","components/color-legend/index.js","utils/document-measurer/index.js","components/d3-heatmap-grid/index.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"container\":\"style_container__M9GCG\"};","import React, { useLayoutEffect, useRef, forwardRef } from 'react';\nimport { Card } from '@mui/material';\n\nimport reducedMotion from '../../utils/reduced-motion';\n\nimport style from './style.module.css';\n\nconst KEYFRAMES = { opacity: [0, 1] };\n\nif (!reducedMotion()) {\n  KEYFRAMES.transform = ['translateY(50px)', 'translateY(0)'];\n}\n\nconst ANIMATION_OPTIONS = {\n  fill: 'both',\n  easing: 'cubic-bezier(0, .99, .56, 1.1)',\n  duration: 500,\n};\n\n// Make the card appear and slide softly from down to up when the page is loaded\nconst AnimatedCard = forwardRef(({ overrideComponent, ...props }, ref) => {\n  const containerRef = useRef(null);\n\n  useLayoutEffect(() => {\n    const node = containerRef.current && containerRef.current.firstElementChild;\n    if (!(node && node.animate)) return;\n\n    const index = Array.from(\n      document.querySelectorAll('main section'),\n    ).findIndex(section => node === section);\n\n    const animation = node.animate(KEYFRAMES, {\n      ...ANIMATION_OPTIONS,\n      delay: index * 150,\n    });\n\n    return () => animation.cancel();\n  }, []);\n\n  const Component = overrideComponent ? 'section' : Card;\n\n  return (\n    <div ref={containerRef} className={style.container}>\n      <Component component=\"section\" {...props} ref={ref} />\n    </div>\n  );\n});\n\nexport default AnimatedCard;\n","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getCardUtilityClass(slot) {\n  return generateUtilityClass('MuiCard', slot);\n}\nconst cardClasses = generateUtilityClasses('MuiCard', ['root']);\nexport default cardClasses;","'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"className\", \"raised\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport chainPropTypes from '@mui/utils/chainPropTypes';\nimport composeClasses from '@mui/utils/composeClasses';\nimport styled from '../styles/styled';\nimport { useDefaultProps } from '../DefaultPropsProvider';\nimport Paper from '../Paper';\nimport { getCardUtilityClass } from './cardClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root']\n  };\n  return composeClasses(slots, getCardUtilityClass, classes);\n};\nconst CardRoot = styled(Paper, {\n  name: 'MuiCard',\n  slot: 'Root',\n  overridesResolver: (props, styles) => styles.root\n})(() => {\n  return {\n    overflow: 'hidden'\n  };\n});\nconst Card = /*#__PURE__*/React.forwardRef(function Card(inProps, ref) {\n  const props = useDefaultProps({\n    props: inProps,\n    name: 'MuiCard'\n  });\n  const {\n      className,\n      raised = false\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const ownerState = _extends({}, props, {\n    raised\n  });\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(CardRoot, _extends({\n    className: clsx(classes.root, className),\n    elevation: raised ? 8 : undefined,\n    ref: ref,\n    ownerState: ownerState\n  }, other));\n});\nprocess.env.NODE_ENV !== \"production\" ? Card.propTypes /* remove-proptypes */ = {\n  // ┌────────────────────────────── Warning ──────────────────────────────┐\n  // │ These PropTypes are generated from the TypeScript type definitions. │\n  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │\n  // └─────────────────────────────────────────────────────────────────────┘\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * If `true`, the card will use raised styling.\n   * @default false\n   */\n  raised: chainPropTypes(PropTypes.bool, props => {\n    if (props.raised && props.variant === 'outlined') {\n      return new Error('MUI: Combining `raised={true}` with `variant=\"outlined\"` has no effect.');\n    }\n    return null;\n  }),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])\n} : void 0;\nexport default Card;","// extracted by mini-css-extract-plugin\nexport default {\"card\":\"style_card__pEq-k\",\"tabs\":\"style_tabs__HhB5H\",\"nglcard\":\"style_nglcard__3eXUT\",\"container\":\"style_container__eab4U\",\"legend_container\":\"style_legend_container__swfrT\",\"legend\":\"style_legend__SS-DS\"};","import React, { lazy, Suspense, useState, useContext, useMemo, useRef, useEffect } from 'react';\nimport { useInView } from 'react-intersection-observer';\n\nimport {\n  CardContent,\n  Table,\n  TableHead,\n  TableBody,\n  TableRow,\n  TableCell,\n  FormControlLabel,\n  Checkbox,\n  Tabs,\n  Tab,\n  Typography,\n  Slider,\n} from '@mui/material';\n\nimport Card from '../../../components/animated-card';\nimport ViewerWithControls from '../../../components/viewer-with-controls';\nimport Loading from '../../../components/loading';\nimport ColorLegend from '../../../components/color-legend';\n\nimport useAPI from '../../../hooks/use-api';\nimport { ProjectCtx } from '../../../contexts';\nimport { BASE_PATH_PROJECTS } from '../../../utils/constants';\nimport useDefaultRepresentations from '../../../components/ngl-viewer/use-default-representations';\n\nimport style from './style.module.css';\nimport { ColormakerRegistry } from 'ngl';\n\nconst useInViewOptions = { triggerOnce: true, rootMargin: '100px' };\n\nconst LipidInteractions = () => {\n  const { accessionAndMdNumber, metadata, chains  } = useContext(ProjectCtx);\n  const [nglRef, isNglVisible] = useInView(useInViewOptions);\n  const viewerRef = useRef(null);\n\n  // Get the default representations\n  const defaultRepresentations = useDefaultRepresentations();\n\n  // Send a request to the API with the url of the specific analysis\n  const {\n    loading: interactionsLoading,\n    payload: interactionsPayload,\n    error: interactionsError,\n  } = useAPI(`${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/analyses/lipid-inter/`);\n\n  // Get the membrane map\n  const {\n    loading: memMapLoading,\n    payload: memMapPayload,\n    error: memMapError,\n  } = useAPI(`${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/analyses/mem-map/`);\n\n  // Add state for selected lipid type\n  const [selectedLipid, setSelectedLipid] = useState(null);\n  const [representations, setRepresentations] = useState(null);\n  const schemes = useRef({});\n\n  // Get available lipid types for tabs\n  const lipidTypes = useMemo(() => {\n    if (!interactionsPayload || !interactionsPayload.data) return [];\n    return Object.keys(interactionsPayload.data);\n  }, [interactionsPayload]);\n\n  // Set initial selected lipid when data loads\n  useMemo(() => {\n    if (lipidTypes.length && !selectedLipid) {\n      setSelectedLipid(lipidTypes[0]);\n    }\n  }, [lipidTypes, selectedLipid]);\n\n  // Generate a color scheme based on interaction data\n  const generateScheme = (lipidType) => {\n    if (!interactionsPayload || !interactionsPayload.data || !lipidType) return null;\n    const max = Math.max(...interactionsPayload.data[lipidType]);\n    return ColormakerRegistry.addScheme(function (params) {\n      this.atomColor = function (atom) {\n        if (!atom.residueIndex) return 0xcccccc; // Default color if no residue index\n        const residueID = atom.residueIndex;\n        const interactionData = interactionsPayload.data[lipidType];\n        // Check if this residue has interaction data\n        if (interactionData && residueID < interactionData.length) {\n          const value = interactionData[residueID];\n          // If below threshold, make it grey\n          if (value < 0) {\n            return 0xcccccc;\n          }\n            // Create a gradient from white (0xffffff) to dark red (0x800000) through orange\n            // For white -> orange -> dark red transition\n            const normalized = value/max;\n            let red = 255;\n            let green, blue;\n            \n            if (normalized < 0.5) {\n            // White to orange transition (first half)\n            green = 255 - Math.floor(128 * normalized * 2); // Gradually reduce green\n            blue = 255 - Math.floor(255 * normalized * 2);  // Rapidly reduce blue\n            } else {\n            // Orange to dark red transition (second half)\n            green = 127 - Math.floor(127 * (normalized - 0.5) * 2); // Continue reducing green\n            blue = 0; // Blue stays at zero\n            }\n            \n            // Combine into RGB color\n            return (red << 16) | (green << 8) | blue;\n        }\n        \n        return 0xcccccc; // Default color\n      };\n    });\n  };\n\n  // Get or create a scheme for a lipid type\n  const getSchemeForLipid = (lipidType) => {\n    if (!schemes.current[lipidType]) {\n      schemes.current[lipidType] = generateScheme(lipidType);\n    }\n    return schemes.current[lipidType];\n  };\n\n  // Update representations when selection changes\n  useEffect(() => {\n    if (!defaultRepresentations || defaultRepresentations.length === 0 || !selectedLipid) return;\n    \n    const customScheme = getSchemeForLipid(selectedLipid);\n    defaultRepresentations.forEach(rep => {\n\n        if (chains.indexOf(rep.selection.slice(1,2)) !== -1 || rep.name === 'Protein') { \n            rep.color = 'custom';\n            rep.type = 'spacefill';\n            rep.customScheme = customScheme;\n        } else if (rep.name === 'Membrane' || rep.name === 'M') {\n            rep.color = 'orange';\n            rep.opacity = 0.0;\n        }\n        \n    });\n    const lipidRep = {\n      'name': selectedLipid,\n      'type': 'licorice',\n      'color': 'orange',\n      'opacity': 0.3,\n      'selection': `( ${selectedLipid} )`,\n    };\n\n    setRepresentations([...defaultRepresentations, lipidRep]);\n  }, [selectedLipid, defaultRepresentations, memMapPayload]);\n\n  if (interactionsLoading || memMapLoading) return <Loading />;\n  if (interactionsError) return interactionsError.toString();\n  if (memMapError) return memMapError.toString();\n  if (!interactionsPayload || !memMapPayload) return 'Something bad happened with Lipid Interactions analysis';\n\n  return (\n    <Suspense fallback={<Loading />}>\n      <Card className={style.card}>\n        <CardContent>\n          <Tabs\n            value={selectedLipid}\n            variant=\"fullWidth\"\n            indicatorColor=\"primary\"\n            textColor=\"primary\"\n            onChange={(event, value) => {\n              setSelectedLipid(value);\n            }}\n            className={style.tabs}\n          >\n            {lipidTypes.map((lipid) => (\n              <Tab\n                key={lipid}\n                value={lipid}\n                label={\n                  <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>\n                    <span>\n                      {memMapPayload?.references?.[lipid]?.resname || lipid}\n                    </span>\n                    {/* <Typography variant=\"caption\" color=\"text.secondary\">\n                      {memMapPayload?.references?.[lipid]?.lipidmaps?.name || 'Lipid'}\n                    </Typography> */}\n                  </div>\n                }\n              />\n            ))}\n          </Tabs>\n          \n          {/* <div className={style.controls}>\n            <Typography id=\"threshold-slider\" gutterBottom>\n              Interaction Threshold: {threshold}\n            </Typography>\n            <Slider\n              value={threshold}\n              onChange={(e, newValue) => setThreshold(newValue)}\n              aria-labelledby=\"threshold-slider\"\n              step={0.05}\n              marks\n              min={0}\n              max={1}\n              valueLabelDisplay=\"auto\"\n            />\n            \n          </div> */}\n        </CardContent>\n      </Card>\n      \n      {/* <Card className={style.legend_container}>\n        <ColorLegend\n          title={'Lipid Interaction Frequency'}\n          minValue={0}\n          maxValue={1}\n          colorPlan={colorPalette}\n          vertical={true}\n          className={style.legend}\n        />\n      </Card> */}\n      \n      <Card className={style.nglcard} ref={nglRef}>\n        {isNglVisible ? (\n          <ViewerWithControls\n            className={style.container}\n            representationsState={[representations, setRepresentations]}\n            ref={viewerRef}\n            rotateX={true}\n          />\n        ) : (\n          <div style={{ height: '50vh' }} />\n        )}\n      </Card>\n    </Suspense>\n  );\n};\n\nexport default LipidInteractions;\n","// extracted by mini-css-extract-plugin\nexport default {\"horizontal\":\"style_horizontal__KW-k9\",\"vertical\":\"style_vertical__YKrT2\",\"heatmap-horizontal\":\"style_heatmap-horizontal__HjdIF\",\"heatmap-vertical\":\"style_heatmap-vertical__utgJY\"};","import React, { useMemo } from 'react';\n\nimport { CardContent } from '@mui/material';\n\nimport style from './style.module.css';\n\nimport D3HeatmapGrid from '../d3-heatmap-grid';\n\n// Display a color legend using the d3 heatmap\nconst ColorLegend = ({\n  // Title to be rendered over the legend\n  title = '',\n  // Maximum and minimum possible values\n  maxValue = 1,\n  minValue = 0,\n  // Colors to represent the values range from lower to higher (e.g. ['red', 'white', 'blue'])\n  colorPlan,\n  // Number of cells in the legend heatmap (i.e. how many times we split the color bar)\n  splits = 19,\n  // Set if the color bar must be veritcal\n  vertical = false,\n  flip = false,\n  // Allow to force a custom className from the parent component\n  className,\n}) => {\n  // Create a fake 'data' object for the heatmap\n  const { legendData, legendLabels } = useMemo(() => {\n    // Set the legend, which is another heatmap\n    // Make labels for different value regions\n    const values = [];\n    // If the minimum and maximum are the same then there is only one label to show\n    if (minValue === maxValue) values.push(minValue);\n    // Otherwise make the different regions\n    // WARNING: If we have same minimum and maximum values then the logic below will enter in an infinite loop\n    else for (let i = minValue; i <= maxValue; i += (maxValue - minValue) / splits)\n      values.push(i);\n\n    // Round all values\n    let legendLabels = values.map(val => Math.round(val));\n    // If there is more than 1 label then the make sure all of them are unique\n    // WARNING: If we have a single label  the logic below will enter in an infinite loop\n    if (legendLabels.length > 1)\n      // If there are repeated labels then we round to the next 10 fold lower scale until there are no more duplicates\n      for (let decimal = 1; new Set(legendLabels).size < legendLabels.length; decimal++) {\n        legendLabels = values.map(val => Math.round(val * 10 ** decimal) / 10 ** decimal);\n      }\n\n    // Data must be an array inside an array\n    const legendData = vertical ? values.map(v => [v]) : [values];\n    if (flip) {\n      // Flip the legend data array\n      legendData.reverse();\n      legendLabels.reverse();\n    }\n\n    return { legendData, legendLabels };\n  }, [maxValue, minValue, splits, vertical]);\n\n  // Render\n  return (\n    <CardContent\n      className={\n        className ? className : vertical ? style.vertical : style.horizontal\n      }\n    >\n      {title}\n      <D3HeatmapGrid\n        data={legendData}\n        xAxisValues={vertical ? [''] : legendLabels}\n        yAxisValues={vertical ? legendLabels : ['']}\n        colorPlan={colorPlan}\n        flippedXAxisValues={false}\n        className={\n          vertical ? style['heatmap-vertical'] : style['heatmap-horizontal']\n        }\n      />\n    </CardContent>\n  );\n};\n\nexport default ColorLegend;\n","// Function involved in getting text pixels width\n// WARNING: These functions do not work properly in Chrome (not an easy problem)\n\n// This function allows to calculate the width of a given string text\n// The font for the calculation in the d3 default font\nexport const getTextWidth = (text, font = 'bold 10px sans-serif') => {\n  const canvas =\n    getTextWidth.canvas ||\n    (getTextWidth.canvas = document.createElement('canvas'));\n  const context = canvas.getContext('2d');\n  context.font = font;\n  const metrics = context.measureText(text);\n  return metrics.width;\n};\n\n// Alternative way to obtain text width\n// Probably the only way to obtain text height\nexport const getTextSizeDOM = (text, font = 'bold 10px sans-serif') => {\n  const element = document.createElement('div');\n  const content = document.createTextNode(text);\n  element.appendChild(content);\n  Object.assign(element.style, {\n    font: font,\n    position: 'absolute',\n    visibility: 'hidden',\n    height: 'auto',\n    width: 'auto',\n    'white-space': 'nowrap',\n  });\n  document.body.appendChild(element);\n  return { width: element.clientWidth, height: element.clientHeight };\n};\n\n// Get the whole body width\nexport const getBodyWidth = () => {\n  return Math.max(\n    document.body.scrollWidth,\n    document.documentElement.scrollWidth,\n    document.body.offsetWidth,\n    document.documentElement.offsetWidth,\n    document.documentElement.clientWidth,\n  );\n};\n\n// Get the whole body height\nexport const getBodyHeight = () => {\n  return Math.max(\n    document.body.scrollHeight,\n    document.documentElement.scrollHeight,\n    document.body.offsetHeight,\n    document.documentElement.offsetHeight,\n    document.documentElement.clientHeight,\n  );\n};\n","import React, { useRef, useEffect, useState, memo } from 'react';\n\nimport { getTextWidth, getTextSizeDOM } from '../../utils/document-measurer';\n\nimport { axisBottom, select, scaleLinear, scaleBand, axisLeft } from 'd3';\n\nimport { setTooltipPosition } from '../../utils/tooltip-position-manager';\n\n// According to d3 documentation\nconst defaultD3font = 'normal 10px sans-serif';\n// Experimentally verfied\nconst titlesD3font = 'normal 14px sans-serif';\n\n// DANI: Ni este 'memo' ni el 'useMemo' de dentro funcionan. Siempre se vuelve a calcular\n// Lo óptimo sería que funcionase, ya que cada vez que el ususario hace click todo se vuelve a cargar\n// Hay que construir una 'comparision function': https://reactjs.org/docs/react-api.html#reactmemo\n\n// Input 'data' is expected to be an array of arrays (i.e. a matrix)\nconst D3HeatmapGrid = memo(\n  ({\n    data, // The main values\n    xAxisValues = [], // String labels for the horizontal axis\n    yAxisValues = [], // String labels for the vertical axis\n    xAxisLabel, // String title for the horizontal axis\n    yAxisLabel, // String title for the vertical axis\n    verticalPadding = 0,\n    colorPlan = ['red', 'white', 'blue'],\n    colorScale, // In case a color scale is passed it overrides the max, mid and min colors\n    onTooltip, // Text to be rendered on the tooltip\n    onClick, // Function to be called when clicking on the heatmap\n    flippedXAxisValues = true, // Set if values in x axis is horizontal (false) or vertical (true)\n    margin = { top: 10, right: 10, bottom: 10, left: 10 },\n    className,\n    NaNColor = '#ffffff', // Default black color for NaN\n    minValue,\n    maxValue,\n    addBorder = true, // Add a border to each cell\n  }) => {\n    if (!data)\n      throw new Error(\n        `Data is missing. Data is mandatory for the heatmap representation`,\n      );\n    // Check that there are no duplicates in both x and y axes values\n    // WARNING: Duplicates would not make the heatmap fail, but they will result in overlaps\n    if (xAxisValues.length !== new Set(xAxisValues).size) {\n      console.log(xAxisValues);\n      throw new Error(`Duplicated values in the X axis. See console logs`);\n    }\n    if (yAxisValues.length !== new Set(yAxisValues).size) {\n      console.log(yAxisValues);\n      throw new Error(`Duplicated values in the Y axis. See console logs`);\n    }\n\n    // If any label is empty, fill it with 1-n numbers\n    if (xAxisValues.length === 0)\n      xAxisValues = Array.from(Array(data[0].length).keys());\n    if (yAxisValues.length === 0)\n      yAxisValues = Array.from(Array(data[0].length).keys());\n\n    // Convert data to heatmap friendly format\n\n    // Join all rows into a single array with all values\n    const values = [].concat(...data);\n    // Save the maximum and minimum values - excluding NaN values\n    const validValues = values.filter(value => !isNaN(value));\n    const maxv = maxValue ?? Math.max(...validValues);\n    const minv = minValue ?? Math.min(...validValues);\n    // Repeat the x labels as many times as rows are there\n    const xlabs = [].concat(...Array(data.length).fill(xAxisValues));\n    // Repeat each y label as many times as rows are there\n    const ylabs = [];\n    for (const lab of yAxisValues)\n      ylabs.push(...Array(xAxisValues.length).fill(lab));\n    // Fill an array with an object fo each d, x and y\n    const fdata = [];\n    for (const i in values) {\n      fdata.push({ v: values[i], x: xlabs[i], y: ylabs[i] });\n    }\n\n    // Set the reference to the element where the heatmap will be allocated\n    const containerRef = useRef(null);\n    // Save the previous chart reference so we can remove it before a new render\n    const previousCharts = useRef(null);\n\n    // Use a state as a workaround to force rerenders on window resize\n    const [, setCurrentWindow] = useState(null);\n\n    // ----------------------------------------------------------------------------------------\n\n    // OFFSETS: Estimate the space needed for all the labels and titles to not overlap\n\n    // Set a small offset to be added between normal labels and 90 degrees rotated labels\n    // This offset is added between the y labels (normal) and the y title (rotated)\n    // This offset is added between the x labels (rotated) and the x title (normal)\n    const roatatedTextOffset = 9; // In px\n\n    // Set a small offset to keep away the axis labels and the axis values\n    // They are very close to the axis values by default\n    const axisLabelsOffset = 9; // In px\n\n    // Measure the height of normal and text and labels\n    const textHeight = getTextSizeDOM('|', defaultD3font).height;\n    const labelsHeight =\n      getTextSizeDOM('|', titlesD3font).height + axisLabelsOffset;\n\n    // Get the calculated widths of all y labels and select the maximum\n    // In addition, add a small offset between labels and the axis which is added further\n    // This offset is only in x axes, which are rotated 90 degrees and end too much close to the axis\n    const maxXAxisWidth =\n      Math.max(\n        ...xAxisValues.map(label => getTextWidth(label, defaultD3font)),\n      ) + roatatedTextOffset;\n    // Get the calculated widths of all y labels and select the maximum\n    const maxYAxisWidth = Math.max(\n      ...yAxisValues.map(label => getTextWidth(label, defaultD3font)),\n    );\n\n    // In addition, add a small offset between labels and the axis which is added further\n    // This offset is only in x axes, which are rotated 90 degrees and end too much close to the axis\n    const xAxisLabelHegiht = xAxisLabel ? labelsHeight : 0;\n    const yAxisLabelHeight = yAxisLabel ? labelsHeight + roatatedTextOffset : 0;\n\n    // Finally, estimate the space needed by axes, titles, etc.\n    const requiredXOffset = flippedXAxisValues\n      ? maxXAxisWidth + xAxisLabelHegiht\n      : textHeight + xAxisLabelHegiht;\n    const requiredYOffset =\n      yAxisValues.length === 1\n        ? Math.max(maxYAxisWidth, getTextWidth(yAxisLabel, titlesD3font))\n        : maxYAxisWidth + yAxisLabelHeight;\n\n    // Set the dimensions and offsets of the graph\n    const offset = {\n      top: margin.top,\n      right: margin.right,\n      bottom: requiredXOffset + margin.bottom,\n      left: requiredYOffset + margin.left,\n    };\n\n    // ----------------------------------------------------------------------------------------\n\n    // The chart is assigned to a referenced 'div' which must be rendered first\n    // All this process is runned after the render\n    useEffect(() => {\n      // Reset the chart\n      // WARNING: For some reason, if this part is re-render the original render is not gone\n      // WARNING: We must reset the element manually or infinite elements are rendered and stacked\n      if (previousCharts.current)\n        previousCharts.current.forEach(chart => chart.remove());\n\n      // Get the current element where all this heatmap is placed\n      const container = containerRef.current;\n      // The first render, when there is no reference to the current element yet, we skip the process\n      const {\n        clientWidth: width,\n        clientHeight: height,\n      } = container.parentElement;\n\n      // Calculate the body width and height\n      const bodyWidth = width - offset.left - offset.right;\n      const bodyHeight = height - offset.top - offset.bottom;\n\n      // Calculate how many labels we can show in any axis while avoiding overlapping\n      // Take in count that bottom labels are rotated 90º, so it is their height that counts\n      // The '* 1.05' is to grant a small padding\n      const xSlots =\n        bodyWidth / ((flippedXAxisValues ? textHeight : maxXAxisWidth) * 1.05);\n      const ySlots = bodyHeight / (textHeight * 1.05);\n\n      // Estimate how many labels we must skip to reach the desired number\n      const xstep = Math.ceil(xAxisValues.length / xSlots);\n      const ystep = Math.ceil(yAxisValues.length / ySlots);\n\n      // Use canvas to display the heatmap blocks since d3 is not as efficient\n      // Canvas is set this way so we can access this specific element later\n      // WARNING: Using the 'document.getElementById' is risky since there may be more\n      // WARNING: e.g. the color legend\n      const canvasElement = document.createElement('CANVAS');\n      select(container)\n        .node()\n        .appendChild(canvasElement);\n      const canvas = select(canvasElement)\n        .attr('id', 'canvas')\n        .attr('width', bodyWidth)\n        .attr('height', bodyHeight)\n        .style('position', 'absolute')\n        .style('top', offset.top + 'px')\n        .style('left', offset.left + 'px')\n        .style('cursor', onClick ? 'pointer' : undefined);\n      const canvasContext = canvas\n        .node()\n        .getContext('2d' /*, {desynchronized: true}*/);\n\n      // append the svg object to the body of the page\n      const svg = select(container)\n        .append('svg')\n        .attr('id', 'svg')\n        .attr('viewBox', [0, 0, width, height]);\n\n      // Build X scales and axis:\n      const x = scaleBand()\n        .range([offset.left, bodyWidth + offset.left])\n        .domain(xAxisValues)\n        .paddingInner(0);\n\n      const xAxis = svg\n        .append('g')\n        .attr('transform', 'translate(0,' + (bodyHeight + offset.top) + ')')\n        .call(\n          axisBottom(x).tickFormat((d, i) => {\n            if (i % xstep === 0) return d;\n            else return '';\n          }),\n        )\n        .selectAll('text');\n\n      if (flippedXAxisValues) {\n        xAxis\n          .style('text-anchor', 'end')\n          .attr('dx', -roatatedTextOffset + 'px')\n          .attr('dy', -roatatedTextOffset + 'px')\n          .attr('transform', 'rotate(-90)');\n      }\n\n      // Build the X axis label\n      svg\n        .append('text')\n        .attr('class', 'x label')\n        .attr('text-anchor', 'middle')\n        .attr('x', offset.left + bodyWidth / 2)\n        .attr('y', offset.top + bodyHeight + requiredXOffset)\n        .text(xAxisLabel);\n\n      // Build Y scales and axis:\n      const y = scaleBand()\n        .domain(yAxisValues)\n        .range([offset.top, bodyHeight + offset.top])\n        .padding(verticalPadding);\n\n      svg\n        .append('g')\n        .attr('transform', 'translate(' + offset.left + ', 0)')\n        .call(\n          axisLeft(y).tickFormat((d, i) => {\n            if (i % ystep === 0) return d;\n            else return '';\n          }),\n        );\n\n      // Build the Y axis label\n      if (yAxisValues.length === 1) {\n        svg\n          .append('text')\n          .attr('class', 'y label')\n          .attr('text-anchor', 'start')\n          .attr('x', 0)\n          .attr('y', margin.top + bodyHeight)\n          .text(yAxisLabel);\n      } else {\n        svg\n          .append('text')\n          .attr('class', 'y label')\n          .attr('text-anchor', 'middle')\n          .attr('x', -(offset.top + bodyHeight / 2))\n          .attr(\n            'y',\n            margin.left +\n              yAxisLabelHeight -\n              roatatedTextOffset -\n              axisLabelsOffset,\n          )\n          .attr('transform', 'rotate(-90)')\n          .text(yAxisLabel);\n      }\n\n      // Build color scale\n      const myColor = value => {\n        if (isNaN(value)) {\n          return NaNColor;\n        }\n        \n        const colorMapper = colorScale \n          ? colorScale \n          : scaleLinear()\n              .range(colorPlan)\n              .domain([minv, (minv + maxv) / 2, maxv]);\n              \n        return colorMapper(value);\n      };\n\n      // Get cell size according to d3 scale band\n      const cellWidth = x.bandwidth();\n      const cellHeight = y.bandwidth();\n\n      // Display heatmap cells using canvas\n      data.forEach((row, cy) => {\n        const yPosition = y(yAxisValues[cy]) - offset.top;\n        row.forEach((value, cx) => {\n          const xPosition = x(xAxisValues[cx]) - offset.left;\n          canvasContext.fillStyle = myColor(value);\n          canvasContext.fillRect(xPosition, yPosition, cellWidth, cellHeight);\n        \n        if (addBorder){  \n          // Add border\n          canvasContext.strokeStyle = myColor(value); // Use same color as fill\n          canvasContext.lineWidth = 1;\n          canvasContext.strokeRect(xPosition, yPosition, cellWidth, cellHeight);}\n        });\n      });\n\n      // Get the current mouse position in a standard format\n      const getMousePosition = e => {\n        // Get canvas current position\n        // WARNING: This line must be inside the function since canvas position may change when scrolling\n        const canvasRect = canvasElement.getBoundingClientRect();\n        // Get the exact mouse positions\n        const xPosition = e.clientX - canvasRect.left;\n        const yPosition = e.clientY - canvasRect.top;\n        // Calculate the equivalent x and y indexes\n        let xIndex = Math.floor(xPosition / x.step());\n        let yIndex = Math.floor(yPosition / y.step());\n        // Sometimes it may happend in the borders of the heatmap that ihe index is out of range\n        const xLimit = data[0].length - 1;\n        if (xIndex < 0) xIndex = 0;\n        if (xIndex > xLimit) xIndex = xLimit;\n        const yLimit = data.length - 1;\n        if (yIndex < 0) yIndex = 0;\n        if (yIndex > yLimit) yIndex = yLimit;\n        // Get also the equivalent axis values and the cell value\n        const xAxisValue = xAxisValues[xIndex];\n        const yAxisValue = yAxisValues[yIndex];\n        const value = data[yIndex][xIndex];\n        return { xIndex, yIndex, value, xAxisValue, yAxisValue };\n      };\n\n      // In case there is a tooltip, handle how to show it\n      let tooltip;\n      if (onTooltip) {\n        // Set up the tooltip, which is hidden by default\n        tooltip = document.createElement('div');\n        Object.assign(tooltip.style, {\n          display: 'none',\n          position: 'absolute',\n          pointerEvents: 'none',\n          backgroundColor: 'rgba( 0, 0, 0, 0.6 )',\n          color: 'lightgrey',\n          padding: '8px',\n          fontFamily: 'sans-serif',\n        });\n        container.appendChild(tooltip);\n\n        canvasElement.onmousemove = e => {\n          // Get current mouse position\n          const mousePosition = getMousePosition(e);\n          // Set the tooltip text\n          tooltip.innerText = onTooltip(mousePosition);\n          //console.log(xIndex + ',' + yIndex);\n          // Set the tooltip position inside the heatmap\n          tooltip.style.display = 'inline-block';\n          const {\n            x: xTooltipPosition,\n            y: yTooltipPosition,\n          } = setTooltipPosition(\n            container,\n            tooltip,\n            { x: e.clientX, y: e.clientY },\n            3,\n          );\n          tooltip.style.left = xTooltipPosition + 'px';\n          tooltip.style.top = yTooltipPosition + 'px';\n        };\n        canvasElement.onmouseleave = () => {\n          tooltip.style.display = 'none';\n        };\n      }\n\n      // Handle when a cell is clicked\n      if (onClick) {\n        canvasElement.onmousedown = e => {\n          // Get current mouse position\n          const mousePosition = getMousePosition(e);\n          // Call the on click function\n          onClick(mousePosition);\n        };\n      }\n\n      // Record all elements which must be removed manually when re-rendering\n      previousCharts.current = tooltip ? [svg, canvas, tooltip] : [svg, canvas];\n\n      const handleResize = () => {\n        setCurrentWindow({\n          innerWidth: window.innerWidth,\n          innerHeight: window.innerHeight,\n        });\n      };\n      window.addEventListener('resize', handleResize);\n\n      // Cleaning function\n      return () => {\n        window.removeEventListener('resize', handleResize);\n      };\n    }); // This useEffect has no dependencies\n\n    // Finally, render the heatmap\n    return (\n      // It is important to specify a height value\n      // Otherwise canvas and svg may be not coordinated\n      <div\n        className={className}\n        style={className ? undefined : { height: '600px', width: '600px' }}\n      >\n        <div\n          ref={containerRef}\n          id={'container'}\n          // WARNING: This width 100% may seem redundant, but chrome needs it\n          style={{ position: 'relative', width: '100%', height: '100%' }}\n        />\n      </div>\n    );\n  },\n);\n\nexport default D3HeatmapGrid;\n"],"names":["KEYFRAMES","opacity","reducedMotion","transform","ANIMATION_OPTIONS","fill","easing","duration","forwardRef","_ref","ref","overrideComponent","props","containerRef","useRef","useLayoutEffect","node","current","firstElementChild","animate","index","Array","from","document","querySelectorAll","findIndex","section","animation","delay","cancel","Component","Card","_jsx","className","style","children","component","getCardUtilityClass","slot","generateUtilityClass","generateUtilityClasses","_excluded","CardRoot","styled","Paper","name","overridesResolver","styles","root","overflow","React","inProps","useDefaultProps","raised","other","_objectWithoutPropertiesLoose","ownerState","_extends","classes","composeClasses","useUtilityClasses","clsx","elevation","undefined","useInViewOptions","triggerOnce","rootMargin","LipidInteractions","accessionAndMdNumber","metadata","chains","useContext","ProjectCtx","nglRef","isNglVisible","useInView","viewerRef","defaultRepresentations","useDefaultRepresentations","loading","interactionsLoading","payload","interactionsPayload","error","interactionsError","useAPI","BASE_PATH_PROJECTS","memMapLoading","memMapPayload","memMapError","selectedLipid","setSelectedLipid","useState","representations","setRepresentations","schemes","lipidTypes","useMemo","data","Object","keys","length","generateScheme","lipidType","max","Math","ColormakerRegistry","addScheme","params","this","atomColor","atom","residueIndex","residueID","interactionData","value","normalized","green","blue","red","floor","useEffect","customScheme","forEach","rep","indexOf","selection","slice","color","type","lipidRep","Loading","toString","_jsxs","Suspense","fallback","card","CardContent","Tabs","variant","indicatorColor","textColor","onChange","event","tabs","map","lipid","_memMapPayload$refere","_memMapPayload$refere2","Tab","label","display","flexDirection","alignItems","references","resname","nglcard","ViewerWithControls","container","representationsState","rotateX","height","title","maxValue","minValue","colorPlan","splits","vertical","flip","legendData","legendLabels","values","push","i","val","round","decimal","Set","size","v","reverse","D3HeatmapGrid","xAxisValues","yAxisValues","flippedXAxisValues","getTextWidth","text","font","arguments","context","canvas","createElement","getContext","measureText","width","getTextSizeDOM","element","content","createTextNode","appendChild","assign","position","visibility","body","clientWidth","clientHeight","defaultD3font","titlesD3font","memo","xAxisLabel","yAxisLabel","verticalPadding","colorScale","onTooltip","onClick","margin","top","right","bottom","left","NaNColor","addBorder","Error","console","log","concat","validValues","filter","isNaN","maxv","minv","min","xlabs","ylabs","lab","fdata","x","y","previousCharts","setCurrentWindow","textHeight","labelsHeight","maxXAxisWidth","maxYAxisWidth","xAxisLabelHegiht","yAxisLabelHeight","requiredXOffset","requiredYOffset","offset","chart","remove","parentElement","bodyWidth","bodyHeight","xSlots","ySlots","xstep","ceil","ystep","canvasElement","select","attr","canvasContext","svg","append","scaleBand","range","domain","paddingInner","xAxis","call","axisBottom","tickFormat","d","selectAll","padding","axisLeft","myColor","scaleLinear","cellWidth","bandwidth","cellHeight","row","cy","yPosition","cx","xPosition","fillStyle","fillRect","strokeStyle","lineWidth","strokeRect","getMousePosition","e","canvasRect","getBoundingClientRect","clientX","clientY","xIndex","step","yIndex","xLimit","yLimit","xAxisValue","yAxisValue","tooltip","pointerEvents","backgroundColor","fontFamily","onmousemove","mousePosition","innerText","xTooltipPosition","yTooltipPosition","setTooltipPosition","onmouseleave","onmousedown","handleResize","innerWidth","window","innerHeight","addEventListener","removeEventListener","id"],"sourceRoot":""}