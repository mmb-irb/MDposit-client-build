{"version":3,"file":"static/js/markov.8816f785.chunk.js","mappings":"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","sources":["webpack://mdposit/./src/components/animated-card/style.module.css?d4d9","components/animated-card/index.js","webpack://mdposit/./src/components/viewer-spawner/style.module.css?df6e","components/viewer-spawner/index.js","hooks/use-batch-api/index.js","webpack://mdposit/./src/pages/accession/markov/style.module.css?7701","pages/accession/markov/index.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"container\":\"style_container__M9GCG\"};","import React, { useLayoutEffect, useRef, forwardRef } from 'react';\nimport { Card } from '@mui/material';\n\nimport reducedMotion from '../../utils/reduced-motion';\n\nimport style from './style.module.css';\n\nconst KEYFRAMES = { opacity: [0, 1] };\n\nif (!reducedMotion()) {\n  KEYFRAMES.transform = ['translateY(50px)', 'translateY(0)'];\n}\n\nconst ANIMATION_OPTIONS = {\n  fill: 'both',\n  easing: 'cubic-bezier(0, .99, .56, 1.1)',\n  duration: 500,\n};\n\n// Make the card appear and slide softly from down to up when the page is loaded\nconst AnimatedCard = forwardRef(({ overrideComponent, ...props }, ref) => {\n  const containerRef = useRef(null);\n\n  useLayoutEffect(() => {\n    const node = containerRef.current && containerRef.current.firstElementChild;\n    if (!(node && node.animate)) return;\n\n    const index = Array.from(\n      document.querySelectorAll('main section'),\n    ).findIndex(section => node === section);\n\n    const animation = node.animate(KEYFRAMES, {\n      ...ANIMATION_OPTIONS,\n      delay: index * 150,\n    });\n\n    return () => animation.cancel();\n  }, []);\n\n  const Component = overrideComponent ? 'section' : Card;\n\n  return (\n    <div ref={containerRef} className={style.container}>\n      <Component component=\"section\" {...props} ref={ref} />\n    </div>\n  );\n});\n\nexport default AnimatedCard;\n","// extracted by mini-css-extract-plugin\nexport default {\"rnd\":\"style_rnd__Txifm\",\"floating-card\":\"style_floating-card__HHpby\"};","import React, { lazy, Suspense, useRef, useState } from 'react';\n\n// Rnd is the resizable and draggable system where the ngl viewer is placed\nimport { Rnd } from 'react-rnd';\n\nimport Card from '../animated-card';\n\nimport style from './style.module.css';\n\nconst ViewerWithControls = lazy(() =>\n  import(\n    /* webpackChunkName: 'viewer-with-controls' */ '../viewer-with-controls'\n  ),\n);\n\n// Minimal ngl window height\nconst MIN_NGL_DIMENSION = 150;\n\n// Counter to get always the maximum zIndex\n// This is useful to set a new or currently dragged/resized ngl window over the others\nlet maxZ = 0;\nconst nextZ = () => {\n  maxZ += 1;\n  return maxZ;\n};\n\n// This function spawns all the NGL viewers needed\n// i.e. one viewer with the requested 'props' and all previous viewers which have been nailed\nconst ViewerSpawner = ({ newViewer, nailing = true, onNail, onClose }) => {\n  // Store here all nailed NGL viewers\n  const [nailedViewers, setNailedViewers] = useState([]);\n\n  // Set the viewers as the nailed viewers and the new viewer\n  const viewers = [...nailedViewers];\n\n  // Keep listed all arrays which have been used (i.e. ngl viewers which have been nailed or closed)\n  const usedIds = useRef([]);\n\n  if (newViewer) {\n    // Find a new suitable Id that meet 2 conditions:\n    // - There is never 2 viewers with the same id, so we avoid errors\n    // - If we pick diferent frames in the graph without nailing anything, the current viewer has always the same id\n    // (This way the current viewer does not appear in the origin position every time)\n    const getNewId = () => {\n      let id = 0;\n      while (id < 999) {\n        if (usedIds.current.indexOf(id) === -1) return id;\n        id += 1;\n      }\n      console.error('Maximum number of viewers reached');\n    };\n\n    // Set a unique id for this props based in the last nailed viewer\n    newViewer.id = getNewId();\n    newViewer.close = () => {\n      if (nailing) {\n        setNailedViewers(nailed => {\n          const newNailed = [...nailed];\n          const index = nailed.indexOf(newViewer);\n          if (index !== -1) newNailed.splice(index, 1);\n          return newNailed;\n        });\n      }\n      if (onClose) onClose(newViewer);\n      usedIds.current.push(newViewer.id);\n    };\n    // If the nailer function is passed, add the logic for the viewer to be nailed further\n    if (nailing)\n      newViewer.nail = () => {\n        setNailedViewers(nailed => [...nailed, newViewer]);\n        if (onNail) onNail(newViewer);\n        usedIds.current.push(newViewer.id);\n      };\n    // Add the current viewer to the viewers list\n    viewers.push(newViewer);\n  }\n\n  // Render a viewer for each prop. Use the 'selected' parameter as unique id\n  return viewers.map(viewer => <NGLViewerInDND key={viewer.id} {...viewer} />);\n};\n\n// This component render a small NGL viewer\n// It is called when user clicks in a point in the projections component\n// Also it is called by the generic analysis page\nconst NGLViewerInDND = props => {\n  // Set a reference for the viewer\n  // If a reference is passed among the viewer arguments then use it instead\n  const viewerRef = props.viewerRef || useRef(null);\n\n  // Set the default position and size\n  const [place, setPlace] = useState(() => {\n    // Set an extra margin\n    const MARGIN = 20;\n    // Get the screen pixel sizes and vertical scroll position\n    const { innerWidth, innerHeight, scrollY } = window;\n    // The spawned elements are parented to the 'main' element, not to the 'body'\n    // We have to take this in count, since the header adds an extra offset in vertical position\n    const offsetHeight = document.querySelector('main').offsetTop;\n    // Set a reasonable dimension for the ngl window\n    const dimension = Math.max(\n      Math.min(innerWidth / 4, innerHeight / 4),\n      MIN_NGL_DIMENSION,\n    );\n    const reasonableHeight = 1.5 * dimension;\n    const reasonableWidth = 2 * dimension;\n    return {\n      // WARNING: If you set the width as 'auto' the window stays very wide when exiting fullscreen\n      width: reasonableWidth, // Let the Rnd logic set the width automatically\n      height: reasonableHeight, // Reasonable height\n      x: 0, // Left border\n      y: innerHeight - offsetHeight - reasonableHeight - MARGIN + scrollY, // Bottom border\n    };\n  });\n\n  return (\n    // Rnd is the draggable and resizable system where the ngl viewer is placed\n    <Rnd\n      position={{ x: place.x, y: place.y }}\n      size={{ width: place.width, height: place.height }}\n      // Update the zIndex to make this window the first visible\n      style={{ zIndex: nextZ() }}\n      className={style.rnd}\n      data-rnd\n      // Limits where the window can be dragged/resized to\n      // WARNING: bounds=\"main\" is problematic since the window may appear out of bounds\n      // WARNING: Then when it is moved for the first time it jumps inside the bonds, not elegant\n      bounds=\"window\"\n      // Prevent the mouse to drag/resize the window when it is over specific elements\n      cancel=\"canvas, [data-popover], #preventDragSize\"\n      // On drag/resize starts we do not change anything, but use the hook to re-render this component\n      // The Z Index is updated and the selected window becomes the first in the z axis automatically\n      // WARNING: Drag functions are also called when you just click (e.g. clicking buttons)\n      onDragStart={() => {\n        setPlace({ ...place });\n      }}\n      onResizeStart={() => {\n        setPlace({ ...place });\n      }}\n      onDragStop={(e, d) => {\n        // Use this to reject some bugged event calls: e.g. the frames number selector\n        if (e.layerX === 0 && e.layerY === 0) return;\n        // We re-render only if the new position does not equal the old position\n        if (place.x !== d.x || place.y !== d.y)\n          setPlace({\n            ...place,\n            x: d.x,\n            y: d.y,\n          });\n      }}\n      // Re-adapt the viewer and update the position/size when the window is resized\n      onResize={() => viewerRef.current && viewerRef.current.autoResize()}\n      onResizeStop={(e, direction, ref, delta, position) => {\n        setPlace({\n          width: ref.style.width,\n          height: ref.style.height,\n          ...position,\n        });\n        // if (!viewerRef.current) return;\n        // viewerRef.current.autoResize();\n        // viewerRef.current.autoResize.flush();\n      }}\n    >\n      <Card className={style['floating-card']} elevation={4}>\n        <Suspense fallback={null}>\n          <ViewerWithControls\n            className={style['floating-card']}\n            ref={viewerRef}\n            startsPlaying={false}\n            {...props}\n          />\n        </Suspense>\n      </Card>\n    </Rnd>\n  );\n};\n\nexport default ViewerSpawner;\n","import { useState, useEffect } from 'react';\nimport axios from 'axios';\n\n// Empty response\nconst blank = {\n  loading: false,\n  payload: null,\n  error: null,\n};\n\n// Loading response\nconst loading = {\n  loading: true,\n};\n\n// Get data from the API for multiple URLs\nconst useBatchAPI = urls => {\n  // Set the 'data' state object, which is returned at the end of this function\n  const [data, setData] = useState(urls.map(url => blank));\n\n  // This react hook is responisble for sending the request to the API\n  // This react hook has 'url' dependencies, so it is only runned once per request\n  useEffect(() => {\n    // This is axios (https://www.npmjs.com/package/axios)\n    // Set a cancel option (token). If a request includes this cancel token in its options, the request can be cancelled\n    // In order to cancel the request, the same token must be used through axios\n    const source = axios.CancelToken.source();\n    let didCancel = false;\n    // Reset data to match in length with the urls\n    // Try to reuse old data in case any url matches\n    setData(oldData => {\n      const newData = urls.map(url => {\n        // If the url is not valid then kill it\n        // This is a workaround of the useAPI hook, but here it makes not sense\n        if (!url) throw new Error('Missing URL in batch API call');\n        // Search for this url in old data and return it in case we find it\n        const alreadySearchedResponse = oldData.find(response => response.url === url);\n        if (alreadySearchedResponse) return alreadySearchedResponse;\n        // Otherwise return the loading response\n        return loading;\n      })\n      return newData;\n    });\n    // Iterate over each url\n    urls.forEach((url, i) => {\n      // Make a request in a Promise/await way\n      axios(url, {\n        // This token allows us to further cancel the request if necessary\n        cancelToken: source.token,\n        // Send the start time so we can calculate the response time when we get the response\n        startTime: new Date(),\n        responseType: 'arraybuffer'\n      })\n        // (.then is async) If the request has succeed\n        .then(response => {\n          if (didCancel) return;\n          // Calculate the response time\n          const endTime = new Date();\n          const startTime = response.config.startTime;\n          const responseTime = endTime - startTime; // In ms\n          // Return response data\n          const responseData = {\n            url: url,\n            loading: false,\n            payload: response.data,\n            error: null,\n            time: responseTime\n          };\n          setData(previousData => {\n            const newData = [ ...previousData ]\n            newData[i] = responseData;\n            return newData;\n          });\n        })\n        // Otherwise\n        .catch(error => {\n          if (didCancel) return;\n          const responseData = {\n            url: url,\n            loading: false,\n            payload: null,\n            error: error,\n          };\n          setData(previousData => {\n            const newData = [ ...previousData ]\n            newData[i] = responseData;\n            return newData;\n          });\n        });\n    });\n\n    return () => {\n      // Cancel the request\n      source.cancel();\n      didCancel = true;\n    };\n\n    // 'useEffect' will only be called when the url changes\n  }, [urls]);\n  // If there is no url then return an empty list\n  if (!urls) return [];\n  // Data is returned here\n  return data;\n};\n\nexport default useBatchAPI;\n","// extracted by mini-css-extract-plugin\nexport default {\"graph\":\"style_graph__hjtUJ\",\"horizontal\":\"style_horizontal__xMVF8\",\"wide25\":\"style_wide25__aa51e\",\"wide75\":\"style_wide75__n-46i\"};","import React, { lazy, useContext, useState, useMemo, useCallback } from 'react';\n\nimport Card from '../../../components/animated-card';\nimport ViewerSpawner from '../../../components/viewer-spawner';\n\nimport style from './style.module.css';\n\nimport useAPI from '../../../hooks/use-api';\nimport useBatchAPI from '../../../hooks/use-batch-api';\nimport { ProjectCtx } from '../../../contexts';\nimport { BASE_PATH_PROJECTS } from '../../../utils/constants';\n\nimport Loading from '../../../components/loading';\nimport { CardContent, Slider, Typography } from '@mui/material';\n\nconst MarkovGraph = lazy(() =>\n  import(/* webpackChunkName: 'graph-msm' */ '../../../components/graph-msm'),\n);\n\n// Set the maximum number of nodes\n// Note that the hard limit of nodes is the number of values in data (now 20)\nconst defaultNodeNumber = 14;\n// Set the maximum number of nodes\n// Note that the hard limit of links is the possible combinations of pairs of nodes\nconst defaultLinksNumber = 20;\n\n// Alternative - RMSD cutoff\n//const rmsdFoldCutoff = 1.6;\n\n// Set the maximum node area in the graph, which is the area of the node with the highest population\n// Note that the rest of node areas are proportional, so there is no need to set the minimum node area\nconst maxNodeArea = 10000;\n// Set the maximum and minimum link widths in the graph\n// Note that both are to be defined since width values are interpolated\nconst maxLinkWidth = 10;\nconst minLinkWidth = 1;\n\nconst Markov = () => {\n\n  // Get the current project metadata\n  const { accessionAndMdNumber, files } = useContext(ProjectCtx);\n\n  // Set when one point in the graph is selected\n  const [selectedFrame, setSelectedFrame] = useState(null);\n\n  // Set the number of nodes to be displayed\n  const [nodesLimit, setNodesLimit] = useState(defaultNodeNumber);\n\n  // Set the number of nodes to be displayed\n  const [linksLimit, setLinksLimit] = useState(defaultLinksNumber);\n\n  // Send a request to the API with the url of the analysis\n  const { loading, payload, error } = useAPI(\n    `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/analyses/markov/`,\n  );\n\n  // Download all markov screenshots\n  // First set the URLs for the API\n  const markov_screenshots_urls = useMemo(() => {\n    // Find markov screenshot filenames\n    const markov_screenshot_filenames = files.filter(filename => filename.includes('markov_screenshot'));\n    // Sort them according to their numeration so they match\n    return markov_screenshot_filenames.map(\n      markov_screenshot_filename => `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/files/${markov_screenshot_filename}`\n    );\n  }, [files]);\n  // Now perform the API calls\n  const markov_screenshots_responses = useBatchAPI(markov_screenshots_urls);\n  const markov_screenshot_loading = markov_screenshots_responses.some(response => response.loading);\n  // Parse the screenshot images\n  const markov_screenshots = useMemo(() => {\n    if (markov_screenshot_loading) return;\n    return markov_screenshots_responses.map(response => {\n      if (!response) return null;\n      if (!response.payload) return null;\n      return 'data:image/png;base64,' + Buffer.from(response.payload, 'binary').toString('base64');\n    });\n  }, [markov_screenshots_responses, markov_screenshot_loading]);\n\n  // Set the nodes and links to be represented in the Markov graph\n  // For every node, set its area according to its population value and then calculate its radius\n  // For every link, set is thickness according to the RMSD between the two frames it is connecting\n  const { graphData, availableLinks } = useMemo(() => {\n    if (!payload) return {};\n    // Set the populations cutoff according to the maximum populations value to remove nodes\n    // Maximum populations value is the first populations value since they are sorted\n    const maximumPopulation = payload.populations[0];\n    // Set nodes: objects containing both the frame and the population\n    const nodes = [];\n    payload.populations.forEach((population, i) => {\n      // If we have already appended as many nodes as admited then stop here\n      if (i >= nodesLimit) return;\n      // Set the area of the current node\n      const area = population * maxNodeArea / maximumPopulation;\n      // Calculate the radius from the area\n      const radius = Math.sqrt(area / Math.PI);\n      // Set the node and add it to the list\n      const node = {\n        id: i,\n        radius: radius,\n        value: payload.frames[i],\n        // Set the text to be displayed as a tooltip when the node is hovered\n        // Populations is a percent in a 0 to 1 format, so we multipley by an extra 100 to get the actual percent\n        text: `Population: ${Math.round(population * 10000) / 100} %\\nFrame: ${payload.frames[i]}`\n      };\n      nodes.push(node);\n    });\n    // Count the number of final nodes, to know which RMSD links are to be discarded\n    const nodeCount = nodes.length;\n    // First of all get all link RMSDs, avoiding repetitions and 0 values\n    const rmsdValues = []\n    payload.rmsd_matrix.forEach((rmsd_row, i) => {\n      // The node for this link is missing\n      if (i >= nodeCount) return;\n      rmsd_row.forEach((rmsd, j) => {\n        // The node for this link is missing\n        if (j >= nodeCount) return;\n        // If i > j the link has been set already\n        // If i = j the RMSD is 0\n        if (i >= j) return;\n        rmsdValues.push(rmsd);\n      });\n    });\n    // Count the number of possible links according to the number of nodes\n    const availableLinks = rmsdValues.length;\n    // Set links, objects containing the two nodes to be connected and the width if the link\n    const links = [];\n    if (linksLimit > 0) {\n      // Sort RMSD values to get the maximum and minimum values\n      const sortedRmsds = rmsdValues.sort();\n      // Set the minimum and maximum RMSD values\n      const minimumRmsd = sortedRmsds[0];\n      const maximumRmsdCutoff = linksLimit < availableLinks\n        ? sortedRmsds[linksLimit - 1]\n        : sortedRmsds[availableLinks - 1];\n      // Calculate the normalizer for the interpolation process\n      const normalizer = maximumRmsdCutoff === minimumRmsd\n        ? 1 // If there is only one link then set it to the maximum width\n        : (maxLinkWidth - minLinkWidth) / (maximumRmsdCutoff - minimumRmsd);\n      // Set link objects\n      payload.rmsd_matrix.forEach((rmsd_row, i) => {\n        // The node for this link is missing\n        if (i >= nodeCount) return;\n        rmsd_row.forEach((rmsd, j) => {\n          // The node for this link is missing\n          if (j >= nodeCount) return;\n          // If i > j the link has been set already\n          // If i = j the RMSD is 0\n          if (i >= j) return;\n          // Check the cuttoff\n          if (rmsd > maximumRmsdCutoff) return;\n          // Interpolate the current rmsd to obtain the corresponding width\n          const width = maxLinkWidth - (rmsd - minimumRmsd) * normalizer;\n          // Set a new link and add it to the list\n          // Note that there is actually not 'source' and 'target', but these are the d3 expected names\n          // Width score is inverse to RMSD: the lowest the RMSD, the widthest the link must be\n          const link = { source: i, target: j, width: width };\n          links.push(link);\n        });\n      });\n    }\n    // // Set the RMSD cutoff according to the minimum RMSD to remove links\n    // // Find the minimum non-zero RMSD value\n    // const minimumRmsd = payload.rmsd_matrix.reduce((current_value, new_row) => {\n    //   return Math.min(current_value, new_row.reduce((local_current_value, new_value) => {\n    //     return new_value === 0 ? local_current_value : Math.min(local_current_value, new_value);\n    //   }, Infinity))\n    // }, Infinity);\n    // // Set the maximum RMSD cutoff to discard a link\n    // const maximumRmsdCutoff = minimumRmsd * rmsdFoldCutoff;\n    // // Calculate the normalizer for the interpolation process\n    // const normalizer = (maxLinkWidth - minLinkWidth) / (maximumRmsdCutoff - minimumRmsd);\n    // // Set links, objects containing the two nodes to be connected and the width if the link\n    // const links = [];\n    // payload.rmsd_matrix.forEach((rmsd_row, i) => {\n    //   // The node for this link is missing\n    //   if (i >= nodeCount) return;\n    //   rmsd_row.forEach((rmsd, j) => {\n    //     // The node for this link is missing\n    //     if (j >= nodeCount) return;\n    //     // If i > j the link has been set already\n    //     // If i = j the RMSD is 0\n    //     if (i >= j) return;\n    //     // Check the cuttoff\n    //     if (rmsd > maximumRmsdCutoff) return;\n    //     // Interpolate the current rmsd to obtain the corresponding width\n    //     const width = maxLinkWidth - (rmsd - minimumRmsd) * normalizer;\n    //     // Set a new link and add it to the list\n    //     // Note that there is actually not 'source' and 'target', but these are the d3 expected names\n    //     // Width score is inverse to RMSD: the lowest the RMSD, the widthest the link must be\n    //     const link = { source: i, target: j, width: width };\n    //     links.push(link);\n    //   });\n    // });\n    // Return both nodes and links inside an object\n    const graphData = { nodes: nodes, links: links };\n    return { graphData, availableLinks };\n  }, [payload, nodesLimit, linksLimit]);\n\n  const handleNodeSelect = useCallback(node => {\n    setSelectedFrame(node.value);\n  }, [setSelectedFrame]);\n\n  // Render loading or error messages according with the API response\n  if (loading) return <Loading />;\n  else if (error) return error.toString();\n  else if (!payload) return 'Something bad happened';\n  // Render loading message according to screenshot downloads\n  if (markov_screenshot_loading) return <Loading />;\n\n  return (\n    <>\n      <Card>\n        <MarkovGraph\n          data={graphData}\n          images={markov_screenshots}\n          selectedNodeValue={selectedFrame}\n          onSelectNode={handleNodeSelect}\n          className={style.graph}\n        />\n        <CardContent>\n          <div className={style.horizontal}>\n            <Typography variant=\"h7\" className={style.wide25}>{'Number of nodes: '}</Typography>\n            <Slider\n              title=\"Change number of nodes\"\n              value={nodesLimit}\n              aria-labelledby=\"continuous-slider\"\n              onChange={(_, value) => { setNodesLimit(value) }}\n              min={2}\n              max={payload.populations.length}\n              valueLabelDisplay=\"auto\"\n              className={style.wide75}\n            />\n          </div>\n          <div className={style.horizontal}>\n            <Typography variant=\"h7\" className={style.wide25}>{'Number of links: '}</Typography>\n            <Slider\n              title=\"Change the RMSD cutoff\"\n              value={linksLimit}\n              aria-labelledby=\"continuous-slider\"\n              onChange={(_, value) => { setLinksLimit(value) }}\n              min={0}\n              max={availableLinks}\n              valueLabelDisplay=\"auto\"\n              className={style.wide75}\n            />\n          </div>\n        </CardContent>\n      </Card>\n      <ViewerSpawner\n        // Set the new viewer or null if there is not a proper \"selected\" value\n        newViewer={selectedFrame\n          ? { requestedFrame: selectedFrame }\n          : null\n        }\n        // If the nailed/closed viewer is the current viewer then reset the 'selected'\n        onNail={viewer =>\n          setSelectedFrame(previous => {\n            if (viewer.requestedFrame === previous) return null;\n            else return previous;\n          })\n        }\n        onClose={viewer =>\n          setSelectedFrame(previous => {\n            if (viewer.requestedFrame === previous) return null;\n            else return previous;\n          })\n        }\n      />\n    </>\n  );\n};\n\nexport default Markov;\n"],"names":["KEYFRAMES","opacity","reducedMotion","transform","ANIMATION_OPTIONS","fill","easing","duration","forwardRef","_ref","ref","overrideComponent","props","containerRef","useRef","useLayoutEffect","node","current","firstElementChild","animate","index","Array","from","document","querySelectorAll","findIndex","section","animation","delay","cancel","Component","Card","_jsx","className","style","children","component","ViewerWithControls","lazy","maxZ","NGLViewerInDND","viewerRef","place","setPlace","useState","innerWidth","innerHeight","scrollY","window","offsetHeight","querySelector","offsetTop","dimension","Math","max","min","reasonableHeight","width","height","x","y","Rnd","position","size","zIndex","bounds","onDragStart","onResizeStart","onDragStop","e","d","layerX","layerY","onResize","autoResize","onResizeStop","direction","delta","elevation","Suspense","fallback","startsPlaying","newViewer","nailing","onNail","onClose","nailedViewers","setNailedViewers","viewers","usedIds","getNewId","id","indexOf","console","error","close","nailed","newNailed","splice","push","nail","map","viewer","blank","loading","payload","urls","data","setData","url","useEffect","source","axios","didCancel","oldData","Error","alreadySearchedResponse","find","response","forEach","i","cancelToken","token","startTime","Date","responseType","then","responseTime","config","responseData","time","previousData","newData","catch","MarkovGraph","Markov","accessionAndMdNumber","files","useContext","ProjectCtx","selectedFrame","setSelectedFrame","nodesLimit","setNodesLimit","linksLimit","setLinksLimit","useAPI","concat","BASE_PATH_PROJECTS","markov_screenshots_urls","useMemo","filter","filename","includes","markov_screenshot_filename","markov_screenshots_responses","useBatchAPI","markov_screenshot_loading","some","markov_screenshots","Buffer","toString","graphData","availableLinks","maximumPopulation","populations","nodes","population","area","radius","sqrt","PI","value","frames","text","round","nodeCount","length","rmsdValues","rmsd_matrix","rmsd_row","rmsd","j","links","sortedRmsds","sort","minimumRmsd","maximumRmsdCutoff","normalizer","link","target","handleNodeSelect","useCallback","Loading","_jsxs","_Fragment","images","selectedNodeValue","onSelectNode","CardContent","Typography","variant","Slider","title","onChange","_","valueLabelDisplay","ViewerSpawner","requestedFrame","previous"],"sourceRoot":""}