{"version":3,"file":"static/js/projections.35644b4a.chunk.js","mappings":"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","sources":["components/projections/move-points/index.js","webpack://mdposit/./src/components/projections/style.module.css?f675","components/projections/index.js","components/projections/get-draw-legend/index.js"],"sourcesContent":["import { timer, easeCubicInOut, easeElastic } from 'd3';\n\n// device pixel ratio (for \"retina\" screens)\nconst dPR = window.devicePixelRatio || 1;\n\n// easing for start animation (looks like a spring coming out of the centre)\nconst customElastic = easeElastic.amplitude(1).period(0.5);\n\n// timer instance variable\nlet t;\n\nexport default ({ context, dataPoints, width, height, maxTime, isFirstTime }) =>\n  new Promise(res => {\n    if (t) t.stop();\n    t = timer(elapsed => {\n      const isLastDraw = elapsed >= maxTime;\n      // if we finished transitioning, clear completely the canvas\n      if (isLastDraw) {\n        t.stop();\n        context.fillStyle = 'white';\n        context.fillRect(0, 0, width * dPR, height * dPR);\n      } else {\n        // clean up the canvas before drawing everything else\n        // using white, but opacity 0.25, to keep a shadow of the previous drawings\n        // to give the illusion of movement\n        context.fillStyle = `rgba(255, 255, 255, 0.25)`;\n        context.fillRect(0, 0, width * dPR, height * dPR);\n      }\n      // loop on every data point and draw them\n      for (const dataPoint of dataPoints) {\n        const easedProgress = Math.max(\n          0,\n          (isFirstTime ? customElastic : easeCubicInOut)(\n            Math.min((elapsed - dataPoint.delay) / dataPoint.duration, 1),\n          ),\n        );\n        // x\n        dataPoint.currentX = dataPoint.interpolateX(easedProgress);\n        // skip out-of-screen points\n        if (dataPoint.currentX < 0 || dataPoint.currentX > width) continue;\n        dataPoint.currentY = dataPoint.interpolateY(easedProgress);\n        // y\n        dataPoints.currentRadius = dataPoints.interpolateRadius(easedProgress);\n        // skip out-of-screen points\n        if (dataPoint.currentY < 0 || dataPoint.currentY > height) continue;\n        // draw point\n        context.fillStyle = dataPoint.fill.hex;\n        context.beginPath();\n        context.arc(\n          dataPoint.currentX,\n          dataPoint.currentY,\n          dataPoints.currentRadius,\n          0,\n          2 * Math.PI,\n        );\n        context.fill();\n      }\n      if (isLastDraw) res();\n    });\n  });\n","// extracted by mini-css-extract-plugin\nexport default {\"graph-container\":\"style_graph-container__oCOoS\",\"axis\":\"style_axis__H0KE8\",\"legend-text\":\"style_legend-text__Zvd0H\",\"legend\":\"style_legend__kYAHJ\",\"switch\":\"style_switch__vPk4i\",\"switched\":\"style_switched__DLS7l\",\"color-scale\":\"style_color-scale__mIyZh\",\"cursor\":\"style_cursor__uJXdm\",\"tooltip\":\"style_tooltip__S2WeP\"};","import React, { useRef, useEffect, useMemo } from 'react';\nimport { noop, zip, random, debounce, clamp } from 'lodash-es';\nimport {\n  select,\n  scaleLinear,\n  axisLeft,\n  axisBottom,\n  scaleSequential,\n  interpolateViridis,\n  interpolate,\n  event,\n  brush,\n  rgb,\n} from 'd3';\nimport { Delaunay } from 'd3-delaunay';\nimport { schedule, sleep, frame } from 'timing-functions';\nimport cn from 'classnames';\n\nimport useToggleState from '../../hooks/use-toggle-state';\nimport movePoints from './move-points';\nimport getDrawLegend from './get-draw-legend';\nimport reducedMotion from '../../utils/reduced-motion';\n\nimport { IconButton } from '@mui/material';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faRandom } from '@fortawesome/free-solid-svg-icons';\n\nimport style from './style.module.css';\n\n// device pixel ratio (for \"retina\" screens)\nconst dPR = window.devicePixelRatio || 1;\n\n// delaunay diagram detection threshold\nconst THRESHOLD = 20;\n\nconst MARGIN = { top: 10, right: 10, bottom: 25, left: 25 };\n\n// animation constants\nconst MAX_DELAY = 500;\nconst [MIN_DURATION, MAX_DURATION] = [375, 625];\n\nconst colorScale = scaleSequential(interpolateViridis);\n\n// This component renders a graph\n// This graph is displayed when user selects 2 pca projections\nconst Projections = ({\n  framestep,\n  projectionsData,\n  projections,\n  datumRange,\n  totalFrames,\n  setRequestedFrame,\n}) => {\n  const containerRef = useRef(null);\n  const legendRef = useRef(null);\n  const drawRef = useRef(noop);\n  const dataPointsRef = useRef(null);\n  const processedRef = useRef(null);\n  const tooltipRef = useRef(null);\n  const delaunayDiagramRef = useRef({ find() {} });\n\n  const [switched, toggleSwitched] = useToggleState(false);\n\n  // Count the number of coordinates\n  const coordinatesCount = useMemo(() => \n    (projectionsData && projectionsData[0].length) || 0,\n  [projectionsData]) ;\n\n  useEffect(() => {\n    const canvas = select(containerRef.current).append('canvas');\n    const graph = select(containerRef.current).append('svg');\n\n    const context = canvas\n      .node()\n      .getContext('2d', { alpha: false, desynchronized: true });\n\n    const brushInstance = brush();\n\n    const refs = {\n      xScale: scaleLinear(),\n      yScale: scaleLinear(),\n      xAxis: graph.append('g').attr('class', style.axis),\n      yAxis: graph.append('g').attr('class', style.axis),\n      xAxisLegend: graph\n        .append('text')\n        .attr('class', cn(style.axis, style['legend-text'])),\n      yAxisLegend: graph\n        .append('text')\n        .attr('class', cn(style.axis, style['legend-text'])),\n      dataPoints: graph.append('g').attr('class', style['data-points']),\n      hover: graph.append('circle').attr('fill', 'transparent'),\n      legendCanvas: select(legendRef.current).select('canvas'),\n      legendCursor: select(legendRef.current).select(`.${style.cursor}`),\n      brush: brushInstance,\n      brushElement: graph.append('g').attr('class', 'brush'),\n    };\n\n    // debounce it to prevent redrawing that too much\n    refs.drawLegend = debounce(\n      getDrawLegend(refs.legendCanvas.node().getContext('2d', { alpha: true })),\n      MAX_DELAY + MAX_DURATION,\n    );\n\n    const reset = ({ onlyTooltip } = {}) => {\n      tooltipRef.current.style.display = 'none';\n      refs.hover.attr('fill', 'transparent');\n      if (onlyTooltip) return;\n      refs.legendCursor.style('left', '');\n      refs.legendCursor.style('opacity', 0);\n    };\n\n    // Select the frame to be displayed by the viewer\n    const handleClick = ({ datumIndex } = {}) =>\n      // This function is a setter from a useState hook in the parent script (pca/index.js)\n      setRequestedFrame(currentFrame => {\n        // If we are out of range then ignore the click\n        if (datumIndex < 0 || datumIndex >= coordinatesCount) return currentFrame;\n        if (!totalFrames) {\n          console.error('No number of frames in metadata. Are we missing the main trajectory?');\n          return null;\n        }\n        // Set the target frame\n        const target = datumIndex * framestep;\n        // If the user clicks in the already selected point then it is unselected\n        if (target === currentFrame) return null;\n        // Return the new frame otherwise\n        return target;\n      });\n\n    drawRef.current = async ({\n      processed = processedRef.current,\n      brushing,\n    } = {}) => {\n      if (!processed) return;\n      await frame();\n      if (!containerRef.current.firstChild) return;\n\n      // container size\n      const { clientWidth: width, clientHeight: height } = containerRef.current;\n      graph.attr('width', width).attr('height', height);\n      if (canvas.attr('width') !== `${width * dPR}`) {\n        canvas.attr('width', width * dPR);\n      }\n      if (canvas.attr('height') !== `${height * dPR}`) {\n        canvas.attr('height', height * dPR);\n      }\n      canvas.style('width', `${width}px`).style('height', `${height}px`);\n\n      refs.brushElement.call(refs.brush);\n\n      const isFirstTime = !dataPointsRef.current;\n\n      // x axis\n      refs.xScale.range([MARGIN.left, width - MARGIN.right]);\n      if (!brushing) refs.xScale.domain(processed.xMinMax);\n\n      // y axis\n      refs.yScale.range([height - MARGIN.bottom, MARGIN.top]);\n      if (!brushing) refs.yScale.domain(processed.yMinMax);\n      // visual x axis\n      const xAxis = g =>\n        g\n          .attr(\n            'transform',\n            `translate(0, ${clamp(refs.yScale(0), 0, height - 32)})`,\n          )\n          .call(\n            axisBottom(refs.xScale)\n              .ticks(Math.round(width / 75))\n              .tickFormat(d => (d === 0 ? null : d)),\n          );\n      refs.xAxis\n        .transition()\n        .duration(!isFirstTime && !reducedMotion() && MAX_DELAY + MAX_DURATION)\n        .call(xAxis);\n\n      refs.xAxisLegend\n        .text(`← principal component ${processed.projections[0] + 1} →`)\n        .transition()\n        .duration(!isFirstTime && !reducedMotion() && MAX_DELAY + MAX_DURATION)\n        .attr('transform', `translate(${width / 2}, ${height - 5})`);\n\n      // visual y axis\n      const yAxis = g =>\n        g\n          .attr(\n            'transform',\n            `translate(${clamp(refs.xScale(0), 30, width - 1)}, 0)`,\n          )\n          .call(\n            axisLeft(refs.yScale)\n              .ticks(Math.round(height / 75))\n              .tickFormat(d => (d === 0 ? null : d)),\n          );\n      refs.yAxis\n        .transition()\n        .duration(!isFirstTime && !reducedMotion() && MAX_DELAY + MAX_DURATION)\n        .call(yAxis);\n\n      refs.yAxisLegend\n        .text(`← principal component ${processed.projections[1] + 1} →`)\n        .transition()\n        .duration(!isFirstTime && !reducedMotion() && MAX_DELAY + MAX_DURATION)\n        .attr('transform', `translate(5, ${height / 2}) rotate(90)`);\n\n      refs.brush.on('end', () => {\n        const { selection } = event;\n        if (!selection) return;\n        refs.xScale.domain(\n          [selection[0][0], selection[1][0]].map(\n            refs.xScale.invert,\n            refs.xScale,\n          ),\n        );\n        refs.yScale.domain(\n          [selection[1][1], selection[0][1]].map(\n            refs.yScale.invert,\n            refs.yScale,\n          ),\n        );\n        // remove visual brush rectangle\n        refs.brushElement.call(refs.brush.move, null);\n        drawRef.current({ brushing: true });\n      });\n\n      const radiusScale =\n        Math.log(\n          Math.max(\n            (processed.xMinMax[1] - processed.xMinMax[0]) /\n              (refs.xScale.domain()[1] - refs.xScale.domain()[0]),\n            (processed.yMinMax[1] - processed.yMinMax[0]) /\n              (refs.yScale.domain()[1] - refs.yScale.domain()[0]),\n          ),\n        ) + 1;\n      const radius = (dPR * Math.min(width, height) * radiusScale) / 250;\n      // hover circle\n      refs.hover.attr('r', radius + 5);\n\n      // data points\n      let maxTime = 0;\n      const currentRadius = isFirstTime\n        ? 0\n        : dataPointsRef.current.currentRadius;\n      dataPointsRef.current = processed.data.map(\n        ({ x: xValue, y: yValue, fill }, i, { length }) => {\n          const xPoint = refs.xScale(xValue) * dPR;\n          const yPoint = refs.yScale(yValue) * dPR;\n          const delay = (i * MAX_DELAY * (isFirstTime ? 2 : 1)) / length;\n          const duration = reducedMotion()\n            ? 0\n            : random(MIN_DURATION, MAX_DURATION) * (isFirstTime ? 2 : 1);\n          const time = delay + duration;\n          // update maxTime if needed\n          if (maxTime < time) maxTime = time;\n          return {\n            currentX: null,\n            currentY: null,\n            currentRadius: null,\n            interpolateX: interpolate(\n              isFirstTime\n                ? refs.xScale(0) * dPR\n                : dataPointsRef.current[i].currentX ||\n                    dataPointsRef.current[i].x,\n              xPoint,\n            ),\n            interpolateY: interpolate(\n              isFirstTime\n                ? refs.yScale(0) * dPR\n                : dataPointsRef.current[i].currentY ||\n                    dataPointsRef.current[i].y,\n              yPoint,\n            ),\n            delay,\n            duration,\n            x: xPoint,\n            y: yPoint,\n            fill,\n          };\n        },\n      );\n\n      // same radius interpolation for all the points, so keep only one\n      dataPointsRef.current.interpolateRadius = interpolate(\n        currentRadius,\n        radius,\n      );\n\n      // will trigger a timer animate points\n      // Render the graph\n      movePoints({\n        context,\n        dataPoints: dataPointsRef.current,\n        width: width * dPR,\n        height: height * dPR,\n        maxTime,\n        isFirstTime,\n      });\n\n      const handleHover = ({ datumIndex, datum } = {}) => {\n        if (!Number.isInteger(datumIndex) || !datum) return;\n        // bottom cursor\n        refs.legendCursor.style(\n          'left',\n          `calc(${(100 * datumIndex) / processed.data.length}% - 4px)`,\n        );\n        refs.legendCursor.style('opacity', 1);\n\n        // would tooltip be visible?\n        const x = refs.xScale(datum.x);\n        if (x < 0 || x > width) return reset({ onlyTooltip: true });\n        const y = refs.yScale(datum.y);\n        if (y < 0 || y > height) return reset({ onlyTooltip: true });\n        // yes, then display tooltip\n        const { scrollX, scrollY } = window;\n        const { left, top } = containerRef.current.getBoundingClientRect();\n        tooltipRef.current.innerHTML = `\n          <div>\n            <p>Frame ${datumIndex * processed.framestep +\n              1} (click to open viewer)</p>\n            <p>Principal component ${processed.projections[0] + 1}: ${\n          datum.x\n        }</p>\n            <p>Principal component ${processed.projections[1] + 1}: ${\n          datum.y\n        }</p>\n          </div>\n        `;\n        tooltipRef.current.style.display = 'inline-block';\n        const rect = tooltipRef.current.getBoundingClientRect();\n        tooltipRef.current.style.transform = `translate(${x +\n          left +\n          scrollX -\n          rect.width / 2}px, ${y + top + scrollY - rect.height - 15}px)`;\n        refs.hover\n          .attr('cx', x)\n          .attr('cy', y)\n          .attr('fill', datum.fill.hex);\n      };\n\n      const handleGraphEventWith = handler => () => {\n        const { scrollX, scrollY } = window;\n        const { left, top } = containerRef.current.getBoundingClientRect();\n        const { pageX, pageY } = event;\n        const mouseX = pageX - left - scrollX;\n        const mouseY = pageY - top - scrollY;\n        // invert the mouse position with the scale because we only computed the\n        // Delaunay graph once on the raw data for optimisation purposes\n        const datumIndex = delaunayDiagramRef.current.find(\n          refs.xScale.invert(mouseX),\n          refs.yScale.invert(mouseY),\n        );\n        const datum = processed.data[datumIndex];\n        if (datum) {\n          const datumX = refs.xScale(datum.x);\n          const datumY = refs.yScale(datum.y);\n          // is within threshold?\n          if (\n            Math.sqrt(\n              Math.abs(datumX - mouseX) ** 2 + Math.abs(datumY - mouseY) ** 2,\n            ) <= THRESHOLD\n          ) {\n            return handler({ datumIndex, datum });\n          }\n        }\n        reset();\n        handler();\n      };\n\n      graph\n        .on('mousemove', handleGraphEventWith(handleHover))\n        .on('mouseout', reset)\n        .on('click', handleGraphEventWith(handleClick));\n\n      /**\n       * @param {(object: object) => void} handler\n       */\n      const handleLegendEventWith = handler => () => {\n        const node = refs.legendCanvas.node();\n        if (!(node && 'getBoundingClientRect' in node)) return;\n        const { left, width } = node.getBoundingClientRect();\n        const { pageX } = event;\n        const position = (pageX - left) / width;\n        const datumIndex = Math.floor(position * processed.data.length);\n        handler({ datumIndex, datum: processed.data[datumIndex] });\n      };\n\n      refs.drawLegend(processed.data, refs.xScale, refs.yScale, width, height);\n\n      refs.legendCanvas\n        .on('mousemove', handleLegendEventWith(handleHover))\n        .on('mouseout', reset)\n        .on('click', handleLegendEventWith(handleClick));\n    };\n\n    window.addEventListener('resize', drawRef.current);\n\n    return () => {\n      // clean up\n      refs.drawLegend && refs.drawLegend.cancel();\n      window.removeEventListener('resize', drawRef.current);\n    };\n  }, [projections, setRequestedFrame, datumRange, totalFrames]);\n\n  useEffect(() => {\n    const [xProj, yProj] = switched ? [0, 1] : [1, 0];\n\n    const colorScaleWithDomain = colorScale.domain([0, coordinatesCount]);\n\n    const xProjectionData = projectionsData[projections[xProj]];\n    const yProjectionData = projectionsData[projections[yProj]];\n    const zipped = zip(xProjectionData, yProjectionData);\n    const processed = {\n      data: zipped.map(([x, y], i) => {\n        const hex = colorScaleWithDomain(i);\n        return {\n          x,\n          y,\n          fill: { hex, ...rgb(hex) },\n        };\n      }),\n      xMinMax: [Math.min(...xProjectionData), Math.max(...xProjectionData)],\n      yMinMax: [Math.min(...yProjectionData), Math.max(...yProjectionData)],\n      framestep,\n      projections: [projections[xProj], projections[yProj]],\n    };\n\n    processedRef.current = processed;\n\n    drawRef.current({ processed });\n\n    // calculate Delaunay graph to later find points from mouse position\n    (async () => {\n      // delay a bit, to prioritise drawing\n      await sleep(MAX_DELAY + MAX_DURATION);\n      await schedule(100);\n      delaunayDiagramRef.current = Delaunay.from(zipped);\n    })();\n  }, [projectionsData, coordinatesCount, projections, framestep, switched]);\n\n  return (\n    <>\n      <div\n        className={style['graph-container']}\n        onDoubleClick={drawRef.current}\n        ref={containerRef}\n      />\n      <div className={style.legend}>\n        <IconButton\n          title=\"Switch axes\"\n          className={cn(style.switch, { [style.switched]: switched })}\n          onClick={toggleSwitched}\n          size=\"large\"\n        >\n          <FontAwesomeIcon icon={faRandom} />\n        </IconButton>\n        <p>position in simulation:</p>\n        <div className={style['color-scale']}>\n          <div>start</div>\n          <div ref={legendRef}>\n            <canvas height=\"1\" width={coordinatesCount} />\n            <div className={style.cursor} />\n          </div>\n          <div>end</div>\n        </div>\n      </div>\n      <div className={style.tooltip} ref={tooltipRef} />\n    </>\n  );\n};\n\nexport default Projections;\n","export default context => (data, xScale, yScale, width, height) => {\n  const imgData = context.createImageData(data.length, 1);\n  // create a 32 bytes view on image data\n  const uInt32View = new Uint32Array(imgData.data.buffer);\n\n  data.forEach(({ x, y, fill: { r, g, b } }, i) => {\n    let opacity = 255;\n    if (xScale) {\n      const onScreenX = xScale(x);\n      if (onScreenX < 0 || onScreenX > width) {\n        opacity = 100;\n      } else {\n        const onScreenY = yScale(y);\n        if (onScreenY < 0 || onScreenY > height) opacity = 100;\n      }\n    }\n\n    // fill r, g, b, and opacity in one go\n    uInt32View[i] = opacity * 0x1000000 + b * 0x10000 + g * 0x100 + r;\n  });\n\n  context.putImageData(imgData, 0, 0);\n};\n"],"names":["dPR","window","devicePixelRatio","customElastic","easeElastic","amplitude","period","t","MARGIN","MAX_DELAY","MIN_DURATION","MAX_DURATION","colorScale","scaleSequential","interpolateViridis","_ref","framestep","projectionsData","projections","datumRange","totalFrames","setRequestedFrame","containerRef","useRef","legendRef","drawRef","noop","dataPointsRef","processedRef","tooltipRef","delaunayDiagramRef","find","switched","toggleSwitched","useToggleState","coordinatesCount","useMemo","length","useEffect","canvas","select","current","append","graph","context","node","getContext","alpha","desynchronized","brushInstance","brush","refs","xScale","scaleLinear","yScale","xAxis","attr","style","axis","yAxis","xAxisLegend","cn","yAxisLegend","dataPoints","hover","legendCanvas","legendCursor","concat","cursor","brushElement","drawLegend","debounce","data","width","height","imgData","createImageData","uInt32View","Uint32Array","buffer","forEach","i","x","y","fill","r","g","b","opacity","onScreenX","onScreenY","putImageData","getDrawLegend","reset","onlyTooltip","arguments","undefined","display","handleClick","datumIndex","currentFrame","console","error","target","async","processed","brushing","frame","firstChild","clientWidth","clientHeight","call","isFirstTime","range","domain","xMinMax","yMinMax","transition","duration","reducedMotion","clamp","axisBottom","ticks","Math","round","tickFormat","d","text","axisLeft","on","selection","event","map","invert","move","radiusScale","log","max","radius","min","maxTime","currentRadius","_ref2","_ref3","xValue","yValue","xPoint","yPoint","delay","random","time","currentX","currentY","interpolateX","interpolate","interpolateY","interpolateRadius","Promise","res","stop","timer","elapsed","isLastDraw","fillStyle","fillRect","dataPoint","easedProgress","easeCubicInOut","hex","beginPath","arc","PI","movePoints","handleHover","datum","Number","isInteger","scrollX","scrollY","left","top","getBoundingClientRect","innerHTML","rect","transform","handleGraphEventWith","handler","pageX","pageY","mouseX","mouseY","datumX","datumY","sqrt","abs","handleLegendEventWith","position","floor","addEventListener","cancel","removeEventListener","xProj","yProj","colorScaleWithDomain","xProjectionData","yProjectionData","zipped","zip","_ref4","_objectSpread","rgb","sleep","schedule","Delaunay","from","_jsxs","_Fragment","children","_jsx","className","onDoubleClick","ref","legend","IconButton","title","switch","onClick","size","FontAwesomeIcon","icon","faRandom","tooltip"],"ignoreList":[],"sourceRoot":""}