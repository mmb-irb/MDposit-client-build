{"version":3,"file":"static/js/projections.736f6422.chunk.js","mappings":"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","sources":["components/projections/move-points/index.js","webpack://mdposit/./src/components/projections/style.module.css?f675","components/projections/index.js","components/projections/get-draw-legend/index.js"],"sourcesContent":["import { timer, easeCubicInOut, easeElastic } from 'd3';\n\n// device pixel ratio (for \"retina\" screens)\nconst dPR = window.devicePixelRatio || 1;\n\n// easing for start animation (looks like a spring coming out of the centre)\nconst customElastic = easeElastic.amplitude(1).period(0.5);\n\n// timer instance variable\nlet t;\n\nexport default ({ context, dataPoints, width, height, maxTime, isFirstTime }) =>\n  new Promise(res => {\n    if (t) t.stop();\n    t = timer(elapsed => {\n      const isLastDraw = elapsed >= maxTime;\n      // if we finished transitioning, clear completely the canvas\n      if (isLastDraw) {\n        t.stop();\n        context.fillStyle = 'white';\n        context.fillRect(0, 0, width * dPR, height * dPR);\n      } else {\n        // clean up the canvas before drawing everything else\n        // using white, but opacity 0.25, to keep a shadow of the previous drawings\n        // to give the illusion of movement\n        context.fillStyle = `rgba(255, 255, 255, 0.25)`;\n        context.fillRect(0, 0, width * dPR, height * dPR);\n      }\n      // loop on every data point and draw them\n      for (const dataPoint of dataPoints) {\n        const easedProgress = Math.max(\n          0,\n          (isFirstTime ? customElastic : easeCubicInOut)(\n            Math.min((elapsed - dataPoint.delay) / dataPoint.duration, 1),\n          ),\n        );\n        // x\n        dataPoint.currentX = dataPoint.interpolateX(easedProgress);\n        // skip out-of-screen points\n        if (dataPoint.currentX < 0 || dataPoint.currentX > width) continue;\n        dataPoint.currentY = dataPoint.interpolateY(easedProgress);\n        // y\n        dataPoints.currentRadius = dataPoints.interpolateRadius(easedProgress);\n        // skip out-of-screen points\n        if (dataPoint.currentY < 0 || dataPoint.currentY > height) continue;\n        // draw point\n        context.fillStyle = dataPoint.fill.hex;\n        context.beginPath();\n        context.arc(\n          dataPoint.currentX,\n          dataPoint.currentY,\n          dataPoints.currentRadius,\n          0,\n          2 * Math.PI,\n        );\n        context.fill();\n      }\n      if (isLastDraw) res();\n    });\n  });\n","// extracted by mini-css-extract-plugin\nexport default {\"graph-container\":\"style_graph-container__oCOoS\",\"axis\":\"style_axis__H0KE8\",\"legend-text\":\"style_legend-text__Zvd0H\",\"legend\":\"style_legend__kYAHJ\",\"switch\":\"style_switch__vPk4i\",\"switched\":\"style_switched__DLS7l\",\"color-scale\":\"style_color-scale__mIyZh\",\"cursor\":\"style_cursor__uJXdm\",\"tooltip\":\"style_tooltip__S2WeP\"};","import React, { useRef, useEffect, useMemo } from 'react';\nimport { noop, zip, random, debounce, clamp } from 'lodash-es';\nimport {\n  select,\n  scaleLinear,\n  axisLeft,\n  axisBottom,\n  scaleSequential,\n  interpolateViridis,\n  interpolate,\n  event,\n  brush,\n  rgb,\n} from 'd3';\nimport { Delaunay } from 'd3-delaunay';\nimport { schedule, sleep, frame } from 'timing-functions';\nimport cn from 'classnames';\n\nimport useToggleState from '../../hooks/use-toggle-state';\nimport movePoints from './move-points';\nimport getDrawLegend from './get-draw-legend';\nimport reducedMotion from '../../utils/reduced-motion';\n\nimport { IconButton } from '@mui/material';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faRandom } from '@fortawesome/free-solid-svg-icons';\n\nimport style from './style.module.css';\n\n// device pixel ratio (for \"retina\" screens)\nconst dPR = window.devicePixelRatio || 1;\n\n// delaunay diagram detection threshold\nconst THRESHOLD = 20;\n\nconst MARGIN = { top: 10, right: 10, bottom: 25, left: 25 };\n\n// animation constants\nconst MAX_DELAY = 500;\nconst [MIN_DURATION, MAX_DURATION] = [375, 625];\n\nconst colorScale = scaleSequential(interpolateViridis);\n\n// This component renders a graph\n// This graph is displayed when user selects 2 pca projections\nconst Projections = ({\n  framestep,\n  projectionsData,\n  projections,\n  datumRange,\n  totalFrames,\n  setRequestedFrame,\n}) => {\n  const containerRef = useRef(null);\n  const legendRef = useRef(null);\n  const drawRef = useRef(noop);\n  const dataPointsRef = useRef(null);\n  const processedRef = useRef(null);\n  const tooltipRef = useRef(null);\n  const delaunayDiagramRef = useRef({ find() {} });\n\n  const [switched, toggleSwitched] = useToggleState(false);\n\n  // Count the number of coordinates\n  const coordinatesCount = useMemo(() => \n    (projectionsData && projectionsData[0].length) || 0,\n  [projectionsData]) ;\n\n  useEffect(() => {\n    const canvas = select(containerRef.current).append('canvas');\n    const graph = select(containerRef.current).append('svg');\n\n    const context = canvas\n      .node()\n      .getContext('2d', { alpha: false, desynchronized: true });\n\n    const brushInstance = brush();\n\n    const refs = {\n      xScale: scaleLinear(),\n      yScale: scaleLinear(),\n      xAxis: graph.append('g').attr('class', style.axis),\n      yAxis: graph.append('g').attr('class', style.axis),\n      xAxisLegend: graph\n        .append('text')\n        .attr('class', cn(style.axis, style['legend-text'])),\n      yAxisLegend: graph\n        .append('text')\n        .attr('class', cn(style.axis, style['legend-text'])),\n      dataPoints: graph.append('g').attr('class', style['data-points']),\n      hover: graph.append('circle').attr('fill', 'transparent'),\n      legendCanvas: select(legendRef.current).select('canvas'),\n      legendCursor: select(legendRef.current).select(`.${style.cursor}`),\n      brush: brushInstance,\n      brushElement: graph.append('g').attr('class', 'brush'),\n    };\n\n    // debounce it to prevent redrawing that too much\n    refs.drawLegend = debounce(\n      getDrawLegend(refs.legendCanvas.node().getContext('2d', { alpha: true })),\n      MAX_DELAY + MAX_DURATION,\n    );\n\n    const reset = ({ onlyTooltip } = {}) => {\n      tooltipRef.current.style.display = 'none';\n      refs.hover.attr('fill', 'transparent');\n      if (onlyTooltip) return;\n      refs.legendCursor.style('left', '');\n      refs.legendCursor.style('opacity', 0);\n    };\n\n    // Select the frame to be displayed by the viewer\n    const handleClick = ({ datumIndex } = {}) =>\n      // This function is a setter from a useState hook in the parent script (pca/index.js)\n      setRequestedFrame(currentFrame => {\n        // If we are out of range then ignore the click\n        if (datumIndex < 0 || datumIndex >= coordinatesCount) return currentFrame;\n        if (!totalFrames) {\n          console.error('No number of frames in metadata. Are we missing the main trajectory?');\n          return null;\n        }\n        // Set the target frame\n        const target = datumIndex * framestep;\n        // If the user clicks in the already selected point then it is unselected\n        if (target === currentFrame) return null;\n        // Return the new frame otherwise\n        return target;\n      });\n\n    drawRef.current = async ({\n      processed = processedRef.current,\n      brushing,\n    } = {}) => {\n      if (!processed) return;\n      await frame();\n      if (!containerRef.current.firstChild) return;\n\n      // container size\n      const { clientWidth: width, clientHeight: height } = containerRef.current;\n      graph.attr('width', width).attr('height', height);\n      if (canvas.attr('width') !== `${width * dPR}`) {\n        canvas.attr('width', width * dPR);\n      }\n      if (canvas.attr('height') !== `${height * dPR}`) {\n        canvas.attr('height', height * dPR);\n      }\n      canvas.style('width', `${width}px`).style('height', `${height}px`);\n\n      refs.brushElement.call(refs.brush);\n\n      const isFirstTime = !dataPointsRef.current;\n\n      // x axis\n      refs.xScale.range([MARGIN.left, width - MARGIN.right]);\n      if (!brushing) refs.xScale.domain(processed.xMinMax);\n\n      // y axis\n      refs.yScale.range([height - MARGIN.bottom, MARGIN.top]);\n      if (!brushing) refs.yScale.domain(processed.yMinMax);\n      // visual x axis\n      const xAxis = g =>\n        g\n          .attr(\n            'transform',\n            `translate(0, ${clamp(refs.yScale(0), 0, height - 32)})`,\n          )\n          .call(\n            axisBottom(refs.xScale)\n              .ticks(Math.round(width / 75))\n              .tickFormat(d => (d === 0 ? null : d)),\n          );\n      refs.xAxis\n        .transition()\n        .duration(!isFirstTime && !reducedMotion() && MAX_DELAY + MAX_DURATION)\n        .call(xAxis);\n\n      refs.xAxisLegend\n        .text(`← principal component ${processed.projections[0] + 1} →`)\n        .transition()\n        .duration(!isFirstTime && !reducedMotion() && MAX_DELAY + MAX_DURATION)\n        .attr('transform', `translate(${width / 2}, ${height - 5})`);\n\n      // visual y axis\n      const yAxis = g =>\n        g\n          .attr(\n            'transform',\n            `translate(${clamp(refs.xScale(0), 30, width - 1)}, 0)`,\n          )\n          .call(\n            axisLeft(refs.yScale)\n              .ticks(Math.round(height / 75))\n              .tickFormat(d => (d === 0 ? null : d)),\n          );\n      refs.yAxis\n        .transition()\n        .duration(!isFirstTime && !reducedMotion() && MAX_DELAY + MAX_DURATION)\n        .call(yAxis);\n\n      refs.yAxisLegend\n        .text(`← principal component ${processed.projections[1] + 1} →`)\n        .transition()\n        .duration(!isFirstTime && !reducedMotion() && MAX_DELAY + MAX_DURATION)\n        .attr('transform', `translate(5, ${height / 2}) rotate(90)`);\n\n      refs.brush.on('end', () => {\n        const { selection } = event;\n        if (!selection) return;\n        refs.xScale.domain(\n          [selection[0][0], selection[1][0]].map(\n            refs.xScale.invert,\n            refs.xScale,\n          ),\n        );\n        refs.yScale.domain(\n          [selection[1][1], selection[0][1]].map(\n            refs.yScale.invert,\n            refs.yScale,\n          ),\n        );\n        // remove visual brush rectangle\n        refs.brushElement.call(refs.brush.move, null);\n        drawRef.current({ brushing: true });\n      });\n\n      const radiusScale =\n        Math.log(\n          Math.max(\n            (processed.xMinMax[1] - processed.xMinMax[0]) /\n              (refs.xScale.domain()[1] - refs.xScale.domain()[0]),\n            (processed.yMinMax[1] - processed.yMinMax[0]) /\n              (refs.yScale.domain()[1] - refs.yScale.domain()[0]),\n          ),\n        ) + 1;\n      const radius = (dPR * Math.min(width, height) * radiusScale) / 250;\n      // hover circle\n      refs.hover.attr('r', radius + 5);\n\n      // data points\n      let maxTime = 0;\n      const currentRadius = isFirstTime\n        ? 0\n        : dataPointsRef.current.currentRadius;\n      dataPointsRef.current = processed.data.map(\n        ({ x: xValue, y: yValue, fill }, i, { length }) => {\n          const xPoint = refs.xScale(xValue) * dPR;\n          const yPoint = refs.yScale(yValue) * dPR;\n          const delay = (i * MAX_DELAY * (isFirstTime ? 2 : 1)) / length;\n          const duration = reducedMotion()\n            ? 0\n            : random(MIN_DURATION, MAX_DURATION) * (isFirstTime ? 2 : 1);\n          const time = delay + duration;\n          // update maxTime if needed\n          if (maxTime < time) maxTime = time;\n          return {\n            currentX: null,\n            currentY: null,\n            currentRadius: null,\n            interpolateX: interpolate(\n              isFirstTime\n                ? refs.xScale(0) * dPR\n                : dataPointsRef.current[i].currentX ||\n                    dataPointsRef.current[i].x,\n              xPoint,\n            ),\n            interpolateY: interpolate(\n              isFirstTime\n                ? refs.yScale(0) * dPR\n                : dataPointsRef.current[i].currentY ||\n                    dataPointsRef.current[i].y,\n              yPoint,\n            ),\n            delay,\n            duration,\n            x: xPoint,\n            y: yPoint,\n            fill,\n          };\n        },\n      );\n\n      // same radius interpolation for all the points, so keep only one\n      dataPointsRef.current.interpolateRadius = interpolate(\n        currentRadius,\n        radius,\n      );\n\n      // will trigger a timer animate points\n      // Render the graph\n      movePoints({\n        context,\n        dataPoints: dataPointsRef.current,\n        width: width * dPR,\n        height: height * dPR,\n        maxTime,\n        isFirstTime,\n      });\n\n      const handleHover = ({ datumIndex, datum } = {}) => {\n        if (!Number.isInteger(datumIndex) || !datum) return;\n        // bottom cursor\n        refs.legendCursor.style(\n          'left',\n          `calc(${(100 * datumIndex) / processed.data.length}% - 4px)`,\n        );\n        refs.legendCursor.style('opacity', 1);\n\n        // would tooltip be visible?\n        const x = refs.xScale(datum.x);\n        if (x < 0 || x > width) return reset({ onlyTooltip: true });\n        const y = refs.yScale(datum.y);\n        if (y < 0 || y > height) return reset({ onlyTooltip: true });\n        // yes, then display tooltip\n        const { scrollX, scrollY } = window;\n        const { left, top } = containerRef.current.getBoundingClientRect();\n        tooltipRef.current.innerHTML = `\n          <div>\n            <p>Frame ${datumIndex * processed.framestep +\n              1} (click to open viewer)</p>\n            <p>Principal component ${processed.projections[0] + 1}: ${\n          datum.x\n        }</p>\n            <p>Principal component ${processed.projections[1] + 1}: ${\n          datum.y\n        }</p>\n          </div>\n        `;\n        tooltipRef.current.style.display = 'inline-block';\n        const rect = tooltipRef.current.getBoundingClientRect();\n        tooltipRef.current.style.transform = `translate(${x +\n          left +\n          scrollX -\n          rect.width / 2}px, ${y + top + scrollY - rect.height - 15}px)`;\n        refs.hover\n          .attr('cx', x)\n          .attr('cy', y)\n          .attr('fill', datum.fill.hex);\n      };\n\n      const handleGraphEventWith = handler => () => {\n        const { scrollX, scrollY } = window;\n        const { left, top } = containerRef.current.getBoundingClientRect();\n        const { pageX, pageY } = event;\n        const mouseX = pageX - left - scrollX;\n        const mouseY = pageY - top - scrollY;\n        // invert the mouse position with the scale because we only computed the\n        // Delaunay graph once on the raw data for optimisation purposes\n        const datumIndex = delaunayDiagramRef.current.find(\n          refs.xScale.invert(mouseX),\n          refs.yScale.invert(mouseY),\n        );\n        const datum = processed.data[datumIndex];\n        if (datum) {\n          const datumX = refs.xScale(datum.x);\n          const datumY = refs.yScale(datum.y);\n          // is within threshold?\n          if (\n            Math.sqrt(\n              Math.abs(datumX - mouseX) ** 2 + Math.abs(datumY - mouseY) ** 2,\n            ) <= THRESHOLD\n          ) {\n            return handler({ datumIndex, datum });\n          }\n        }\n        reset();\n        handler();\n      };\n\n      graph\n        .on('mousemove', handleGraphEventWith(handleHover))\n        .on('mouseout', reset)\n        .on('click', handleGraphEventWith(handleClick));\n\n      /**\n       * @param {(object: object) => void} handler\n       */\n      const handleLegendEventWith = handler => () => {\n        const node = refs.legendCanvas.node();\n        if (!(node && 'getBoundingClientRect' in node)) return;\n        const { left, width } = node.getBoundingClientRect();\n        const { pageX } = event;\n        const position = (pageX - left) / width;\n        const datumIndex = Math.floor(position * processed.data.length);\n        handler({ datumIndex, datum: processed.data[datumIndex] });\n      };\n\n      refs.drawLegend(processed.data, refs.xScale, refs.yScale, width, height);\n\n      refs.legendCanvas\n        .on('mousemove', handleLegendEventWith(handleHover))\n        .on('mouseout', reset)\n        .on('click', handleLegendEventWith(handleClick));\n    };\n\n    window.addEventListener('resize', drawRef.current);\n\n    return () => {\n      // clean up\n      refs.drawLegend && refs.drawLegend.cancel();\n      window.removeEventListener('resize', drawRef.current);\n    };\n  }, [projections, setRequestedFrame, datumRange, totalFrames]);\n\n  useEffect(() => {\n    const [xProj, yProj] = switched ? [0, 1] : [1, 0];\n\n    const colorScaleWithDomain = colorScale.domain([0, coordinatesCount]);\n\n    const xProjectionData = projectionsData[projections[xProj]];\n    const yProjectionData = projectionsData[projections[yProj]];\n    const zipped = zip(xProjectionData, yProjectionData);\n    const processed = {\n      data: zipped.map(([x, y], i) => {\n        const hex = colorScaleWithDomain(i);\n        return {\n          x,\n          y,\n          fill: { hex, ...rgb(hex) },\n        };\n      }),\n      xMinMax: [Math.min(...xProjectionData), Math.max(...xProjectionData)],\n      yMinMax: [Math.min(...yProjectionData), Math.max(...yProjectionData)],\n      framestep,\n      projections: [projections[xProj], projections[yProj]],\n    };\n\n    processedRef.current = processed;\n\n    drawRef.current({ processed });\n\n    // calculate Delaunay graph to later find points from mouse position\n    (async () => {\n      // delay a bit, to prioritise drawing\n      await sleep(MAX_DELAY + MAX_DURATION);\n      await schedule(100);\n      delaunayDiagramRef.current = Delaunay.from(zipped);\n    })();\n  }, [projectionsData, coordinatesCount, projections, framestep, switched]);\n\n  return (\n    <>\n      <div\n        className={style['graph-container']}\n        onDoubleClick={drawRef.current}\n        ref={containerRef}\n      />\n      <div className={style.legend}>\n        <IconButton\n          title=\"Switch axes\"\n          className={cn(style.switch, { [style.switched]: switched })}\n          onClick={toggleSwitched}\n          size=\"large\"\n        >\n          <FontAwesomeIcon icon={faRandom} />\n        </IconButton>\n        <p>position in simulation:</p>\n        <div className={style['color-scale']}>\n          <div>start</div>\n          <div ref={legendRef}>\n            <canvas height=\"1\" width={coordinatesCount} />\n            <div className={style.cursor} />\n          </div>\n          <div>end</div>\n        </div>\n      </div>\n      <div className={style.tooltip} ref={tooltipRef} />\n    </>\n  );\n};\n\nexport default Projections;\n","export default context => (data, xScale, yScale, width, height) => {\n  const imgData = context.createImageData(data.length, 1);\n  // create a 32 bytes view on image data\n  const uInt32View = new Uint32Array(imgData.data.buffer);\n\n  data.forEach(({ x, y, fill: { r, g, b } }, i) => {\n    let opacity = 255;\n    if (xScale) {\n      const onScreenX = xScale(x);\n      if (onScreenX < 0 || onScreenX > width) {\n        opacity = 100;\n      } else {\n        const onScreenY = yScale(y);\n        if (onScreenY < 0 || onScreenY > height) opacity = 100;\n      }\n    }\n\n    // fill r, g, b, and opacity in one go\n    uInt32View[i] = opacity * 0x1000000 + b * 0x10000 + g * 0x100 + r;\n  });\n\n  context.putImageData(imgData, 0, 0);\n};\n"],"names":["dPR","window","devicePixelRatio","customElastic","easeElastic","amplitude","period","t","MARGIN","MAX_DELAY","MIN_DURATION","MAX_DURATION","colorScale","scaleSequential","interpolateViridis","_ref","framestep","projectionsData","projections","datumRange","totalFrames","setRequestedFrame","containerRef","useRef","legendRef","drawRef","noop","dataPointsRef","processedRef","tooltipRef","delaunayDiagramRef","find","switched","toggleSwitched","useToggleState","coordinatesCount","useMemo","length","useEffect","canvas","select","current","append","graph","context","node","getContext","alpha","desynchronized","brushInstance","brush","refs","xScale","scaleLinear","yScale","xAxis","attr","style","axis","yAxis","xAxisLegend","cn","yAxisLegend","dataPoints","hover","legendCanvas","legendCursor","cursor","brushElement","drawLegend","debounce","data","width","height","imgData","createImageData","uInt32View","Uint32Array","buffer","forEach","i","x","y","fill","r","g","b","opacity","onScreenX","onScreenY","putImageData","getDrawLegend","reset","onlyTooltip","arguments","undefined","display","handleClick","datumIndex","currentFrame","console","error","target","async","processed","brushing","frame","firstChild","clientWidth","clientHeight","call","isFirstTime","range","domain","xMinMax","yMinMax","transition","duration","reducedMotion","clamp","axisBottom","ticks","Math","round","tickFormat","d","text","axisLeft","on","selection","event","map","invert","move","radiusScale","log","max","radius","min","maxTime","currentRadius","_ref2","_ref3","xValue","yValue","xPoint","yPoint","delay","random","time","currentX","currentY","interpolateX","interpolate","interpolateY","interpolateRadius","Promise","res","stop","timer","elapsed","isLastDraw","fillStyle","fillRect","dataPoint","easedProgress","easeCubicInOut","hex","beginPath","arc","PI","movePoints","handleHover","datum","Number","isInteger","scrollX","scrollY","left","top","getBoundingClientRect","innerHTML","rect","transform","handleGraphEventWith","handler","pageX","pageY","mouseX","mouseY","datumX","datumY","sqrt","abs","handleLegendEventWith","position","floor","addEventListener","cancel","removeEventListener","xProj","yProj","colorScaleWithDomain","xProjectionData","yProjectionData","zipped","zip","_ref4","rgb","sleep","schedule","Delaunay","from","_jsxs","_Fragment","children","_jsx","className","onDoubleClick","ref","legend","IconButton","title","switch","onClick","size","FontAwesomeIcon","icon","faRandom","tooltip"],"sourceRoot":""}