{"version":3,"file":"static/js/projections.805512e6.chunk.js","mappings":"sQAGA,MAAMA,EAAMC,OAAOC,kBAAoB,EAGjCC,EAAgBC,EAAAA,IAAYC,UAAU,GAAGC,OAAO,IAGtD,IAAIC,E,gDCRJ,SAAgB,kBAAkB,+BAA+B,KAAO,oBAAoB,cAAc,2BAA2B,OAAS,sBAAsB,OAAS,sBAAsB,SAAW,wBAAwB,cAAc,2BAA2B,OAAS,sBAAsB,QAAU,wB,eC6BxT,MAAMP,EAAMC,OAAOC,kBAAoB,EAKjCM,EAAgB,GAAhBA,EAA2B,GAA3BA,EAAuC,GAAvCA,EAAiD,GAGjDC,EAAY,KACXC,EAAcC,GAAgB,CAAC,IAAK,KAErCC,GAAaC,EAAAA,EAAAA,KAAgBC,EAAAA,KAuanC,EAnaoBC,IAOb,IAPc,UACnBC,EAAS,gBACTC,EAAe,YACfC,EAAW,WACXC,EAAU,YACVC,EAAW,kBACXC,GACDN,EACC,MAAMO,GAAeC,EAAAA,EAAAA,QAAO,MACtBC,GAAYD,EAAAA,EAAAA,QAAO,MACnBE,GAAUF,EAAAA,EAAAA,QAAOG,EAAAA,GACjBC,GAAgBJ,EAAAA,EAAAA,QAAO,MACvBK,GAAeL,EAAAA,EAAAA,QAAO,MACtBM,GAAaN,EAAAA,EAAAA,QAAO,MACpBO,GAAqBP,EAAAA,EAAAA,QAAO,CAAEQ,IAAAA,GAAQ,KAErCC,EAAUC,IAAkBC,EAAAA,EAAAA,IAAe,IAElDC,EAAAA,EAAAA,YAAU,KACR,MAAMC,GAASC,EAAAA,EAAAA,KAAOf,EAAagB,SAASC,OAAO,UAC7CC,GAAQH,EAAAA,EAAAA,KAAOf,EAAagB,SAASC,OAAO,OAE5CE,EAAUL,EACbM,OACAC,WAAW,KAAM,CAAEC,OAAO,EAAOC,gBAAgB,IAE9CC,GAAgBC,EAAAA,EAAAA,OAEhBC,EAAO,CACXC,QAAQC,EAAAA,EAAAA,OACRC,QAAQD,EAAAA,EAAAA,OACRE,MAAOZ,EAAMD,OAAO,KAAKc,KAAK,QAASC,EAAMC,MAC7CC,MAAOhB,EAAMD,OAAO,KAAKc,KAAK,QAASC,EAAMC,MAC7CE,YAAajB,EACVD,OAAO,QACPc,KAAK,QAASK,IAAGJ,EAAMC,KAAMD,EAAM,iBACtCK,YAAanB,EACVD,OAAO,QACPc,KAAK,QAASK,IAAGJ,EAAMC,KAAMD,EAAM,iBACtCM,WAAYpB,EAAMD,OAAO,KAAKc,KAAK,QAASC,EAAM,gBAClDO,MAAOrB,EAAMD,OAAO,UAAUc,KAAK,OAAQ,eAC3CS,cAAczB,EAAAA,EAAAA,KAAOb,EAAUc,SAASD,OAAO,UAC/C0B,cAAc1B,EAAAA,EAAAA,KAAOb,EAAUc,SAASD,OAAO,IAAIiB,EAAMU,UACzDjB,MAAOD,EACPmB,aAAczB,EAAMD,OAAO,KAAKc,KAAK,QAAS,UAIhDL,EAAKkB,YAAaC,EAAAA,EAAAA,GC7FtB,CAAe1B,GAAW,CAAC2B,EAAMnB,EAAQE,EAAQkB,EAAOC,KACtD,MAAMC,EAAU9B,EAAQ+B,gBAAgBJ,EAAKK,OAAQ,GAE/CC,EAAa,IAAIC,YAAYJ,EAAQH,KAAKQ,QAEhDR,EAAKS,SAAQ,CAAA9D,EAA8B+D,KAAO,IAApC,EAAEC,EAAC,EAAEC,EAAGC,MAAM,EAAEC,EAAC,EAAEC,EAAC,EAAEC,IAAKrE,EACnCsE,EAAU,IACd,GAAIpC,EAAQ,CACV,MAAMqC,EAAYrC,EAAO8B,GACzB,GAAIO,EAAY,GAAKA,EAAYjB,EAC/BgB,EAAU,QACL,CACL,MAAME,EAAYpC,EAAO6B,IACrBO,EAAY,GAAKA,EAAYjB,KAAQe,EAAU,IACrD,CACF,CAGAX,EAAWI,GAAe,SAAVO,EAA0B,MAAJD,EAAkB,IAAJD,EAAYD,CAAC,IAGnEzC,EAAQ+C,aAAajB,EAAS,EAAG,EAAE,EDyE/BkB,CAAczC,EAAKc,aAAapB,OAAOC,WAAW,KAAM,CAAEC,OAAO,KACjEnC,EAAYE,GAGd,MAAM+E,EAAQ,WAA2B,IAA1B,YAAEC,GAAaC,UAAAnB,OAAA,QAAAoB,IAAAD,UAAA,GAAAA,UAAA,GAAG,CAAC,EAChC/D,EAAWS,QAAQgB,MAAMwC,QAAU,OACnC9C,EAAKa,MAAMR,KAAK,OAAQ,eACpBsC,IACJ3C,EAAKe,aAAaT,MAAM,OAAQ,IAChCN,EAAKe,aAAaT,MAAM,UAAW,GACrC,EAGMyC,EAAc,eAAC,WAAEC,GAAYJ,UAAAnB,OAAA,QAAAoB,IAAAD,UAAA,GAAAA,UAAA,GAAG,CAAC,EAAC,OAEtCvE,GAAkB4E,IAChB,IAAK7E,EAEH,OADA8E,QAAQC,MAAM,wEACP,KAET,MAAMC,EAASC,KAAKC,MAAMN,GAAc5E,EAAcD,IAEtD,OAAOiF,IAAWH,EAAiB,KAAOG,CAAM,GAChD,EA6QJ,OA3QA3E,EAAQa,QAAUiE,iBAGN,IAHa,UACvBC,EAAY5E,EAAaU,QAAO,SAChCmE,GACDb,UAAAnB,OAAA,QAAAoB,IAAAD,UAAA,GAAAA,UAAA,GAAG,CAAC,EACH,IAAKY,EAAW,OAEhB,SADME,EAAAA,EAAAA,OACDpF,EAAagB,QAAQqE,WAAY,OAGtC,MAAQC,YAAavC,EAAOwC,aAAcvC,GAAWhD,EAAagB,QAClEE,EAAMa,KAAK,QAASgB,GAAOhB,KAAK,SAAUiB,GACtClC,EAAOiB,KAAK,WAAa,GAAGgB,EAAQrE,GACtCoC,EAAOiB,KAAK,QAASgB,EAAQrE,GAE3BoC,EAAOiB,KAAK,YAAc,GAAGiB,EAAStE,GACxCoC,EAAOiB,KAAK,SAAUiB,EAAStE,GAEjCoC,EAAOkB,MAAM,QAAS,GAAGe,OAAWf,MAAM,SAAU,GAAGgB,OAEvDtB,EAAKiB,aAAa6C,KAAK9D,EAAKD,OAE5B,MAAMgE,GAAepF,EAAcW,QAGnCU,EAAKC,OAAO+D,MAAM,CAACxG,EAAa6D,EAAQ7D,IACnCiG,GAAUzD,EAAKC,OAAOgE,OAAOT,EAAUU,SAG5ClE,EAAKG,OAAO6D,MAAM,CAAC1C,EAAS9D,EAAeA,IACtCiG,GAAUzD,EAAKG,OAAO8D,OAAOT,EAAUW,SAa5CnE,EAAKI,MACFgE,aACAC,UAAUN,KAAgBO,EAAAA,EAAAA,MAAmB7G,EAAYE,GACzDmG,MAdW3B,GACZA,EACG9B,KACC,YACA,iBAAgBkE,EAAAA,EAAAA,GAAMvE,EAAKG,OAAO,GAAI,EAAGmB,EAAS,QAEnDwC,MACCU,EAAAA,EAAAA,KAAWxE,EAAKC,QACbwE,MAAMpB,KAAKqB,MAAMrD,EAAQ,KACzBsD,YAAWC,GAAY,IAANA,EAAU,KAAOA,OAO3C5E,EAAKS,YACFoE,KAAK,8BAAyBrB,EAAUtF,YAAY,GAAK,YACzDkG,aACAC,UAAUN,KAAgBO,EAAAA,EAAAA,MAAmB7G,EAAYE,GACzD0C,KAAK,YAAa,aAAagB,EAAQ,MAAMC,EAAS,MAczDtB,EAAKQ,MACF4D,aACAC,UAAUN,KAAgBO,EAAAA,EAAAA,MAAmB7G,EAAYE,GACzDmG,MAdW3B,GACZA,EACG9B,KACC,YACA,cAAakE,EAAAA,EAAAA,GAAMvE,EAAKC,OAAO,GAAI,GAAIoB,EAAQ,UAEhDyC,MACCgB,EAAAA,EAAAA,KAAS9E,EAAKG,QACXsE,MAAMpB,KAAKqB,MAAMpD,EAAS,KAC1BqD,YAAWC,GAAY,IAANA,EAAU,KAAOA,OAO3C5E,EAAKW,YACFkE,KAAK,8BAAyBrB,EAAUtF,YAAY,GAAK,YACzDkG,aACAC,UAAUN,KAAgBO,EAAAA,EAAAA,MAAmB7G,EAAYE,GACzD0C,KAAK,YAAa,gBAAgBiB,EAAS,iBAE9CtB,EAAKD,MAAMgF,GAAG,OAAO,KACnB,MAAM,UAAEC,GAAcC,EAAAA,IACjBD,IACLhF,EAAKC,OAAOgE,OACV,CAACe,EAAU,GAAG,GAAIA,EAAU,GAAG,IAAIE,IACjClF,EAAKC,OAAOkF,OACZnF,EAAKC,SAGTD,EAAKG,OAAO8D,OACV,CAACe,EAAU,GAAG,GAAIA,EAAU,GAAG,IAAIE,IACjClF,EAAKG,OAAOgF,OACZnF,EAAKG,SAITH,EAAKiB,aAAa6C,KAAK9D,EAAKD,MAAMqF,KAAM,MACxC3G,EAAQa,QAAQ,CAAEmE,UAAU,IAAO,IAGrC,MAAM4B,EACJhC,KAAKiC,IACHjC,KAAKkC,KACF/B,EAAUU,QAAQ,GAAKV,EAAUU,QAAQ,KACvClE,EAAKC,OAAOgE,SAAS,GAAKjE,EAAKC,OAAOgE,SAAS,KACjDT,EAAUW,QAAQ,GAAKX,EAAUW,QAAQ,KACvCnE,EAAKG,OAAO8D,SAAS,GAAKjE,EAAKG,OAAO8D,SAAS,MAElD,EACAuB,EAAUxI,EAAMqG,KAAKoC,IAAIpE,EAAOC,GAAU+D,EAAe,IAE/DrF,EAAKa,MAAMR,KAAK,IAAKmF,EAAS,GAG9B,IAAIE,EAAU,EACd,MAAMC,EAAgB5B,EAClB,EACApF,EAAcW,QAAQqG,cAC1BhH,EAAcW,QAAUkE,EAAUpC,KAAK8D,KACrC,CAAAU,EAAiC9D,EAAC+D,KAAkB,IAAjD9D,EAAG+D,EAAQ9D,EAAG+D,EAAM,KAAE9D,GAAM2D,GAAK,OAAEnE,GAAQoE,EAC5C,MAAMG,EAAShG,EAAKC,OAAO6F,GAAU9I,EAC/BiJ,EAASjG,EAAKG,OAAO4F,GAAU/I,EAC/BkJ,EAASpE,EAAIrE,GAAasG,EAAc,EAAI,GAAMtC,EAClD4C,GAAWC,EAAAA,EAAAA,KACb,GACA6B,EAAAA,EAAAA,GAAOzI,EAAcC,IAAiBoG,EAAc,EAAI,GACtDqC,EAAOF,EAAQ7B,EAGrB,OADIqB,EAAUU,IAAMV,EAAUU,GACvB,CACLC,SAAU,KACVC,SAAU,KACVX,cAAe,KACfY,cAAcC,EAAAA,EAAAA,KACZzC,EACI/D,EAAKC,OAAO,GAAKjD,EACjB2B,EAAcW,QAAQwC,GAAGuE,UACvB1H,EAAcW,QAAQwC,GAAGC,EAC/BiE,GAEFS,cAAcD,EAAAA,EAAAA,KACZzC,EACI/D,EAAKG,OAAO,GAAKnD,EACjB2B,EAAcW,QAAQwC,GAAGwE,UACvB3H,EAAcW,QAAQwC,GAAGE,EAC/BiE,GAEFC,QACA7B,WACAtC,EAAGiE,EACHhE,EAAGiE,EACHhE,OACD,IAKLtD,EAAcW,QAAQoH,mBAAoBF,EAAAA,EAAAA,KACxCb,EACAH,GFvQR,CAAezH,IAAA,IAAC,QAAE0B,EAAO,WAAEmB,EAAU,MAAES,EAAK,OAAEC,EAAM,QAAEoE,EAAO,YAAE3B,GAAahG,EAC1E,IAAI4I,SAAQC,IACNrJ,GAAGA,EAAEsJ,OACTtJ,GAAIuJ,EAAAA,EAAAA,MAAMC,IACR,MAAMC,EAAaD,GAAWrB,EAE1BsB,GACFzJ,EAAEsJ,OACFpH,EAAQwH,UAAY,QACpBxH,EAAQyH,SAAS,EAAG,EAAG7F,EAAQrE,EAAKsE,EAAStE,KAK7CyC,EAAQwH,UAAY,4BACpBxH,EAAQyH,SAAS,EAAG,EAAG7F,EAAQrE,EAAKsE,EAAStE,IAG/C,IAAK,MAAMmK,KAAavG,EAAY,CAClC,MAAMwG,EAAgB/D,KAAKkC,IACzB,GACCxB,EAAc5G,EAAgBkK,EAAAA,KAC7BhE,KAAKoC,KAAKsB,EAAUI,EAAUjB,OAASiB,EAAU9C,SAAU,KAI/D8C,EAAUd,SAAWc,EAAUZ,aAAaa,GAExCD,EAAUd,SAAW,GAAKc,EAAUd,SAAWhF,IACnD8F,EAAUb,SAAWa,EAAUV,aAAaW,GAE5CxG,EAAW+E,cAAgB/E,EAAW8F,kBAAkBU,GAEpDD,EAAUb,SAAW,GAAKa,EAAUb,SAAWhF,IAEnD7B,EAAQwH,UAAYE,EAAUlF,KAAKqF,IACnC7H,EAAQ8H,YACR9H,EAAQ+H,IACNL,EAAUd,SACVc,EAAUb,SACV1F,EAAW+E,cACX,EACA,EAAItC,KAAKoE,IAEXhI,EAAQwC,QACV,CACI+E,GAAYJ,GAAK,GACrB,GACF,EE4NEc,CAAW,CACTjI,UACAmB,WAAYjC,EAAcW,QAC1B+B,MAAOA,EAAQrE,EACfsE,OAAQA,EAAStE,EACjB0I,UACA3B,gBAGF,MAAM4D,EAAc,WAAiC,IAAhC,WAAE3E,EAAU,MAAE4E,GAAOhF,UAAAnB,OAAA,QAAAoB,IAAAD,UAAA,GAAAA,UAAA,GAAG,CAAC,EAC5C,IAAKiF,OAAOC,UAAU9E,KAAgB4E,EAAO,OAE7C5H,EAAKe,aAAaT,MAChB,OACA,QAAS,IAAM0C,EAAcQ,EAAUpC,KAAKK,kBAE9CzB,EAAKe,aAAaT,MAAM,UAAW,GAGnC,MAAMyB,EAAI/B,EAAKC,OAAO2H,EAAM7F,GAC5B,GAAIA,EAAI,GAAKA,EAAIV,EAAO,OAAOqB,EAAM,CAAEC,aAAa,IACpD,MAAMX,EAAIhC,EAAKG,OAAOyH,EAAM5F,GAC5B,GAAIA,EAAI,GAAKA,EAAIV,EAAQ,OAAOoB,EAAM,CAAEC,aAAa,IAErD,MAAM,QAAEoF,EAAO,QAAEC,GAAY/K,QACvB,KAAEgL,EAAI,IAAEC,GAAQ5J,EAAagB,QAAQ6I,wBAC3CtJ,EAAWS,QAAQ8I,UAAY,2CAEhBpF,EAAaQ,EAAUxF,UAChC,oEACuBwF,EAAUtF,YAAY,GAAK,MACtD0J,EAAM7F,6CAEqByB,EAAUtF,YAAY,GAAK,MACtD0J,EAAM5F,oCAIRnD,EAAWS,QAAQgB,MAAMwC,QAAU,eACnC,MAAMuF,EAAOxJ,EAAWS,QAAQ6I,wBAChCtJ,EAAWS,QAAQgB,MAAMgI,UAAY,aAAavG,EAChDkG,EACAF,EACAM,EAAKhH,MAAQ,QAAQW,EAAIkG,EAAMF,EAAUK,EAAK/G,OAAS,QACzDtB,EAAKa,MACFR,KAAK,KAAM0B,GACX1B,KAAK,KAAM2B,GACX3B,KAAK,OAAQuH,EAAM3F,KAAKqF,IAC7B,EAEMiB,EAAuBC,GAAW,KACtC,MAAM,QAAET,EAAO,QAAEC,GAAY/K,QACvB,KAAEgL,EAAI,IAAEC,GAAQ5J,EAAagB,QAAQ6I,yBACrC,MAAEM,EAAK,MAAEC,GAAUzD,EAAAA,IACnB0D,EAASF,EAAQR,EAAOF,EACxBa,EAASF,EAAQR,EAAMF,EAGvBhF,EAAalE,EAAmBQ,QAAQP,KAC5CiB,EAAKC,OAAOkF,OAAOwD,GACnB3I,EAAKG,OAAOgF,OAAOyD,IAEfhB,EAAQpE,EAAUpC,KAAK4B,GAC7B,GAAI4E,EAAO,CACT,MAAMiB,EAAS7I,EAAKC,OAAO2H,EAAM7F,GAC3B+G,EAAS9I,EAAKG,OAAOyH,EAAM5F,GAEjC,GACEqB,KAAK0F,KACH1F,KAAK2F,IAAIH,EAASF,IAAW,EAAItF,KAAK2F,IAAIF,EAASF,IAAW,IA3T1D,GA8TN,OAAOJ,EAAQ,CAAExF,aAAY4E,SAEjC,CACAlF,IACA8F,GAAS,EAGXhJ,EACGuF,GAAG,YAAawD,EAAqBZ,IACrC5C,GAAG,WAAYrC,GACfqC,GAAG,QAASwD,EAAqBxF,IAKpC,MAAMkG,EAAwBT,GAAW,KACvC,MAAM9I,EAAOM,EAAKc,aAAapB,OAC/B,IAAMA,KAAQ,0BAA2BA,GAAO,OAChD,MAAM,KAAEuI,EAAI,MAAE5G,GAAU3B,EAAKyI,yBACvB,MAAEM,GAAUxD,EAAAA,IACZiE,GAAYT,EAAQR,GAAQ5G,EAC5B2B,EAAaK,KAAKC,MAAM4F,EAAW1F,EAAUpC,KAAKK,QACxD+G,EAAQ,CAAExF,aAAY4E,MAAOpE,EAAUpC,KAAK4B,IAAc,EAG5DhD,EAAKkB,WAAWsC,EAAUpC,KAAMpB,EAAKC,OAAQD,EAAKG,OAAQkB,EAAOC,GAEjEtB,EAAKc,aACFiE,GAAG,YAAakE,EAAsBtB,IACtC5C,GAAG,WAAYrC,GACfqC,GAAG,QAASkE,EAAsBlG,GACvC,EAEA9F,OAAOkM,iBAAiB,SAAU1K,EAAQa,SAEnC,KAELU,EAAKkB,YAAclB,EAAKkB,WAAWkI,SACnCnM,OAAOoM,oBAAoB,SAAU5K,EAAQa,QAAQ,CACtD,GACA,CAACpB,EAAaG,EAAmBF,EAAYC,KAEhDe,EAAAA,EAAAA,YAAU,KACR,MAAOmK,EAAOC,GAASvK,EAAW,CAAC,EAAG,GAAK,CAAC,EAAG,GAEzCwK,EACHvL,GAAmBA,EAAgB,GAAGwD,QAAW,EAC9CgI,EAAuB7L,EAAWqG,OAAO,CAAC,EAAGuF,IAE7CE,EAAkBzL,EAAgBC,EAAYoL,IAC9CK,EAAkB1L,EAAgBC,EAAYqL,IAC9CK,GAASC,EAAAA,EAAAA,GAAIH,EAAiBC,GAC9BnG,EAAY,CAChBpC,KAAMwI,EAAO1E,KAAI,CAAA4E,EAAShI,KAAO,IAAdC,EAAGC,GAAE8H,EACtB,MAAMxC,EAAMmC,EAAqB3H,GACjC,MAAO,CACLC,IACAC,IACAC,KAAM,CAAEqF,UAAQyC,EAAAA,EAAAA,KAAIzC,IACrB,IAEHpD,QAAS,CAACb,KAAKoC,OAAOiE,GAAkBrG,KAAKkC,OAAOmE,IACpDvF,QAAS,CAACd,KAAKoC,OAAOkE,GAAkBtG,KAAKkC,OAAOoE,IACpD3L,YACAE,YAAa,CAACA,EAAYoL,GAAQpL,EAAYqL,KAGhD3K,EAAaU,QAAUkE,EAEvB/E,EAAQa,QAAQ,CAAEkE,cAGlB,iBAEQwG,EAAAA,EAAAA,IAAMvM,EAAYE,SAClBsM,EAAAA,EAAAA,GAAS,KACfnL,EAAmBQ,QAAU4K,EAAAA,EAASC,KAAKP,EAC5C,EALD,EAKI,GACH,CAAC3L,EAAiBC,EAAaF,EAAWgB,IAE7C,MAAMwK,EAAoBvL,GAAmBA,EAAgB,GAAGwD,QAAW,EAE3E,OACE2I,EAAAA,EAAAA,MAAAC,EAAAA,SAAA,CAAAC,SAAA,EACEC,EAAAA,EAAAA,KAAA,OACEC,UAAWlK,EAAM,mBACjBmK,cAAehM,EAAQa,QACvBoL,IAAKpM,KAEP8L,EAAAA,EAAAA,MAAA,OAAKI,UAAWlK,EAAMqK,OAAOL,SAAA,EAC3BC,EAAAA,EAAAA,KAACK,EAAAA,EAAU,CACTC,MAAM,cACNL,UAAW9J,IAAGJ,EAAMwK,OAAQ,CAAE,CAACxK,EAAMtB,UAAWA,IAChD+L,QAAS9L,EACT+L,KAAK,QAAOV,UAEZC,EAAAA,EAAAA,KAACU,EAAAA,EAAe,CAACC,KAAMC,EAAAA,SAEzBZ,EAAAA,EAAAA,KAAA,KAAAD,SAAG,6BACHF,EAAAA,EAAAA,MAAA,OAAKI,UAAWlK,EAAM,eAAegK,SAAA,EACnCC,EAAAA,EAAAA,KAAA,OAAAD,SAAK,WACLF,EAAAA,EAAAA,MAAA,OAAKM,IAAKlM,EAAU8L,SAAA,EAClBC,EAAAA,EAAAA,KAAA,UAAQjJ,OAAO,IAAID,MAAOmI,KAC1Be,EAAAA,EAAAA,KAAA,OAAKC,UAAWlK,EAAMU,aAExBuJ,EAAAA,EAAAA,KAAA,OAAAD,SAAK,eAGTC,EAAAA,EAAAA,KAAA,OAAKC,UAAWlK,EAAM8K,QAASV,IAAK7L,MACnC,C","sources":["components/projections/move-points/index.js","webpack://mdposit/./src/components/projections/style.module.css?f675","components/projections/index.js","components/projections/get-draw-legend/index.js"],"sourcesContent":["import { timer, easeCubicInOut, easeElastic } from 'd3';\n\n// device pixel ratio (for \"retina\" screens)\nconst dPR = window.devicePixelRatio || 1;\n\n// easing for start animation (looks like a spring coming out of the centre)\nconst customElastic = easeElastic.amplitude(1).period(0.5);\n\n// timer instance variable\nlet t;\n\nexport default ({ context, dataPoints, width, height, maxTime, isFirstTime }) =>\n  new Promise(res => {\n    if (t) t.stop();\n    t = timer(elapsed => {\n      const isLastDraw = elapsed >= maxTime;\n      // if we finished transitioning, clear completely the canvas\n      if (isLastDraw) {\n        t.stop();\n        context.fillStyle = 'white';\n        context.fillRect(0, 0, width * dPR, height * dPR);\n      } else {\n        // clean up the canvas before drawing everything else\n        // using white, but opacity 0.25, to keep a shadow of the previous drawings\n        // to give the illusion of movement\n        context.fillStyle = `rgba(255, 255, 255, 0.25)`;\n        context.fillRect(0, 0, width * dPR, height * dPR);\n      }\n      // loop on every data point and draw them\n      for (const dataPoint of dataPoints) {\n        const easedProgress = Math.max(\n          0,\n          (isFirstTime ? customElastic : easeCubicInOut)(\n            Math.min((elapsed - dataPoint.delay) / dataPoint.duration, 1),\n          ),\n        );\n        // x\n        dataPoint.currentX = dataPoint.interpolateX(easedProgress);\n        // skip out-of-screen points\n        if (dataPoint.currentX < 0 || dataPoint.currentX > width) continue;\n        dataPoint.currentY = dataPoint.interpolateY(easedProgress);\n        // y\n        dataPoints.currentRadius = dataPoints.interpolateRadius(easedProgress);\n        // skip out-of-screen points\n        if (dataPoint.currentY < 0 || dataPoint.currentY > height) continue;\n        // draw point\n        context.fillStyle = dataPoint.fill.hex;\n        context.beginPath();\n        context.arc(\n          dataPoint.currentX,\n          dataPoint.currentY,\n          dataPoints.currentRadius,\n          0,\n          2 * Math.PI,\n        );\n        context.fill();\n      }\n      if (isLastDraw) res();\n    });\n  });\n","// extracted by mini-css-extract-plugin\nexport default {\"graph-container\":\"style_graph-container__oCOoS\",\"axis\":\"style_axis__H0KE8\",\"legend-text\":\"style_legend-text__Zvd0H\",\"legend\":\"style_legend__kYAHJ\",\"switch\":\"style_switch__vPk4i\",\"switched\":\"style_switched__DLS7l\",\"color-scale\":\"style_color-scale__mIyZh\",\"cursor\":\"style_cursor__uJXdm\",\"tooltip\":\"style_tooltip__S2WeP\"};","import React, { useRef, useEffect } from 'react';\nimport { noop, zip, random, debounce, clamp } from 'lodash-es';\nimport {\n  select,\n  scaleLinear,\n  axisLeft,\n  axisBottom,\n  scaleSequential,\n  interpolateViridis,\n  interpolate,\n  event,\n  brush,\n  rgb,\n} from 'd3';\nimport { Delaunay } from 'd3-delaunay';\nimport { schedule, sleep, frame } from 'timing-functions';\nimport cn from 'classnames';\n\nimport useToggleState from '../../hooks/use-toggle-state';\nimport movePoints from './move-points';\nimport getDrawLegend from './get-draw-legend';\nimport reducedMotion from '../../utils/reduced-motion';\n\nimport { IconButton } from '@mui/material';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faRandom } from '@fortawesome/free-solid-svg-icons';\n\nimport style from './style.module.css';\n\n// device pixel ratio (for \"retina\" screens)\nconst dPR = window.devicePixelRatio || 1;\n\n// delaunay diagram detection threshold\nconst THRESHOLD = 20;\n\nconst MARGIN = { top: 10, right: 10, bottom: 25, left: 25 };\n\n// animation constants\nconst MAX_DELAY = 500;\nconst [MIN_DURATION, MAX_DURATION] = [375, 625];\n\nconst colorScale = scaleSequential(interpolateViridis);\n\n// This component renders a graph\n// This graph is displayed when user selects 2 pca projections\nconst Projections = ({\n  framestep,\n  projectionsData,\n  projections,\n  datumRange,\n  totalFrames,\n  setRequestedFrame,\n}) => {\n  const containerRef = useRef(null);\n  const legendRef = useRef(null);\n  const drawRef = useRef(noop);\n  const dataPointsRef = useRef(null);\n  const processedRef = useRef(null);\n  const tooltipRef = useRef(null);\n  const delaunayDiagramRef = useRef({ find() {} });\n\n  const [switched, toggleSwitched] = useToggleState(false);\n\n  useEffect(() => {\n    const canvas = select(containerRef.current).append('canvas');\n    const graph = select(containerRef.current).append('svg');\n\n    const context = canvas\n      .node()\n      .getContext('2d', { alpha: false, desynchronized: true });\n\n    const brushInstance = brush();\n\n    const refs = {\n      xScale: scaleLinear(),\n      yScale: scaleLinear(),\n      xAxis: graph.append('g').attr('class', style.axis),\n      yAxis: graph.append('g').attr('class', style.axis),\n      xAxisLegend: graph\n        .append('text')\n        .attr('class', cn(style.axis, style['legend-text'])),\n      yAxisLegend: graph\n        .append('text')\n        .attr('class', cn(style.axis, style['legend-text'])),\n      dataPoints: graph.append('g').attr('class', style['data-points']),\n      hover: graph.append('circle').attr('fill', 'transparent'),\n      legendCanvas: select(legendRef.current).select('canvas'),\n      legendCursor: select(legendRef.current).select(`.${style.cursor}`),\n      brush: brushInstance,\n      brushElement: graph.append('g').attr('class', 'brush'),\n    };\n\n    // debounce it to prevent redrawing that too much\n    refs.drawLegend = debounce(\n      getDrawLegend(refs.legendCanvas.node().getContext('2d', { alpha: true })),\n      MAX_DELAY + MAX_DURATION,\n    );\n\n    const reset = ({ onlyTooltip } = {}) => {\n      tooltipRef.current.style.display = 'none';\n      refs.hover.attr('fill', 'transparent');\n      if (onlyTooltip) return;\n      refs.legendCursor.style('left', '');\n      refs.legendCursor.style('opacity', 0);\n    };\n\n    // Select the frame to be displayed by the viewer\n    const handleClick = ({ datumIndex } = {}) =>\n      // This function is a setter from a useState hook in the parent script (pca/index.js)\n      setRequestedFrame(requestedFrame => {\n        if (!totalFrames) {\n          console.error('No number of frames in metadata. Are we missing the main trajectory?');\n          return null;\n        }\n        const target = Math.floor(datumIndex * (totalFrames / datumRange));\n        // If the user clicks in the already selected point it is unselected\n        return target === requestedFrame ? null : target;\n      });\n\n    drawRef.current = async ({\n      processed = processedRef.current,\n      brushing,\n    } = {}) => {\n      if (!processed) return;\n      await frame();\n      if (!containerRef.current.firstChild) return;\n\n      // container size\n      const { clientWidth: width, clientHeight: height } = containerRef.current;\n      graph.attr('width', width).attr('height', height);\n      if (canvas.attr('width') !== `${width * dPR}`) {\n        canvas.attr('width', width * dPR);\n      }\n      if (canvas.attr('height') !== `${height * dPR}`) {\n        canvas.attr('height', height * dPR);\n      }\n      canvas.style('width', `${width}px`).style('height', `${height}px`);\n\n      refs.brushElement.call(refs.brush);\n\n      const isFirstTime = !dataPointsRef.current;\n\n      // x axis\n      refs.xScale.range([MARGIN.left, width - MARGIN.right]);\n      if (!brushing) refs.xScale.domain(processed.xMinMax);\n\n      // y axis\n      refs.yScale.range([height - MARGIN.bottom, MARGIN.top]);\n      if (!brushing) refs.yScale.domain(processed.yMinMax);\n      // visual x axis\n      const xAxis = g =>\n        g\n          .attr(\n            'transform',\n            `translate(0, ${clamp(refs.yScale(0), 0, height - 32)})`,\n          )\n          .call(\n            axisBottom(refs.xScale)\n              .ticks(Math.round(width / 75))\n              .tickFormat(d => (d === 0 ? null : d)),\n          );\n      refs.xAxis\n        .transition()\n        .duration(!isFirstTime && !reducedMotion() && MAX_DELAY + MAX_DURATION)\n        .call(xAxis);\n\n      refs.xAxisLegend\n        .text(`← principal component ${processed.projections[0] + 1} →`)\n        .transition()\n        .duration(!isFirstTime && !reducedMotion() && MAX_DELAY + MAX_DURATION)\n        .attr('transform', `translate(${width / 2}, ${height - 5})`);\n\n      // visual y axis\n      const yAxis = g =>\n        g\n          .attr(\n            'transform',\n            `translate(${clamp(refs.xScale(0), 30, width - 1)}, 0)`,\n          )\n          .call(\n            axisLeft(refs.yScale)\n              .ticks(Math.round(height / 75))\n              .tickFormat(d => (d === 0 ? null : d)),\n          );\n      refs.yAxis\n        .transition()\n        .duration(!isFirstTime && !reducedMotion() && MAX_DELAY + MAX_DURATION)\n        .call(yAxis);\n\n      refs.yAxisLegend\n        .text(`← principal component ${processed.projections[1] + 1} →`)\n        .transition()\n        .duration(!isFirstTime && !reducedMotion() && MAX_DELAY + MAX_DURATION)\n        .attr('transform', `translate(5, ${height / 2}) rotate(90)`);\n\n      refs.brush.on('end', () => {\n        const { selection } = event;\n        if (!selection) return;\n        refs.xScale.domain(\n          [selection[0][0], selection[1][0]].map(\n            refs.xScale.invert,\n            refs.xScale,\n          ),\n        );\n        refs.yScale.domain(\n          [selection[1][1], selection[0][1]].map(\n            refs.yScale.invert,\n            refs.yScale,\n          ),\n        );\n        // remove visual brush rectangle\n        refs.brushElement.call(refs.brush.move, null);\n        drawRef.current({ brushing: true });\n      });\n\n      const radiusScale =\n        Math.log(\n          Math.max(\n            (processed.xMinMax[1] - processed.xMinMax[0]) /\n              (refs.xScale.domain()[1] - refs.xScale.domain()[0]),\n            (processed.yMinMax[1] - processed.yMinMax[0]) /\n              (refs.yScale.domain()[1] - refs.yScale.domain()[0]),\n          ),\n        ) + 1;\n      const radius = (dPR * Math.min(width, height) * radiusScale) / 250;\n      // hover circle\n      refs.hover.attr('r', radius + 5);\n\n      // data points\n      let maxTime = 0;\n      const currentRadius = isFirstTime\n        ? 0\n        : dataPointsRef.current.currentRadius;\n      dataPointsRef.current = processed.data.map(\n        ({ x: xValue, y: yValue, fill }, i, { length }) => {\n          const xPoint = refs.xScale(xValue) * dPR;\n          const yPoint = refs.yScale(yValue) * dPR;\n          const delay = (i * MAX_DELAY * (isFirstTime ? 2 : 1)) / length;\n          const duration = reducedMotion()\n            ? 0\n            : random(MIN_DURATION, MAX_DURATION) * (isFirstTime ? 2 : 1);\n          const time = delay + duration;\n          // update maxTime if needed\n          if (maxTime < time) maxTime = time;\n          return {\n            currentX: null,\n            currentY: null,\n            currentRadius: null,\n            interpolateX: interpolate(\n              isFirstTime\n                ? refs.xScale(0) * dPR\n                : dataPointsRef.current[i].currentX ||\n                    dataPointsRef.current[i].x,\n              xPoint,\n            ),\n            interpolateY: interpolate(\n              isFirstTime\n                ? refs.yScale(0) * dPR\n                : dataPointsRef.current[i].currentY ||\n                    dataPointsRef.current[i].y,\n              yPoint,\n            ),\n            delay,\n            duration,\n            x: xPoint,\n            y: yPoint,\n            fill,\n          };\n        },\n      );\n\n      // same radius interpolation for all the points, so keep only one\n      dataPointsRef.current.interpolateRadius = interpolate(\n        currentRadius,\n        radius,\n      );\n\n      // will trigger a timer animate points\n      // Render the graph\n      movePoints({\n        context,\n        dataPoints: dataPointsRef.current,\n        width: width * dPR,\n        height: height * dPR,\n        maxTime,\n        isFirstTime,\n      });\n\n      const handleHover = ({ datumIndex, datum } = {}) => {\n        if (!Number.isInteger(datumIndex) || !datum) return;\n        // bottom cursor\n        refs.legendCursor.style(\n          'left',\n          `calc(${(100 * datumIndex) / processed.data.length}% - 4px)`,\n        );\n        refs.legendCursor.style('opacity', 1);\n\n        // would tooltip be visible?\n        const x = refs.xScale(datum.x);\n        if (x < 0 || x > width) return reset({ onlyTooltip: true });\n        const y = refs.yScale(datum.y);\n        if (y < 0 || y > height) return reset({ onlyTooltip: true });\n        // yes, then display tooltip\n        const { scrollX, scrollY } = window;\n        const { left, top } = containerRef.current.getBoundingClientRect();\n        tooltipRef.current.innerHTML = `\n          <div>\n            <p>Frame ${datumIndex * processed.framestep +\n              1} (click to open viewer)</p>\n            <p>Principal component ${processed.projections[0] + 1}: ${\n          datum.x\n        }</p>\n            <p>Principal component ${processed.projections[1] + 1}: ${\n          datum.y\n        }</p>\n          </div>\n        `;\n        tooltipRef.current.style.display = 'inline-block';\n        const rect = tooltipRef.current.getBoundingClientRect();\n        tooltipRef.current.style.transform = `translate(${x +\n          left +\n          scrollX -\n          rect.width / 2}px, ${y + top + scrollY - rect.height - 15}px)`;\n        refs.hover\n          .attr('cx', x)\n          .attr('cy', y)\n          .attr('fill', datum.fill.hex);\n      };\n\n      const handleGraphEventWith = handler => () => {\n        const { scrollX, scrollY } = window;\n        const { left, top } = containerRef.current.getBoundingClientRect();\n        const { pageX, pageY } = event;\n        const mouseX = pageX - left - scrollX;\n        const mouseY = pageY - top - scrollY;\n        // invert the mouse position with the scale because we only computed the\n        // Delaunay graph once on the raw data for optimisation purposes\n        const datumIndex = delaunayDiagramRef.current.find(\n          refs.xScale.invert(mouseX),\n          refs.yScale.invert(mouseY),\n        );\n        const datum = processed.data[datumIndex];\n        if (datum) {\n          const datumX = refs.xScale(datum.x);\n          const datumY = refs.yScale(datum.y);\n          // is within threshold?\n          if (\n            Math.sqrt(\n              Math.abs(datumX - mouseX) ** 2 + Math.abs(datumY - mouseY) ** 2,\n            ) <= THRESHOLD\n          ) {\n            return handler({ datumIndex, datum });\n          }\n        }\n        reset();\n        handler();\n      };\n\n      graph\n        .on('mousemove', handleGraphEventWith(handleHover))\n        .on('mouseout', reset)\n        .on('click', handleGraphEventWith(handleClick));\n\n      /**\n       * @param {(object: object) => void} handler\n       */\n      const handleLegendEventWith = handler => () => {\n        const node = refs.legendCanvas.node();\n        if (!(node && 'getBoundingClientRect' in node)) return;\n        const { left, width } = node.getBoundingClientRect();\n        const { pageX } = event;\n        const position = (pageX - left) / width;\n        const datumIndex = Math.floor(position * processed.data.length);\n        handler({ datumIndex, datum: processed.data[datumIndex] });\n      };\n\n      refs.drawLegend(processed.data, refs.xScale, refs.yScale, width, height);\n\n      refs.legendCanvas\n        .on('mousemove', handleLegendEventWith(handleHover))\n        .on('mouseout', reset)\n        .on('click', handleLegendEventWith(handleClick));\n    };\n\n    window.addEventListener('resize', drawRef.current);\n\n    return () => {\n      // clean up\n      refs.drawLegend && refs.drawLegend.cancel();\n      window.removeEventListener('resize', drawRef.current);\n    };\n  }, [projections, setRequestedFrame, datumRange, totalFrames]);\n\n  useEffect(() => {\n    const [xProj, yProj] = switched ? [0, 1] : [1, 0];\n\n    const coordinatesCount =\n      (projectionsData && projectionsData[0].length) || 0;\n    const colorScaleWithDomain = colorScale.domain([0, coordinatesCount]);\n\n    const xProjectionData = projectionsData[projections[xProj]];\n    const yProjectionData = projectionsData[projections[yProj]];\n    const zipped = zip(xProjectionData, yProjectionData);\n    const processed = {\n      data: zipped.map(([x, y], i) => {\n        const hex = colorScaleWithDomain(i);\n        return {\n          x,\n          y,\n          fill: { hex, ...rgb(hex) },\n        };\n      }),\n      xMinMax: [Math.min(...xProjectionData), Math.max(...xProjectionData)],\n      yMinMax: [Math.min(...yProjectionData), Math.max(...yProjectionData)],\n      framestep,\n      projections: [projections[xProj], projections[yProj]],\n    };\n\n    processedRef.current = processed;\n\n    drawRef.current({ processed });\n\n    // calculate Delaunay graph to later find points from mouse position\n    (async () => {\n      // delay a bit, to prioritise drawing\n      await sleep(MAX_DELAY + MAX_DURATION);\n      await schedule(100);\n      delaunayDiagramRef.current = Delaunay.from(zipped);\n    })();\n  }, [projectionsData, projections, framestep, switched]);\n\n  const coordinatesCount = (projectionsData && projectionsData[0].length) || 0;\n\n  return (\n    <>\n      <div\n        className={style['graph-container']}\n        onDoubleClick={drawRef.current}\n        ref={containerRef}\n      />\n      <div className={style.legend}>\n        <IconButton\n          title=\"Switch axes\"\n          className={cn(style.switch, { [style.switched]: switched })}\n          onClick={toggleSwitched}\n          size=\"large\"\n        >\n          <FontAwesomeIcon icon={faRandom} />\n        </IconButton>\n        <p>position in simulation:</p>\n        <div className={style['color-scale']}>\n          <div>start</div>\n          <div ref={legendRef}>\n            <canvas height=\"1\" width={coordinatesCount} />\n            <div className={style.cursor} />\n          </div>\n          <div>end</div>\n        </div>\n      </div>\n      <div className={style.tooltip} ref={tooltipRef} />\n    </>\n  );\n};\n\nexport default Projections;\n","export default context => (data, xScale, yScale, width, height) => {\n  const imgData = context.createImageData(data.length, 1);\n  // create a 32 bytes view on image data\n  const uInt32View = new Uint32Array(imgData.data.buffer);\n\n  data.forEach(({ x, y, fill: { r, g, b } }, i) => {\n    let opacity = 255;\n    if (xScale) {\n      const onScreenX = xScale(x);\n      if (onScreenX < 0 || onScreenX > width) {\n        opacity = 100;\n      } else {\n        const onScreenY = yScale(y);\n        if (onScreenY < 0 || onScreenY > height) opacity = 100;\n      }\n    }\n\n    // fill r, g, b, and opacity in one go\n    uInt32View[i] = opacity * 0x1000000 + b * 0x10000 + g * 0x100 + r;\n  });\n\n  context.putImageData(imgData, 0, 0);\n};\n"],"names":["dPR","window","devicePixelRatio","customElastic","easeElastic","amplitude","period","t","MARGIN","MAX_DELAY","MIN_DURATION","MAX_DURATION","colorScale","scaleSequential","interpolateViridis","_ref","framestep","projectionsData","projections","datumRange","totalFrames","setRequestedFrame","containerRef","useRef","legendRef","drawRef","noop","dataPointsRef","processedRef","tooltipRef","delaunayDiagramRef","find","switched","toggleSwitched","useToggleState","useEffect","canvas","select","current","append","graph","context","node","getContext","alpha","desynchronized","brushInstance","brush","refs","xScale","scaleLinear","yScale","xAxis","attr","style","axis","yAxis","xAxisLegend","cn","yAxisLegend","dataPoints","hover","legendCanvas","legendCursor","cursor","brushElement","drawLegend","debounce","data","width","height","imgData","createImageData","length","uInt32View","Uint32Array","buffer","forEach","i","x","y","fill","r","g","b","opacity","onScreenX","onScreenY","putImageData","getDrawLegend","reset","onlyTooltip","arguments","undefined","display","handleClick","datumIndex","requestedFrame","console","error","target","Math","floor","async","processed","brushing","frame","firstChild","clientWidth","clientHeight","call","isFirstTime","range","domain","xMinMax","yMinMax","transition","duration","reducedMotion","clamp","axisBottom","ticks","round","tickFormat","d","text","axisLeft","on","selection","event","map","invert","move","radiusScale","log","max","radius","min","maxTime","currentRadius","_ref2","_ref3","xValue","yValue","xPoint","yPoint","delay","random","time","currentX","currentY","interpolateX","interpolate","interpolateY","interpolateRadius","Promise","res","stop","timer","elapsed","isLastDraw","fillStyle","fillRect","dataPoint","easedProgress","easeCubicInOut","hex","beginPath","arc","PI","movePoints","handleHover","datum","Number","isInteger","scrollX","scrollY","left","top","getBoundingClientRect","innerHTML","rect","transform","handleGraphEventWith","handler","pageX","pageY","mouseX","mouseY","datumX","datumY","sqrt","abs","handleLegendEventWith","position","addEventListener","cancel","removeEventListener","xProj","yProj","coordinatesCount","colorScaleWithDomain","xProjectionData","yProjectionData","zipped","zip","_ref4","rgb","sleep","schedule","Delaunay","from","_jsxs","_Fragment","children","_jsx","className","onDoubleClick","ref","legend","IconButton","title","switch","onClick","size","FontAwesomeIcon","icon","faRandom","tooltip"],"sourceRoot":""}