{"version":3,"file":"static/js/projections.e2da77d4.chunk.js","mappings":"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","sources":["components/projections/move-points/index.js","webpack://mdposit/./src/components/projections/style.module.css?f675","components/projections/index.js","components/projections/get-draw-legend/index.js"],"sourcesContent":["import { timer, easeCubicInOut, easeElastic } from 'd3';\n\n// device pixel ratio (for \"retina\" screens)\nconst dPR = window.devicePixelRatio || 1;\n\n// easing for start animation (looks like a spring coming out of the centre)\nconst customElastic = easeElastic.amplitude(1).period(0.5);\n\n// timer instance variable\nlet t;\n\nexport default ({ context, dataPoints, width, height, maxTime, isFirstTime }) =>\n  new Promise(res => {\n    if (t) t.stop();\n    t = timer(elapsed => {\n      const isLastDraw = elapsed >= maxTime;\n      // if we finished transitioning, clear completely the canvas\n      if (isLastDraw) {\n        t.stop();\n        context.fillStyle = 'white';\n        context.fillRect(0, 0, width * dPR, height * dPR);\n      } else {\n        // clean up the canvas before drawing everything else\n        // using white, but opacity 0.25, to keep a shadow of the previous drawings\n        // to give the illusion of movement\n        context.fillStyle = `rgba(255, 255, 255, 0.25)`;\n        context.fillRect(0, 0, width * dPR, height * dPR);\n      }\n      // loop on every data point and draw them\n      for (const dataPoint of dataPoints) {\n        const easedProgress = Math.max(\n          0,\n          (isFirstTime ? customElastic : easeCubicInOut)(\n            Math.min((elapsed - dataPoint.delay) / dataPoint.duration, 1),\n          ),\n        );\n        // x\n        dataPoint.currentX = dataPoint.interpolateX(easedProgress);\n        // skip out-of-screen points\n        if (dataPoint.currentX < 0 || dataPoint.currentX > width) continue;\n        dataPoint.currentY = dataPoint.interpolateY(easedProgress);\n        // y\n        dataPoints.currentRadius = dataPoints.interpolateRadius(easedProgress);\n        // skip out-of-screen points\n        if (dataPoint.currentY < 0 || dataPoint.currentY > height) continue;\n        // draw point\n        context.fillStyle = dataPoint.fill.hex;\n        context.beginPath();\n        context.arc(\n          dataPoint.currentX,\n          dataPoint.currentY,\n          dataPoints.currentRadius,\n          0,\n          2 * Math.PI,\n        );\n        context.fill();\n      }\n      if (isLastDraw) res();\n    });\n  });\n","// extracted by mini-css-extract-plugin\nexport default {\"graph-container\":\"style_graph-container__oCOoS\",\"axis\":\"style_axis__H0KE8\",\"legend-text\":\"style_legend-text__Zvd0H\",\"legend\":\"style_legend__kYAHJ\",\"switch\":\"style_switch__vPk4i\",\"switched\":\"style_switched__DLS7l\",\"color-scale\":\"style_color-scale__mIyZh\",\"cursor\":\"style_cursor__uJXdm\",\"tooltip\":\"style_tooltip__S2WeP\"};","import React, { useRef, useEffect } from 'react';\nimport { noop, zip, random, debounce, clamp } from 'lodash-es';\nimport {\n  select,\n  scaleLinear,\n  axisLeft,\n  axisBottom,\n  scaleSequential,\n  interpolateViridis,\n  interpolate,\n  event,\n  brush,\n  rgb,\n} from 'd3';\nimport { Delaunay } from 'd3-delaunay';\nimport { schedule, sleep, frame } from 'timing-functions';\nimport cn from 'classnames';\n\nimport useToggleState from '../../hooks/use-toggle-state';\nimport movePoints from './move-points';\nimport getDrawLegend from './get-draw-legend';\nimport reducedMotion from '../../utils/reduced-motion';\n\nimport { IconButton } from '@mui/material';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faRandom } from '@fortawesome/free-solid-svg-icons';\n\nimport style from './style.module.css';\n\n// device pixel ratio (for \"retina\" screens)\nconst dPR = window.devicePixelRatio || 1;\n\n// delaunay diagram detection threshold\nconst THRESHOLD = 20;\n\nconst MARGIN = { top: 10, right: 10, bottom: 25, left: 25 };\n\n// animation constants\nconst MAX_DELAY = 500;\nconst [MIN_DURATION, MAX_DURATION] = [375, 625];\n\nconst colorScale = scaleSequential(interpolateViridis);\n\n// This component renders a graph\n// This graph is displayed when user selects 2 pca projections\nconst Projections = ({\n  framestep,\n  projectionsData,\n  projections,\n  datumRange,\n  totalFrames,\n  setRequestedFrame,\n}) => {\n  const containerRef = useRef(null);\n  const legendRef = useRef(null);\n  const drawRef = useRef(noop);\n  const dataPointsRef = useRef(null);\n  const processedRef = useRef(null);\n  const tooltipRef = useRef(null);\n  const delaunayDiagramRef = useRef({ find() {} });\n\n  const [switched, toggleSwitched] = useToggleState(false);\n\n  useEffect(() => {\n    const canvas = select(containerRef.current).append('canvas');\n    const graph = select(containerRef.current).append('svg');\n\n    const context = canvas\n      .node()\n      .getContext('2d', { alpha: false, desynchronized: true });\n\n    const brushInstance = brush();\n\n    const refs = {\n      xScale: scaleLinear(),\n      yScale: scaleLinear(),\n      xAxis: graph.append('g').attr('class', style.axis),\n      yAxis: graph.append('g').attr('class', style.axis),\n      xAxisLegend: graph\n        .append('text')\n        .attr('class', cn(style.axis, style['legend-text'])),\n      yAxisLegend: graph\n        .append('text')\n        .attr('class', cn(style.axis, style['legend-text'])),\n      dataPoints: graph.append('g').attr('class', style['data-points']),\n      hover: graph.append('circle').attr('fill', 'transparent'),\n      legendCanvas: select(legendRef.current).select('canvas'),\n      legendCursor: select(legendRef.current).select(`.${style.cursor}`),\n      brush: brushInstance,\n      brushElement: graph.append('g').attr('class', 'brush'),\n    };\n\n    // debounce it to prevent redrawing that too much\n    refs.drawLegend = debounce(\n      getDrawLegend(refs.legendCanvas.node().getContext('2d', { alpha: true })),\n      MAX_DELAY + MAX_DURATION,\n    );\n\n    const reset = ({ onlyTooltip } = {}) => {\n      tooltipRef.current.style.display = 'none';\n      refs.hover.attr('fill', 'transparent');\n      if (onlyTooltip) return;\n      refs.legendCursor.style('left', '');\n      refs.legendCursor.style('opacity', 0);\n    };\n\n    // Select the frame to be displayed by the viewer\n    const handleClick = ({ datumIndex } = {}) =>\n      // This function is a setter from a useState hook in the parent script (pca/index.js)\n      setRequestedFrame(requestedFrame => {\n        if (!totalFrames) {\n          console.error('No number of frames in metadata. Are we missing the main trajectory?');\n          return null;\n        }\n        const target = Math.floor(datumIndex * (totalFrames / datumRange));\n        // If the user clicks in the already selected point it is unselected\n        return target === requestedFrame ? null : target;\n      });\n\n    drawRef.current = async ({\n      processed = processedRef.current,\n      brushing,\n    } = {}) => {\n      if (!processed) return;\n      await frame();\n      if (!containerRef.current.firstChild) return;\n\n      // container size\n      const { clientWidth: width, clientHeight: height } = containerRef.current;\n      graph.attr('width', width).attr('height', height);\n      if (canvas.attr('width') !== `${width * dPR}`) {\n        canvas.attr('width', width * dPR);\n      }\n      if (canvas.attr('height') !== `${height * dPR}`) {\n        canvas.attr('height', height * dPR);\n      }\n      canvas.style('width', `${width}px`).style('height', `${height}px`);\n\n      refs.brushElement.call(refs.brush);\n\n      const isFirstTime = !dataPointsRef.current;\n\n      // x axis\n      refs.xScale.range([MARGIN.left, width - MARGIN.right]);\n      if (!brushing) refs.xScale.domain(processed.xMinMax);\n\n      // y axis\n      refs.yScale.range([height - MARGIN.bottom, MARGIN.top]);\n      if (!brushing) refs.yScale.domain(processed.yMinMax);\n      // visual x axis\n      const xAxis = g =>\n        g\n          .attr(\n            'transform',\n            `translate(0, ${clamp(refs.yScale(0), 0, height - 32)})`,\n          )\n          .call(\n            axisBottom(refs.xScale)\n              .ticks(Math.round(width / 75))\n              .tickFormat(d => (d === 0 ? null : d)),\n          );\n      refs.xAxis\n        .transition()\n        .duration(!isFirstTime && !reducedMotion() && MAX_DELAY + MAX_DURATION)\n        .call(xAxis);\n\n      refs.xAxisLegend\n        .text(`← principal component ${processed.projections[0] + 1} →`)\n        .transition()\n        .duration(!isFirstTime && !reducedMotion() && MAX_DELAY + MAX_DURATION)\n        .attr('transform', `translate(${width / 2}, ${height - 5})`);\n\n      // visual y axis\n      const yAxis = g =>\n        g\n          .attr(\n            'transform',\n            `translate(${clamp(refs.xScale(0), 30, width - 1)}, 0)`,\n          )\n          .call(\n            axisLeft(refs.yScale)\n              .ticks(Math.round(height / 75))\n              .tickFormat(d => (d === 0 ? null : d)),\n          );\n      refs.yAxis\n        .transition()\n        .duration(!isFirstTime && !reducedMotion() && MAX_DELAY + MAX_DURATION)\n        .call(yAxis);\n\n      refs.yAxisLegend\n        .text(`← principal component ${processed.projections[1] + 1} →`)\n        .transition()\n        .duration(!isFirstTime && !reducedMotion() && MAX_DELAY + MAX_DURATION)\n        .attr('transform', `translate(5, ${height / 2}) rotate(90)`);\n\n      refs.brush.on('end', () => {\n        const { selection } = event;\n        if (!selection) return;\n        refs.xScale.domain(\n          [selection[0][0], selection[1][0]].map(\n            refs.xScale.invert,\n            refs.xScale,\n          ),\n        );\n        refs.yScale.domain(\n          [selection[1][1], selection[0][1]].map(\n            refs.yScale.invert,\n            refs.yScale,\n          ),\n        );\n        // remove visual brush rectangle\n        refs.brushElement.call(refs.brush.move, null);\n        drawRef.current({ brushing: true });\n      });\n\n      const radiusScale =\n        Math.log(\n          Math.max(\n            (processed.xMinMax[1] - processed.xMinMax[0]) /\n              (refs.xScale.domain()[1] - refs.xScale.domain()[0]),\n            (processed.yMinMax[1] - processed.yMinMax[0]) /\n              (refs.yScale.domain()[1] - refs.yScale.domain()[0]),\n          ),\n        ) + 1;\n      const radius = (dPR * Math.min(width, height) * radiusScale) / 250;\n      // hover circle\n      refs.hover.attr('r', radius + 5);\n\n      // data points\n      let maxTime = 0;\n      const currentRadius = isFirstTime\n        ? 0\n        : dataPointsRef.current.currentRadius;\n      dataPointsRef.current = processed.data.map(\n        ({ x: xValue, y: yValue, fill }, i, { length }) => {\n          const xPoint = refs.xScale(xValue) * dPR;\n          const yPoint = refs.yScale(yValue) * dPR;\n          const delay = (i * MAX_DELAY * (isFirstTime ? 2 : 1)) / length;\n          const duration = reducedMotion()\n            ? 0\n            : random(MIN_DURATION, MAX_DURATION) * (isFirstTime ? 2 : 1);\n          const time = delay + duration;\n          // update maxTime if needed\n          if (maxTime < time) maxTime = time;\n          return {\n            currentX: null,\n            currentY: null,\n            currentRadius: null,\n            interpolateX: interpolate(\n              isFirstTime\n                ? refs.xScale(0) * dPR\n                : dataPointsRef.current[i].currentX ||\n                    dataPointsRef.current[i].x,\n              xPoint,\n            ),\n            interpolateY: interpolate(\n              isFirstTime\n                ? refs.yScale(0) * dPR\n                : dataPointsRef.current[i].currentY ||\n                    dataPointsRef.current[i].y,\n              yPoint,\n            ),\n            delay,\n            duration,\n            x: xPoint,\n            y: yPoint,\n            fill,\n          };\n        },\n      );\n\n      // same radius interpolation for all the points, so keep only one\n      dataPointsRef.current.interpolateRadius = interpolate(\n        currentRadius,\n        radius,\n      );\n\n      // will trigger a timer animate points\n      // Render the graph\n      movePoints({\n        context,\n        dataPoints: dataPointsRef.current,\n        width: width * dPR,\n        height: height * dPR,\n        maxTime,\n        isFirstTime,\n      });\n\n      const handleHover = ({ datumIndex, datum } = {}) => {\n        if (!Number.isInteger(datumIndex) || !datum) return;\n        // bottom cursor\n        refs.legendCursor.style(\n          'left',\n          `calc(${(100 * datumIndex) / processed.data.length}% - 4px)`,\n        );\n        refs.legendCursor.style('opacity', 1);\n\n        // would tooltip be visible?\n        const x = refs.xScale(datum.x);\n        if (x < 0 || x > width) return reset({ onlyTooltip: true });\n        const y = refs.yScale(datum.y);\n        if (y < 0 || y > height) return reset({ onlyTooltip: true });\n        // yes, then display tooltip\n        const { scrollX, scrollY } = window;\n        const { left, top } = containerRef.current.getBoundingClientRect();\n        tooltipRef.current.innerHTML = `\n          <div>\n            <p>Frame ${datumIndex * processed.framestep +\n              1} (click to open viewer)</p>\n            <p>Principal component ${processed.projections[0] + 1}: ${\n          datum.x\n        }</p>\n            <p>Principal component ${processed.projections[1] + 1}: ${\n          datum.y\n        }</p>\n          </div>\n        `;\n        tooltipRef.current.style.display = 'inline-block';\n        const rect = tooltipRef.current.getBoundingClientRect();\n        tooltipRef.current.style.transform = `translate(${x +\n          left +\n          scrollX -\n          rect.width / 2}px, ${y + top + scrollY - rect.height - 15}px)`;\n        refs.hover\n          .attr('cx', x)\n          .attr('cy', y)\n          .attr('fill', datum.fill.hex);\n      };\n\n      const handleGraphEventWith = handler => () => {\n        const { scrollX, scrollY } = window;\n        const { left, top } = containerRef.current.getBoundingClientRect();\n        const { pageX, pageY } = event;\n        const mouseX = pageX - left - scrollX;\n        const mouseY = pageY - top - scrollY;\n        // invert the mouse position with the scale because we only computed the\n        // Delaunay graph once on the raw data for optimisation purposes\n        const datumIndex = delaunayDiagramRef.current.find(\n          refs.xScale.invert(mouseX),\n          refs.yScale.invert(mouseY),\n        );\n        const datum = processed.data[datumIndex];\n        if (datum) {\n          const datumX = refs.xScale(datum.x);\n          const datumY = refs.yScale(datum.y);\n          // is within threshold?\n          if (\n            Math.sqrt(\n              Math.abs(datumX - mouseX) ** 2 + Math.abs(datumY - mouseY) ** 2,\n            ) <= THRESHOLD\n          ) {\n            return handler({ datumIndex, datum });\n          }\n        }\n        reset();\n        handler();\n      };\n\n      graph\n        .on('mousemove', handleGraphEventWith(handleHover))\n        .on('mouseout', reset)\n        .on('click', handleGraphEventWith(handleClick));\n\n      /**\n       * @param {(object: object) => void} handler\n       */\n      const handleLegendEventWith = handler => () => {\n        const node = refs.legendCanvas.node();\n        if (!(node && 'getBoundingClientRect' in node)) return;\n        const { left, width } = node.getBoundingClientRect();\n        const { pageX } = event;\n        const position = (pageX - left) / width;\n        const datumIndex = Math.floor(position * processed.data.length);\n        handler({ datumIndex, datum: processed.data[datumIndex] });\n      };\n\n      refs.drawLegend(processed.data, refs.xScale, refs.yScale, width, height);\n\n      refs.legendCanvas\n        .on('mousemove', handleLegendEventWith(handleHover))\n        .on('mouseout', reset)\n        .on('click', handleLegendEventWith(handleClick));\n    };\n\n    window.addEventListener('resize', drawRef.current);\n\n    return () => {\n      // clean up\n      refs.drawLegend && refs.drawLegend.cancel();\n      window.removeEventListener('resize', drawRef.current);\n    };\n  }, [projections, setRequestedFrame, datumRange, totalFrames]);\n\n  useEffect(() => {\n    const [xProj, yProj] = switched ? [0, 1] : [1, 0];\n\n    const coordinatesCount =\n      (projectionsData && projectionsData[0].length) || 0;\n    const colorScaleWithDomain = colorScale.domain([0, coordinatesCount]);\n\n    const xProjectionData = projectionsData[projections[xProj]];\n    const yProjectionData = projectionsData[projections[yProj]];\n    const zipped = zip(xProjectionData, yProjectionData);\n    const processed = {\n      data: zipped.map(([x, y], i) => {\n        const hex = colorScaleWithDomain(i);\n        return {\n          x,\n          y,\n          fill: { hex, ...rgb(hex) },\n        };\n      }),\n      xMinMax: [Math.min(...xProjectionData), Math.max(...xProjectionData)],\n      yMinMax: [Math.min(...yProjectionData), Math.max(...yProjectionData)],\n      framestep,\n      projections: [projections[xProj], projections[yProj]],\n    };\n\n    processedRef.current = processed;\n\n    drawRef.current({ processed });\n\n    // calculate Delaunay graph to later find points from mouse position\n    (async () => {\n      // delay a bit, to prioritise drawing\n      await sleep(MAX_DELAY + MAX_DURATION);\n      await schedule(100);\n      delaunayDiagramRef.current = Delaunay.from(zipped);\n    })();\n  }, [projectionsData, projections, framestep, switched]);\n\n  const coordinatesCount = (projectionsData && projectionsData[0].length) || 0;\n\n  return (\n    <>\n      <div\n        className={style['graph-container']}\n        onDoubleClick={drawRef.current}\n        ref={containerRef}\n      />\n      <div className={style.legend}>\n        <IconButton\n          title=\"Switch axes\"\n          className={cn(style.switch, { [style.switched]: switched })}\n          onClick={toggleSwitched}\n          size=\"large\"\n        >\n          <FontAwesomeIcon icon={faRandom} />\n        </IconButton>\n        <p>position in simulation:</p>\n        <div className={style['color-scale']}>\n          <div>start</div>\n          <div ref={legendRef}>\n            <canvas height=\"1\" width={coordinatesCount} />\n            <div className={style.cursor} />\n          </div>\n          <div>end</div>\n        </div>\n      </div>\n      <div className={style.tooltip} ref={tooltipRef} />\n    </>\n  );\n};\n\nexport default Projections;\n","export default context => (data, xScale, yScale, width, height) => {\n  const imgData = context.createImageData(data.length, 1);\n  // create a 32 bytes view on image data\n  const uInt32View = new Uint32Array(imgData.data.buffer);\n\n  data.forEach(({ x, y, fill: { r, g, b } }, i) => {\n    let opacity = 255;\n    if (xScale) {\n      const onScreenX = xScale(x);\n      if (onScreenX < 0 || onScreenX > width) {\n        opacity = 100;\n      } else {\n        const onScreenY = yScale(y);\n        if (onScreenY < 0 || onScreenY > height) opacity = 100;\n      }\n    }\n\n    // fill r, g, b, and opacity in one go\n    uInt32View[i] = opacity * 0x1000000 + b * 0x10000 + g * 0x100 + r;\n  });\n\n  context.putImageData(imgData, 0, 0);\n};\n"],"names":["dPR","window","devicePixelRatio","customElastic","easeElastic","amplitude","period","t","MARGIN","MAX_DELAY","MIN_DURATION","MAX_DURATION","colorScale","scaleSequential","interpolateViridis","_ref","framestep","projectionsData","projections","datumRange","totalFrames","setRequestedFrame","containerRef","useRef","legendRef","drawRef","noop","dataPointsRef","processedRef","tooltipRef","delaunayDiagramRef","find","switched","toggleSwitched","useToggleState","useEffect","canvas","select","current","append","graph","context","node","getContext","alpha","desynchronized","brushInstance","brush","refs","xScale","scaleLinear","yScale","xAxis","attr","style","axis","yAxis","xAxisLegend","cn","yAxisLegend","dataPoints","hover","legendCanvas","legendCursor","concat","cursor","brushElement","drawLegend","debounce","data","width","height","imgData","createImageData","length","uInt32View","Uint32Array","buffer","forEach","i","x","y","fill","r","g","b","opacity","onScreenX","onScreenY","putImageData","getDrawLegend","reset","onlyTooltip","arguments","undefined","display","handleClick","datumIndex","requestedFrame","console","error","target","Math","floor","async","processed","brushing","frame","firstChild","clientWidth","clientHeight","call","isFirstTime","range","domain","xMinMax","yMinMax","transition","duration","reducedMotion","clamp","axisBottom","ticks","round","tickFormat","d","text","axisLeft","on","selection","event","map","invert","move","radiusScale","log","max","radius","min","maxTime","currentRadius","_ref2","_ref3","xValue","yValue","xPoint","yPoint","delay","random","time","currentX","currentY","interpolateX","interpolate","interpolateY","interpolateRadius","Promise","res","stop","timer","elapsed","isLastDraw","fillStyle","fillRect","dataPoint","easedProgress","easeCubicInOut","hex","beginPath","arc","PI","movePoints","handleHover","datum","Number","isInteger","scrollX","scrollY","left","top","getBoundingClientRect","innerHTML","rect","transform","handleGraphEventWith","handler","pageX","pageY","mouseX","mouseY","datumX","datumY","sqrt","abs","handleLegendEventWith","position","addEventListener","cancel","removeEventListener","xProj","yProj","coordinatesCount","colorScaleWithDomain","xProjectionData","yProjectionData","zipped","zip","_ref4","rgb","sleep","schedule","Delaunay","from","_jsxs","_Fragment","children","_jsx","className","onDoubleClick","ref","legend","IconButton","title","switch","onClick","size","FontAwesomeIcon","icon","faRandom","tooltip"],"sourceRoot":""}