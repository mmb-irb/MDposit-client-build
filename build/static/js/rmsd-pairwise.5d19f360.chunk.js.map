{"version":3,"file":"static/js/rmsd-pairwise.5d19f360.chunk.js","mappings":"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","sources":["components/ngl-viewer/use-default-representations/index.js","webpack://mdposit/./src/pages/accession/rmsd-pairwise/style.module.css?bc81","pages/accession/rmsd-pairwise/index.js"],"sourcesContent":["// React logic\nimport { useMemo, useContext } from 'react';\n\nimport { ProjectCtx, PdbCtx } from '../../../contexts';\n\nimport { nglSelection2residueIndices, nglSelectionExists } from '../../../utils/topology-manager';\n\n// Use this hook to get the memoized NGL default representations\nconst useDefaultRepresentations = () => {\n  // Get the current project metadata and chains\n  const { chains, metadata, topology } = useContext(ProjectCtx);\n  // Get current structure\n  const { file: structure } = useContext(PdbCtx);\n  //console.log(structure.residueMap.get(0).isCg());\n  // Set the chains to be represented in the NGL viewer by default\n  // WARNING: This is experimental and may have some bugs\n  const defaultRepresentations = useMemo(() => {\n    if (!topology) return [];\n    const reps = [];\n    const ligands = metadata && metadata.LIGANDS;\n    if (metadata && chains) {\n      const chainnames = metadata.CHAINNAMES;\n      // Represent each protein chain\n      if (chainnames) {\n        for (const chain of chains) {\n          const name = chainnames[chain];\n          reps.push({\n            name: name ? name + ' (Chain ' + chain + ')' : 'Chain ' + chain,\n            selection: ':' + chain,\n          });\n        }\n      }\n      // If chainnames are not defined then set a general representation\n      else {\n        const generalRepresentations = [\n          { name: 'Protein', selection: 'protein' },\n          { name: 'Nucleic acids', selection: 'nucleic' }\n        ]\n        // Add the representation only if it contains any atom\n        generalRepresentations.forEach(rep => {\n          const exists = nglSelectionExists(rep.selection, structure);\n          if (exists) reps.push(rep);\n        });\n      }\n\n      // Represent the mebrane if exist\n      /*\n          if (metadata.MEMBRANE !== 'No')\n              reps.push({\n              selection: '(not polymer or hetero) and not (water or ion)',\n              name: metadata.MEMBRANE,\n              type: 'licorice',\n              opacity: 0.5,\n              });\n          */\n      // Represent all chains which are not in the 'chains' and 'ligands' list in licorice\n      topology.chainNames.forEach(chain => {\n        // Check if the chain is in the protein chains\n        const isProtein = chains.indexOf(chain) !== -1;\n        if (isProtein) return;\n        // Check if the chain is full ligand\n        // DANI: No se ha probado\n        const topologyChain = topology.getChainByName(chain);\n        const isLigand = topologyChain.residues.every(residue => residue.isLigand);\n        // If there is any coincidence then skip this chainname\n        if (isLigand) return;\n        // Get the chain name according to metadata, if available\n        const name = (chainnames && chainnames[chain]) || chain;\n        reps.push({\n          name: name,\n          selection: ':' + chain,\n          type: 'licorice',\n          color: 'purple',\n          opacity: 0.5,\n        });\n      });\n    }\n    // If there is no metadata/chains then set up a defualt generic representation\n    else {\n      reps.push({ name: 'Main structure' });\n    }\n\n    // Display ligands\n    if (ligands) {\n      for (const ligand of ligands) {\n        // New system: ligands are pubchem ids\n        if (typeof ligand === 'string') {\n          // Get ligand reisude indcies\n          const ligandResidueIndices = topology.getReferenceResidueIndices(ligand);\n          if (!ligandResidueIndices || ligandResidueIndices.length === 0) continue;\n          // Transform the residue indices to a NGL selection\n          const { rangedSelection: nglSelection } = topology.residueIndices2Ngl(ligandResidueIndices);\n          // Add the representation\n          reps.push({\n            name: ligand,\n            selection: nglSelection,\n            type: 'ball+stick',\n            color: 'element'\n          });\n        }\n        // Old system: ligands are objects which may have a ngl selection\n        else{\n          if (!ligand.ngl) continue;\n          reps.push({\n            name: ligand.name,\n            selection: ligand.ngl,\n            type: 'licorice',\n          });\n        }\n        \n      }\n    }\n\n    // Add a representation for ions in spacefill in case there are residues with 1 atom\n    const singleAtomIndices = []\n    topology.residueAtomIndices.forEach(atomIndices => {\n      if (atomIndices.length > 1) return;\n      singleAtomIndices.push(atomIndices[0]);\n    })\n    if (singleAtomIndices.length > 0) {\n      const singleAtomSelection = '@' + singleAtomIndices.join(',');\n      reps.push({\n        name: 'Ions',\n        selection: singleAtomSelection,\n        type: 'spacefill',\n        color: 'element',\n      });\n    }\n\n    // Represent \"Other\" residues in low opacity grey licorice\n    // Get all residues which are not already included on any previous section\n    // Get also all residues which are represented as cartoon but are not protein or nucleic acid\n    // i.e. residues which would not be represented by now\n    const representedResidues = [];\n    reps.forEach(rep => {\n      const isCartoon = rep.type === undefined || rep.type === 'cartoon';\n      const residues = nglSelection2residueIndices(\n        rep.selection,\n        isCartoon,\n        structure,\n      );\n      representedResidues.push(...residues);\n    });\n    const residuesCount = topology.residueCount;\n    const nonRepresentedResidues = [];\n    for (let i = 0; i < residuesCount; i++) {\n      if (representedResidues.indexOf(i) === -1) nonRepresentedResidues.push(i);\n    }\n    if (nonRepresentedResidues.length > 0) {\n      const {\n        rangedSelection: otherSelection,\n      } = topology.residueIndices2Ngl(nonRepresentedResidues);\n      reps.push({\n        name: 'Other',\n        selection: otherSelection,\n        type: 'licorice',\n        color: 'grey',\n        opacity: 0.3,\n      });\n    }\n\n    return reps;\n  }, [chains, metadata, topology, structure]);\n\n  return defaultRepresentations;\n};\n\nexport default useDefaultRepresentations;\n","// extracted by mini-css-extract-plugin\nexport default {\"widest\":\"style_widest__hZ7sO\",\"margined\":\"style_margined__GphyO\",\"margined-bottom\":\"style_margined-bottom__KpiYO\",\"horizontal\":\"style_horizontal__1xLer\"};","import React, { useContext, useState, useMemo, useRef } from 'react';\n\nimport { CardContent, Chip, Typography } from '@mui/material';\n\nimport useAPI from '../../../hooks/use-api';\n\nimport Card from '../../../components/animated-card';\nimport Loading from '../../../components/loading';\nimport ViewerSpawner from '../../../components/viewer-spawner';\nimport useDefaultRepresentations from '../../../components/ngl-viewer/use-default-representations';\n\nimport { ProjectCtx } from '../../../contexts';\n\nimport { BASE_PATH_PROJECTS } from '../../../utils/constants';\n\nimport style from './style.module.css';\n\nimport InteractionSelector from '../../../components/interaction-selector';\nimport Heatmap from '../../../components/heatmap';\n\n// Keep constant representation references to keep them between renders\nconst REPRESENTATION_REFERENCES = {\n  base: ['First frame', 'Second frame'],\n  interface: ['First frame interface', 'Second frame interface']\n}\n\n// Set the representation colors\nconst REPRESENTATION_COLORS = {\n  base: ['red', 'blue'],\n  interface: [\n    ['orange', 'yellow'], // Agent 1\n    ['purple', 'green'], // Agent 2\n  ] \n}\n\nconst RmsdPairwise = () => {\n  // Get the current project data\n  const {\n    accessionAndMdNumber,\n    metadata,\n    interactions: defaultInteractions,\n    topology: topologyManager,\n  } = useContext(ProjectCtx);\n\n  // Set a ref to the ngl which allows access to the ngl viewer exposed methods\n  const viewerRef = useRef(null);\n  // Get the default representations\n  const defaultRepresentations = useDefaultRepresentations();\n  // The selected frames\n  const [selectedFramePair, setSelectedFramePair] = useState(null);\n  // The interaction to be displayed\n  const [selectedInteraction, setSelectedInteraction] = useState(0);\n  // Get analysis data from the API\n  const url = `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/analyses/rmsd-pairwise/`;\n  const { loading, payload, error } = useAPI(url);\n  // Set the available interactions\n  const interactions = useMemo(() => {\n    if (!defaultInteractions) return [{ name: 'Overall' }];\n    // Label all metadata interactions with the 'interface residues' ending\n    defaultInteractions.forEach(interaction => {\n      interaction.label = interaction.name + ' (interface residues)';\n    });\n    const interactions = [{ name: 'Overall' }, ...defaultInteractions];\n    return interactions;\n  }, [defaultInteractions]);\n  // Process analysis data for the heatmap\n  const { rmsds, AxesValues } = useMemo(() => {\n    // Return if the payload is not ready\n    if (!payload) return {};\n    // Get the selected interaction\n    const interaction = interactions[selectedInteraction];\n    // Get the data whose name matches the interaction name\n    const data = payload.data.find(dataset => dataset.name === interaction.name);\n    if (!data) throw new Error(`Dataset for interaction \"${interaction.name}\" not found`);\n    // Get the rmsds values\n    const rmsds = data.rmsds;\n    // Calculate the step\n    // DANI: Esto no es del todo correcto pero hace que los números de frames siempre cuadren\n    const dataLength = rmsds.length;\n    const AxesStep = Math.floor(metadata.mdFrames / (dataLength - 1));\n    // DANI: Esto es lo correcto\n    // DANI: En algunos análisis antiguos las frames no cuadran y hay que rehacerlos\n    //const xAxesStep = payload.step;\n    // Calculate the frames labels\n    // These values are used for BOTH axes\n    const AxesValues = Array(dataLength)\n      .fill(undefined)\n      .map((v, i) => i * AxesStep);\n    return { rmsds, AxesValues };\n  }, [payload, metadata, interactions, selectedInteraction]);\n\n  // Set the component state\n  const [components, setComponents] = useState(null);\n\n  // Set the components value\n  useMemo(() => {\n    // If there is no selected pair then set the components as null\n    if (!selectedFramePair) return setComponents(null);\n    // If a frame pair is selected then set the components or update them accordingly\n    setComponents(previousComponents => {\n      // If there are no previous components then set them from scratch\n      if (previousComponents === null) {\n        return selectedFramePair.map((frame, index) => ({\n          name: `${index}. Frame ${frame}`,\n          frame: frame\n        }));\n      }\n      // If components already exists then just update them\n      selectedFramePair.forEach((frame, index) => {\n        const previousComponent = previousComponents[index];\n        previousComponent.name = `${index}. Frame ${frame}`;\n        previousComponent.frame = frame;\n      });\n      return [...previousComponents];\n    });\n  }, [selectedFramePair]);\n\n  // Set the component state\n  const [representations, setRepresentations] = useState(null);\n\n  // Set the viewer representations\n  useMemo(() => {\n    // If there are no components then clear the representations and stop here\n    if (!components) return setRepresentations(null);\n    // Get the selected interaction\n    const interaction = interactions[selectedInteraction];\n    // Get also the number of the interacting agents\n    const agents = [\n      { name: interaction.agent_1, interface: interaction.interface_indices_1 },\n      { name: interaction.agent_2, interface: interaction.interface_indices_2 }\n    ];\n    // Setup every representation or update the already existing ones\n    setRepresentations(previousRepresentations => {\n      // Set a list to keep updated representations\n      const newRepresentations = [];\n      // Find out if there is a selected interaction\n      const currentInteraction = selectedInteraction > 0;\n      // Find out if there was a selected interaction in the previous representations\n      const previousInteraction = !!(previousRepresentations && previousRepresentations.find(\n        rep => rep.reference && rep.reference.includes(REPRESENTATION_REFERENCES.interface[0])));\n      // Check if there was interactions in the previous\n      // If there were no previous representations then set the default values\n      if (previousRepresentations === null) {\n        components.forEach((component, index) => {\n          // Set the overall representations\n          // In case there is no interaction selected this would be opaque\n          // In case there is an interaction selected this would be transparent (just a reference)\n          defaultRepresentations.forEach(representation => {\n            const newRepresentation = { ...representation };\n            newRepresentation.name = `${component.name} - ${representation.name}`;\n            newRepresentation.color = REPRESENTATION_COLORS.base[index];\n            newRepresentation.component = component.name;\n            newRepresentation.reference = `${REPRESENTATION_REFERENCES.base[index]} - ${representation.name}`;\n            if (currentInteraction) {\n              newRepresentation.name += ' reference';\n              newRepresentation.opacity = 0.1;\n            }\n            newRepresentations.push(newRepresentation);\n          });\n        });\n      }\n      // If representations already exist then update them\n      else {\n        components.forEach((component, index) => {\n          // Iterate the default representations\n          defaultRepresentations.forEach(representation => {\n            // Find the previous corresponding representation\n            const reference = `${REPRESENTATION_REFERENCES.base[index]} - ${representation.name}`;\n            const previousRepresentation = previousRepresentations.find(rep => rep.reference === reference);\n            if (!previousRepresentation) throw new Error(`No previous representation with reference ${reference}`);\n            // Update the representation name and component\n            const previousComponentName = previousRepresentation.name.split(' - ')[0];\n            previousRepresentation.name = previousRepresentation.name.replace(previousComponentName, component.name);\n            previousRepresentation.component = component.name;\n            // Add or remove the 'reference' tail from the name and update the opacity\n            // If we passed from no selected interaction to selected interaction\n            if (currentInteraction && !previousInteraction) {\n              previousRepresentation.name += ' reference';\n              previousRepresentation.opacity = 0.1;\n            }\n            // If we passed from selected interaction to no selected interaction\n            if (!currentInteraction && previousInteraction) {\n              previousRepresentation.name = previousRepresentation.name.replace(' reference', '');\n              previousRepresentation.opacity = 1;\n            }\n            newRepresentations.push(previousRepresentation);\n          });\n        });\n      }\n      // Set interfaces representations, each with different colors\n      if (currentInteraction) {\n        // If we did not have a selected interaction then setup representations with default values\n        if (previousInteraction === false) {\n          components.forEach((component, index) => {\n            agents.forEach((agent, agentIndex) => {\n              // Get the interaction interface, if it exists, in NGL format\n              // The default interaction (Overall) has no interface\n              const selection = agent.interface && topologyManager.residueIndices2Ngl(agent.interface);\n              // Set the new representation\n              newRepresentations.push({\n                name: `${component.name} - ${agent.name} interface`,\n                color: REPRESENTATION_COLORS.interface[index][agentIndex],\n                selection: selection.rangedSelection,\n                type: 'licorice',\n                component: component.name,\n                reference: `${REPRESENTATION_REFERENCES.interface[index]} - ${agent.name}`\n              });\n            });\n          });\n        }\n        // Otherwise update the already existing representations\n        else {\n          components.forEach((component, index) => {\n            agents.forEach(agent => {\n              // Get the interaction interface, if it exists, in NGL format\n              // The default interaction (Overall) has no interface\n              const selection = agent.interface && topologyManager.residueIndices2Ngl(agent.interface);\n              // Find the previous representation for interface 1\n              const reference = `${REPRESENTATION_REFERENCES.interface[index]} - ${agent.name}`;\n              const previousRepresentation = previousRepresentations.find(\n                rep => rep.reference === reference\n              );\n              // Update its name, selection and component\n              previousRepresentation.name = `${component.name} - ${agent.name} interface`;\n              previousRepresentation.selection = selection.rangedSelection;\n              previousRepresentation.component = component.name;\n              newRepresentations.push(previousRepresentation);\n            });\n          });\n        }\n      }\n      // Add previous custom representations (added by the user)\n      previousRepresentations && previousRepresentations.filter(rep => rep.custom)\n        .forEach(representation => {\n          // Update the component to target the first component\n          representation.component = components[0].name;\n          newRepresentations.push(representation);\n        });\n      // Update the representations state\n      return newRepresentations;\n    });\n  }, [\n    components,\n    topologyManager,\n    interactions,\n    selectedInteraction,\n    defaultRepresentations,\n  ]);\n\n  // Render loading or error messages according with the API response\n  if (loading) return <Loading />;\n  else if (error) return error.toString();\n  else if (!payload) return 'Something bad happened';\n\n  // Render\n  return (\n    <>\n      <Card>\n        <CardContent className={style.horizontal}>\n          <Typography variant=\"h6\">Residues selection:</Typography>\n          <InteractionSelector\n            interactions={interactions}\n            selectedInteraction={selectedInteraction}\n            setSelectedInteraction={setSelectedInteraction}\n          />\n          {selectedFramePair && (\n            <div>\n              {components && components.map((component, c) => (\n                <Chip key={c} label={'Frame ' + component.frame}\n                  style={{\n                    margin: '0.2em',\n                    backgroundColor: c === 0 ? 'red' : 'blue',\n                  }}\n                />\n              ))}\n              {selectedInteraction > 0 && components && components.map((component, c) => {\n                  // Get the interacting agents\n                  const interaction = interactions[selectedInteraction];\n                  const agents = [ interaction.agent_1, interaction.agent_2 ];\n                  // Generate a chip for every agent\n                  return agents.map((agent, a) => (\n                    <Chip key={a} label={'Frame ' + component.frame + ' - ' + agent}\n                      style={{\n                        margin: '0.2em',\n                        backgroundColor: a === 0\n                          ? c === 0\n                            ? 'orange'\n                            : 'purple'\n                          : c === 0\n                            ? 'yellow'\n                            : 'green',\n                      }}\n                    />\n                  ));\n                }\n              )}\n            </div>\n          )}\n        </CardContent>\n      </Card>\n      <Card className={style.margined} id=\"heatmap\">\n        <CardContent>\n          <Heatmap\n            inputData={{\n              data: rmsds,\n              xLabels: AxesValues,\n              yLabels: AxesValues,\n            }}\n            onTooltip={({ value, xAxisValue, yAxisValue }) =>\n              `${xAxisValue} - ${yAxisValue}\\n${Math.round(value * 100) / 100} Å`\n            }\n            onClick={({ xAxisValue, yAxisValue }) =>\n              setSelectedFramePair([xAxisValue, yAxisValue])\n            }\n            legendTitle={'RMSD (Å)'}\n            maxColor={'red'}\n            minColor={'blue'}\n            xTitle={'Frames'}\n            yTitle={'Frames'}\n          />\n        </CardContent>\n      </Card>\n      <ViewerSpawner\n        // Set a viewer if there is selected frames\n        newViewer={components\n          ? {\n              componentsState: [components, setComponents],\n              representationsState: [representations, setRepresentations],\n              selRef: selectedFramePair,\n              viewerRef: viewerRef\n            }\n          : null\n        }\n        // If the nailed/closed viewer is the current viewer then reset the 'selected'\n        onNail={viewer =>\n          setSelectedFramePair(previous => {\n            if (viewer.selRef === previous) return null;\n            else return previous;\n          })\n        }\n        onClose={viewer =>\n          setSelectedFramePair(previous => {\n            if (viewer.selRef === previous) return null;\n            else return previous;\n          })\n        }\n      />\n    </>\n  );\n};\n\nexport default RmsdPairwise;\n"],"names":["useDefaultRepresentations","chains","metadata","topology","useContext","ProjectCtx","file","structure","PdbCtx","useMemo","reps","ligands","LIGANDS","chainnames","CHAINNAMES","chain","name","push","selection","forEach","rep","nglSelectionExists","chainNames","indexOf","getChainByName","residues","every","residue","isLigand","type","color","opacity","ligand","ligandResidueIndices","getReferenceResidueIndices","length","rangedSelection","nglSelection","residueIndices2Ngl","ngl","singleAtomIndices","residueAtomIndices","atomIndices","singleAtomSelection","join","representedResidues","isCartoon","undefined","nglSelection2residueIndices","residuesCount","residueCount","nonRepresentedResidues","i","otherSelection","REPRESENTATION_REFERENCES","base","interface","REPRESENTATION_COLORS","RmsdPairwise","accessionAndMdNumber","interactions","defaultInteractions","topologyManager","viewerRef","useRef","defaultRepresentations","selectedFramePair","setSelectedFramePair","useState","selectedInteraction","setSelectedInteraction","url","concat","BASE_PATH_PROJECTS","loading","payload","error","useAPI","interaction","label","rmsds","AxesValues","data","find","dataset","Error","dataLength","AxesStep","Math","floor","mdFrames","Array","fill","map","v","components","setComponents","previousComponents","frame","index","previousComponent","representations","setRepresentations","agents","agent_1","interface_indices_1","agent_2","interface_indices_2","previousRepresentations","newRepresentations","currentInteraction","previousInteraction","reference","includes","component","representation","newRepresentation","previousRepresentation","previousComponentName","split","replace","agent","agentIndex","filter","custom","_jsx","Loading","toString","_jsxs","_Fragment","children","Card","CardContent","className","style","Typography","variant","InteractionSelector","c","Chip","margin","backgroundColor","a","id","Heatmap","inputData","xLabels","yLabels","onTooltip","_ref","value","xAxisValue","yAxisValue","round","onClick","_ref2","legendTitle","maxColor","minColor","xTitle","yTitle","ViewerSpawner","newViewer","componentsState","representationsState","selRef","onNail","viewer","previous","onClose"],"sourceRoot":""}