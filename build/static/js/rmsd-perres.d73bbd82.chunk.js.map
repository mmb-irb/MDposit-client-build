{"version":3,"file":"static/js/rmsd-perres.d73bbd82.chunk.js","mappings":"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","sources":["webpack://mdposit/./src/pages/accession/rmsd-perres/style.module.css?5d27","pages/accession/rmsd-perres/index.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"graphcard\":\"style_graphcard__VoJ6R\",\"graph\":\"style_graph__GoAAc\",\"graph-placeholder\":\"style_graph-placeholder__bh3Kw\",\"nglcard\":\"style_nglcard__Zr+kp\",\"container\":\"style_container__lBCpG\"};","import React, {\n  Suspense,\n  useState,\n  useContext,\n  useMemo,\n  useCallback,\n  useRef,\n} from 'react';\nimport { useInView } from 'react-intersection-observer';\n\nimport { Typography } from '@mui/material';\n\nimport { color as d3color, scaleLinear } from 'd3';\n\nimport Card from '../../../components/animated-card';\nimport ViewerWithControls from '../../../components/viewer-with-controls';\nimport useDefaultRepresentations from '../../../components/ngl-viewer/use-default-representations';\nimport Loading from '../../../components/loading';\n\nimport useAPI from '../../../hooks/use-api';\n\nimport { ProjectCtx } from '../../../contexts';\n\nimport { BASE_PATH_PROJECTS } from '../../../utils/constants';\n\nimport style from './style.module.css';\n\nimport { ColormakerRegistry } from 'ngl';\n\nimport ResidueSelector from '../../../components/residue-selector';\n\nimport Graph from '../../../components/graph';\n\n// Define permanent options for the \"useInView\"\nconst useInViewOptions = { triggerOnce: true, rootMargin: '100px' };\n\n// Set the color of each residue in the NGL representation\n// WARNING: Grey looks better than white because the background may be white and resdiues are hard to see\nconst nglColorPlan = ['grey', 'yellow', 'red'];\n\n// Round to cents\nconst nice = number => Math.round(number * 100) / 100;\n// Get the average and standard deviation\nconst getStaistics = values => {\n  const n = values.length;\n  const mean = values.reduce((a, b) => a + b) / n;\n  const stdv = Math.sqrt(\n    values.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n,\n  );\n  return [nice(mean), nice(stdv)];\n};\n\nconst RmsdPerres = () => {\n  // Track if the NGL viewer\n  // The status isNglVisible is returned true/false when the element is in/out the screen respectively\n  const [nglRef, isNglVisible] = useInView(useInViewOptions);\n\n  // Get the current project data\n  const {\n    accessionAndMdNumber,\n    metadata,\n    topology: topologyManager,\n    populations,\n  } = useContext(ProjectCtx);\n\n  // Get the default representations\n  const defaultRepresentations = useDefaultRepresentations();\n\n  // Set a ref to the ngl which allows access to its exposed methods\n  const viewerRef = useRef(null);\n  // Set a ref to the graph which allows access to its exposed methods\n  const graphRef = useRef(null);\n\n  // Send a request to the API with the url of the specific analysis\n  const { loading, payload, error } = useAPI(\n    `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/analyses/rmsd-perres/`,\n  );\n\n  // Set when one point in the graph is selected\n  const [selectedResidues, setSelectedResidues] = useState([]);\n\n  // Get the residues list in model notation\n  const {\n    components,\n    representations,\n    analysisFrameCount,\n    xAxisStep,\n    xAxisLabel,\n    isEnsemble,\n    xTooltip,\n    data,\n    xWeights,\n  } = useMemo(() => {\n    if (\n      !topologyManager ||\n      !metadata ||\n      !payload ||\n      (populations && populations.loading)\n    )\n      return {};\n\n    // Data is stored as RMSD per residue and per frame respectively\n    const rmsdpr = payload.rmsdpr;\n    // Calculate the mean and standard deviation of each residue rmsds\n    // DANI: Esto he comprovado que cuesta 10 milisegundos aprox en una estructura grande\n    const means = [];\n    const stdvs = [];\n    rmsdpr.forEach(rmsdpf => {\n      if (rmsdpf === null) {\n        means.push(null);\n        stdvs.push(null);\n      } else {\n        const [mean, stdv] = getStaistics(rmsdpf);\n        means.push(mean);\n        stdvs.push(stdv);\n      }\n    });\n\n    // Put all data together to be used further in this component\n    const data = { rmsdpr, means, stdvs };\n\n    // Also get the maximum and minimum means\n    const max = Math.max(...means);\n    const min = Math.min(...means);\n\n    // Set the color scale according to the maximum and minimum means\n    const nglColorScale = scaleLinear()\n      .range(nglColorPlan)\n      .domain([min, (min + max) / 2, max]);\n\n    // Set each residue color in the ngl representation according to the color cale\n    // WARNING: Grey looks better than white because the background is white and the structure is easier to see\n    const colorScheme = ColormakerRegistry.addScheme(function(params) {\n      this.atomColor = atom => {\n        // Find the residue index and then the mean rmsd for this residue\n        const residueIndex = atom.residueIndex;\n        const mean = means[residueIndex];\n        // If there is no data for this residue then paint it white\n        if (mean === null) return 16777215;\n        // Calculate the interpolated rgb for this value\n        // The interpolated color comes in rbg format\n        const hexColor = d3color(nglColorScale(mean)).formatHex();\n        // The color interpolation returns a string like '#000000'\n        // We remove the first character ('#') and parse it to integer from hexadecimal\n        const color = parseInt(hexColor.substring(1), 16);\n        return color;\n      };\n    });\n\n    // Set the viewer configuration: components and representations\n\n    // Get the number of frames in the trajectory\n    const trajectoryFrameCount = metadata.mdFrames;\n\n    // Get the frames step from the analysis itself\n    const frameStep = payload['step'];\n\n    // Load the required frames from the main trajectory\n    const trajectoryUrl = `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/trajectory`;\n    const mainURL = `${trajectoryUrl}?frames=1:${trajectoryFrameCount}:${frameStep}`;\n\n    // Set the components by setting a custom component with an extended trajectory\n    const components = [ { trajectoryURLs: [mainURL] } ];\n\n    // Set the representations by showing all default representations repainted\n    const representations = [];\n    defaultRepresentations.forEach(representation => {\n      const newRepresentation = { ...representation };\n      newRepresentation.color = 'custom';\n      newRepresentation.customScheme = colorScheme;\n      representations.push(newRepresentation);\n    });\n\n    // Get the number of frames in the analysis from the first residue data\n    const firstResidueData = rmsdpr[0];\n    const analysisFrameCount = firstResidueData.length;\n\n    // Get the total time length\n    const timeLength = metadata.timeLength;\n\n    // If this is an ensemble or we are missing the time length then we use frames as the x axis\n    // If this is a trajectory and we have the time length then we use time as the x axis\n    const isEnsemble = metadata.TYPE === 'ensemble';\n    let xAxisStep;\n    let xAxisLabel;\n    let xTooltip;\n    if (isEnsemble || !timeLength) {\n      xAxisStep = frameStep;\n      xAxisLabel = 'Frames';\n      xTooltip = xValue => 'frame ' + xValue;\n    }\n    else {\n      xAxisStep = timeLength / (analysisFrameCount - 1);\n      xAxisLabel = 'Time (ns)';\n      xTooltip = xValue => +xValue.toFixed(2) + ' ns';\n    }\n\n    // Get the weigths for each data value corresponding frame\n    let xWeights;\n    if (populations && populations.payload) {\n      xWeights = [];\n      for (let i = 0; i < populations.payload.length; i += xAxisStep) {\n        xWeights.push(populations.payload[i]);\n      }\n    }\n\n    // Return values to be memoized\n    return {\n      components,\n      representations,\n      analysisFrameCount,\n      xAxisStep,\n      xAxisLabel,\n      isEnsemble,\n      xTooltip,\n      data,\n      xWeights,\n    };\n  }, [\n    payload,\n    topologyManager,\n    metadata,\n    accessionAndMdNumber,\n    defaultRepresentations,\n    populations,\n  ]);\n\n  // Get the residues list in model notation\n  const { selectedData, selectedResidueIndices } = useMemo(() => {\n    // Now get only the selected keys from the payload\n    const selectedData = {};\n    const selectedResidueIndices = [];\n    // Color the first selected residues in the graph\n    selectedResidues.forEach((residue, i) => {\n      const currentResidueData = data.rmsdpr[residue.index];\n      const newData = { data: currentResidueData };\n      newData.color = residue.color;\n      selectedData[i] = newData;\n      selectedResidueIndices.push(residue.index);\n    });\n    return { selectedData, selectedResidueIndices };\n  }, [data, selectedResidues]);\n\n  // When the user clicks on the graph\n  const handleFrameSelection = useCallback(frame => {\n    viewerRef.current.togglePlaying(false);\n    viewerRef.current.currentFrame = frame;\n  }, []);\n\n  // When the ngl is playing\n  const handleFrameProgress = useCallback(\n    progress => {\n      if (!graphRef.current) return;\n      // Process is a float number which ranges from 0 to 1\n      // Guess the frame number which belongs to the process\n      // WARNING: The follwoing multiplication must return always a whole number\n      // WARNING: This 'round' is only for the float problem (e.g. 57 = 56.9999...)\n      const frame = Math.round(progress * (analysisFrameCount - 1));\n      graphRef.current.marks = [\n        {\n          x: frame,\n          attr: { fill: '#c8c8c8' },\n        },\n      ];\n    },\n    [analysisFrameCount],\n  );\n\n  // When a residue is selected\n  const handleSelect = useCallback(\n    (residue, residueIndex, color) => {\n      const selectedResidue = { color, index: residueIndex };\n      setSelectedResidues(previous => [...previous, selectedResidue]);\n    },\n    [setSelectedResidues],\n  );\n  // When a residue is deselected\n  const handleDeselect = useCallback(\n    (residue, residueIndex) => {\n      setSelectedResidues(previous =>\n        previous.filter(residue => residue.index !== residueIndex),\n      );\n    },\n    [setSelectedResidues],\n  );\n  // When the clean all residues button is clicked\n  const handleClean = useCallback(() => {\n    setSelectedResidues([]);\n  }, [setSelectedResidues]);\n\n  // Handle what to write on the tooltip when the user hovers a specific residue letter\n  const handleTooltip = useCallback(\n    (residue, residueIndex) => {\n      const currentResidueMean = data.means[residueIndex];\n      const currentResidueStdv = data.stdvs[residueIndex];\n      const meanRMSD = Math.round(currentResidueMean * 100) / 100;\n      const stdvRMSD = Math.round(currentResidueStdv * 100) / 100;\n      return `Mean RMSD: ${meanRMSD}\\nStandard deviation: ${stdvRMSD}`;\n    },\n    [data],\n  );\n\n  // Render loading or error messages according with the API response\n  if (loading || (populations && populations.loading)) return <Loading />;\n  else if (error) return error.toString();\n  else if (populations && populations.error)\n    return populations.error.toString();\n  else if (!payload) return 'Something bad happened with the analysis data';\n  else if (populations && !populations.payload)\n    return 'Something bad happened with populations';\n\n  if (!topologyManager) return <Loading />;\n\n  // Render\n  return (\n    <Suspense fallback={<Loading />}>\n      <Card>\n        <ResidueSelector\n          residueValues={data.means}\n          legendTitle={'Average RMSD (Å)'}\n          onSelect={handleSelect}\n          onDeselect={handleDeselect}\n          onClean={handleClean}\n          onTooltip={handleTooltip}\n        />\n      </Card>\n      <Card className={style.graphcard}>\n        {selectedResidues.length > 0 ? (\n          <Graph\n            yData={selectedData}\n            step={xAxisStep}\n            xAxisLabel={xAxisLabel}\n            type={isEnsemble ? 'dots' : 'line'}\n            xWeights={xWeights}\n            xTooltip={xTooltip}\n            yAxisLabel={'RMSd (Å)'}\n            onSelect={handleFrameSelection}\n            className={style.graph}\n            ref={graphRef}\n          />\n        ) : (\n          <div className={style['graph-placeholder']}>\n            <Typography variant=\"h6\">No residue selected</Typography>\n          </div>\n        )}\n      </Card>\n      <Card className={style.nglcard} ref={nglRef}>\n        {/* Render the NGL viewer when it is on screen*/}\n        {isNglVisible ? (\n          <ViewerWithControls\n            className={style.container}\n            startingComponents={components}\n            startingRepresentations={representations}\n            selectedResidueIndices={selectedResidueIndices}\n            onProgress={handleFrameProgress}\n            ref={viewerRef}\n            framesSelect={false}\n          />\n        ) : (\n          <div style={{ height: '50vh' }} />\n        )}\n      </Card>\n    </Suspense>\n  );\n};\n\nexport default RmsdPerres;\n"],"names":["useInViewOptions","triggerOnce","rootMargin","nglColorPlan","nice","number","Math","round","RmsdPerres","nglRef","isNglVisible","useInView","accessionAndMdNumber","metadata","topology","topologyManager","populations","useContext","ProjectCtx","defaultRepresentations","useDefaultRepresentations","viewerRef","useRef","graphRef","loading","payload","error","useAPI","concat","BASE_PATH_PROJECTS","selectedResidues","setSelectedResidues","useState","components","representations","analysisFrameCount","xAxisStep","xAxisLabel","isEnsemble","xTooltip","data","xWeights","useMemo","rmsdpr","means","stdvs","forEach","rmsdpf","push","mean","stdv","values","n","length","reduce","a","b","sqrt","map","x","pow","getStaistics","max","min","nglColorScale","scaleLinear","range","domain","colorScheme","ColormakerRegistry","addScheme","params","this","atomColor","atom","residueIndex","hexColor","d3color","formatHex","parseInt","substring","trajectoryFrameCount","mdFrames","frameStep","trajectoryUrl","trajectoryURLs","representation","newRepresentation","color","customScheme","timeLength","TYPE","xValue","toFixed","i","selectedData","selectedResidueIndices","residue","newData","index","handleFrameSelection","useCallback","frame","current","togglePlaying","currentFrame","handleFrameProgress","progress","marks","attr","fill","handleSelect","selectedResidue","previous","handleDeselect","filter","handleClean","handleTooltip","currentResidueMean","currentResidueStdv","meanRMSD","stdvRMSD","_jsx","Loading","toString","_jsxs","Suspense","fallback","children","Card","ResidueSelector","residueValues","legendTitle","onSelect","onDeselect","onClean","onTooltip","className","style","Graph","yData","step","type","yAxisLabel","ref","Typography","variant","ViewerWithControls","startingComponents","startingRepresentations","onProgress","framesSelect","height"],"sourceRoot":""}