{"version":3,"file":"static/js/5291.6de179ad.chunk.js","mappings":"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","sources":["../node_modules/lodash-es/_baseToString.js","../node_modules/lodash-es/toString.js","../node_modules/lodash-es/_isFlattenable.js","../node_modules/lodash-es/_baseFlatten.js","../node_modules/lodash-es/_arrayMap.js","../node_modules/lodash-es/noop.js","utils/statistics/index.js","../node_modules/@mui/material/internal/svg-icons/CheckBoxOutlineBlank.js","../node_modules/@mui/material/internal/svg-icons/CheckBox.js","../node_modules/@mui/material/internal/svg-icons/IndeterminateCheckBox.js","../node_modules/@mui/material/Checkbox/checkboxClasses.js","../node_modules/@mui/material/Checkbox/Checkbox.js","../node_modules/lodash-es/flatten.js","../node_modules/lodash-es/uniqueId.js","components/graph/add-text-background/index.js","components/graph/add-masks/index.js","webpack://mdposit/./src/components/graph/style.module.css?7739","webpack://mdposit/./src/components/graph/line-sample/style.module.css?e034","components/graph/line-sample/index.js","components/graph/index.js","utils/document-measurer/index.js"],"sourcesContent":["import Symbol from './_Symbol.js';\nimport arrayMap from './_arrayMap.js';\nimport isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default baseToString;\n","import baseToString from './_baseToString.js';\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nexport default toString;\n","import Symbol from './_Symbol.js';\nimport isArguments from './isArguments.js';\nimport isArray from './isArray.js';\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nexport default isFlattenable;\n","import arrayPush from './_arrayPush.js';\nimport isFlattenable from './_isFlattenable.js';\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nexport default baseFlatten;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nexport default arrayMap;\n","/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nexport default noop;\n","// Statistics\n// Provide some usual statistics functions\n\n// Set a function which returns just the average\nexport const getMean = data => {\n  if (!data) return;\n  const sum = data.reduce((pv, cv) => pv + cv, 0);\n  const n = data.length;\n  return sum / n;\n};\n\n// Set a function which returns the average and standard deviation from a numeric array\nexport const getMeanAndStdv = data => {\n  if (!data) return;\n  const sum = data.reduce((pv, cv) => pv + cv, 0);\n  const n = data.length;\n  const mean = sum / n;\n  const stdv = Math.sqrt(\n    data.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n,\n  );\n  return { mean, stdv };\n};\n","'use client';\n\nimport * as React from 'react';\nimport createSvgIcon from '../../utils/createSvgIcon';\n\n/**\n * @ignore - internal component.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z\"\n}), 'CheckBoxOutlineBlank');","'use client';\n\nimport * as React from 'react';\nimport createSvgIcon from '../../utils/createSvgIcon';\n\n/**\n * @ignore - internal component.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"\n}), 'CheckBox');","'use client';\n\nimport * as React from 'react';\nimport createSvgIcon from '../../utils/createSvgIcon';\n\n/**\n * @ignore - internal component.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z\"\n}), 'IndeterminateCheckBox');","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getCheckboxUtilityClass(slot) {\n  return generateUtilityClass('MuiCheckbox', slot);\n}\nconst checkboxClasses = generateUtilityClasses('MuiCheckbox', ['root', 'checked', 'disabled', 'indeterminate', 'colorPrimary', 'colorSecondary', 'sizeSmall', 'sizeMedium']);\nexport default checkboxClasses;","'use client';\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"checkedIcon\", \"color\", \"icon\", \"indeterminate\", \"indeterminateIcon\", \"inputProps\", \"size\", \"className\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport refType from '@mui/utils/refType';\nimport composeClasses from '@mui/utils/composeClasses';\nimport { alpha } from '@mui/system/colorManipulator';\nimport SwitchBase from '../internal/SwitchBase';\nimport CheckBoxOutlineBlankIcon from '../internal/svg-icons/CheckBoxOutlineBlank';\nimport CheckBoxIcon from '../internal/svg-icons/CheckBox';\nimport IndeterminateCheckBoxIcon from '../internal/svg-icons/IndeterminateCheckBox';\nimport capitalize from '../utils/capitalize';\nimport { useDefaultProps } from '../DefaultPropsProvider';\nimport styled, { rootShouldForwardProp } from '../styles/styled';\nimport checkboxClasses, { getCheckboxUtilityClass } from './checkboxClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    classes,\n    indeterminate,\n    color,\n    size\n  } = ownerState;\n  const slots = {\n    root: ['root', indeterminate && 'indeterminate', `color${capitalize(color)}`, `size${capitalize(size)}`]\n  };\n  const composedClasses = composeClasses(slots, getCheckboxUtilityClass, classes);\n  return _extends({}, classes, composedClasses);\n};\nconst CheckboxRoot = styled(SwitchBase, {\n  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',\n  name: 'MuiCheckbox',\n  slot: 'Root',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, ownerState.indeterminate && styles.indeterminate, styles[`size${capitalize(ownerState.size)}`], ownerState.color !== 'default' && styles[`color${capitalize(ownerState.color)}`]];\n  }\n})(({\n  theme,\n  ownerState\n}) => _extends({\n  color: (theme.vars || theme).palette.text.secondary\n}, !ownerState.disableRipple && {\n  '&:hover': {\n    backgroundColor: theme.vars ? `rgba(${ownerState.color === 'default' ? theme.vars.palette.action.activeChannel : theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(ownerState.color === 'default' ? theme.palette.action.active : theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),\n    // Reset on touch devices, it doesn't add specificity\n    '@media (hover: none)': {\n      backgroundColor: 'transparent'\n    }\n  }\n}, ownerState.color !== 'default' && {\n  [`&.${checkboxClasses.checked}, &.${checkboxClasses.indeterminate}`]: {\n    color: (theme.vars || theme).palette[ownerState.color].main\n  },\n  [`&.${checkboxClasses.disabled}`]: {\n    color: (theme.vars || theme).palette.action.disabled\n  }\n}));\nconst defaultCheckedIcon = /*#__PURE__*/_jsx(CheckBoxIcon, {});\nconst defaultIcon = /*#__PURE__*/_jsx(CheckBoxOutlineBlankIcon, {});\nconst defaultIndeterminateIcon = /*#__PURE__*/_jsx(IndeterminateCheckBoxIcon, {});\nconst Checkbox = /*#__PURE__*/React.forwardRef(function Checkbox(inProps, ref) {\n  var _icon$props$fontSize, _indeterminateIcon$pr;\n  const props = useDefaultProps({\n    props: inProps,\n    name: 'MuiCheckbox'\n  });\n  const {\n      checkedIcon = defaultCheckedIcon,\n      color = 'primary',\n      icon: iconProp = defaultIcon,\n      indeterminate = false,\n      indeterminateIcon: indeterminateIconProp = defaultIndeterminateIcon,\n      inputProps,\n      size = 'medium',\n      className\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const icon = indeterminate ? indeterminateIconProp : iconProp;\n  const indeterminateIcon = indeterminate ? indeterminateIconProp : checkedIcon;\n  const ownerState = _extends({}, props, {\n    color,\n    indeterminate,\n    size\n  });\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(CheckboxRoot, _extends({\n    type: \"checkbox\",\n    inputProps: _extends({\n      'data-indeterminate': indeterminate\n    }, inputProps),\n    icon: /*#__PURE__*/React.cloneElement(icon, {\n      fontSize: (_icon$props$fontSize = icon.props.fontSize) != null ? _icon$props$fontSize : size\n    }),\n    checkedIcon: /*#__PURE__*/React.cloneElement(indeterminateIcon, {\n      fontSize: (_indeterminateIcon$pr = indeterminateIcon.props.fontSize) != null ? _indeterminateIcon$pr : size\n    }),\n    ownerState: ownerState,\n    ref: ref,\n    className: clsx(classes.root, className)\n  }, other, {\n    classes: classes\n  }));\n});\nprocess.env.NODE_ENV !== \"production\" ? Checkbox.propTypes /* remove-proptypes */ = {\n  // ┌────────────────────────────── Warning ──────────────────────────────┐\n  // │ These PropTypes are generated from the TypeScript type definitions. │\n  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │\n  // └─────────────────────────────────────────────────────────────────────┘\n  /**\n   * If `true`, the component is checked.\n   */\n  checked: PropTypes.bool,\n  /**\n   * The icon to display when the component is checked.\n   * @default <CheckBoxIcon />\n   */\n  checkedIcon: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'primary'\n   */\n  color: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['default', 'primary', 'secondary', 'error', 'info', 'success', 'warning']), PropTypes.string]),\n  /**\n   * The default checked state. Use when the component is not controlled.\n   */\n  defaultChecked: PropTypes.bool,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: PropTypes.bool,\n  /**\n   * If `true`, the ripple effect is disabled.\n   * @default false\n   */\n  disableRipple: PropTypes.bool,\n  /**\n   * The icon to display when the component is unchecked.\n   * @default <CheckBoxOutlineBlankIcon />\n   */\n  icon: PropTypes.node,\n  /**\n   * The id of the `input` element.\n   */\n  id: PropTypes.string,\n  /**\n   * If `true`, the component appears indeterminate.\n   * This does not set the native input element to indeterminate due\n   * to inconsistent behavior across browsers.\n   * However, we set a `data-indeterminate` attribute on the `input`.\n   * @default false\n   */\n  indeterminate: PropTypes.bool,\n  /**\n   * The icon to display when the component is indeterminate.\n   * @default <IndeterminateCheckBoxIcon />\n   */\n  indeterminateIcon: PropTypes.node,\n  /**\n   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.\n   */\n  inputProps: PropTypes.object,\n  /**\n   * Pass a ref to the `input` element.\n   */\n  inputRef: refType,\n  /**\n   * Callback fired when the state is changed.\n   *\n   * @param {React.ChangeEvent<HTMLInputElement>} event The event source of the callback.\n   * You can pull out the new checked state by accessing `event.target.checked` (boolean).\n   */\n  onChange: PropTypes.func,\n  /**\n   * If `true`, the `input` element is required.\n   * @default false\n   */\n  required: PropTypes.bool,\n  /**\n   * The size of the component.\n   * `small` is equivalent to the dense checkbox styling.\n   * @default 'medium'\n   */\n  size: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['medium', 'small']), PropTypes.string]),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n  /**\n   * The value of the component. The DOM API casts this to a string.\n   * The browser uses \"on\" as the default value.\n   */\n  value: PropTypes.any\n} : void 0;\nexport default Checkbox;","import baseFlatten from './_baseFlatten.js';\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nexport default flatten;\n","import toString from './toString.js';\n\n/** Used to generate unique IDs. */\nvar idCounter = 0;\n\n/**\n * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {string} [prefix=''] The value to prefix the ID with.\n * @returns {string} Returns the unique ID.\n * @example\n *\n * _.uniqueId('contact_');\n * // => 'contact_104'\n *\n * _.uniqueId();\n * // => '105'\n */\nfunction uniqueId(prefix) {\n  var id = ++idCounter;\n  return toString(prefix) + id;\n}\n\nexport default uniqueId;\n","import { uniqueId } from 'lodash-es';\n\nconst addTextBackground = defs => {\n  const id = uniqueId('background-');\n\n  const filter = defs\n    .append('filter')\n    .attr('x', 0)\n    .attr('y', 0)\n    .attr('width', 1)\n    .attr('height', 1)\n    .attr('id', id);\n  filter.append('feFlood').attr('flood-color', 'white');\n  filter.append('feComposite').attr('in', 'SourceGraphic');\n  return `url(#${id})`;\n};\n\nexport default addTextBackground;\n","import { uniqueId } from 'lodash-es';\n\nconst addMasks = defs => {\n  const idStart = uniqueId('gradient-start-');\n  const idEnd = uniqueId('gradient-end-');\n  const startMaskGradient = defs.append('linearGradient').attr('id', idStart);\n  startMaskGradient\n    .append('stop')\n    .attr('offset', '0%')\n    .style('stop-color', 'white')\n    .style('stop-opacity', '1');\n  startMaskGradient\n    .append('stop')\n    .attr('offset', '100%')\n    .style('stop-color', 'white')\n    .style('stop-opacity', '0');\n  const endMaskGradient = defs.append('linearGradient').attr('id', idEnd);\n  endMaskGradient\n    .append('stop')\n    .attr('offset', '0%')\n    .style('stop-color', 'white')\n    .style('stop-opacity', '0');\n  endMaskGradient\n    .append('stop')\n    .attr('offset', '100%')\n    .style('stop-color', 'white')\n    .style('stop-opacity', '1');\n  return [`url(#${idStart})`, `url(#${idEnd})`];\n};\n\nexport default addMasks;\n","// extracted by mini-css-extract-plugin\nexport default {\"default\":\"style_default__PoK16\",\"flexible\":\"style_flexible__UEdHy\",\"graph-container\":\"style_graph-container__j1+gF\",\"graph-legend\":\"style_graph-legend__z5iWz\",\"graph-display-legend\":\"style_graph-display-legend__zhM2L\",\"line-sample\":\"style_line-sample__1vgXB\"};","// extracted by mini-css-extract-plugin\nexport default {\"default\":\"style_default__IVrx2\"};","import React, { useRef, useEffect } from 'react';\nimport { select } from 'd3';\n\nimport style from './style.module.css';\n\nconst LineSample = ({ color, dash, className }) => {\n  // Referenced document element where d3 is rendered\n  const containerRef = useRef(null);\n\n  // This useEffect must be run only once\n  useEffect(() => {\n    const graph = select(containerRef.current);\n    graph.attr('width', 50).attr('height', 5);\n    graph\n      .append('line')\n      .style('stroke', color)\n      .style('stroke-dasharray', dash)\n      .style('stroke-width', 3)\n      .attr('x1', 0)\n      .attr('y1', 0)\n      .attr('x2', 50)\n      .attr('y2', 0);\n  }, []);\n  // Maybe might need to double-check that and remove the exception\n\n  return (\n    <svg ref={containerRef} className={className ? className : style.default} />\n  );\n};\n\nexport default LineSample;\n","import React, {\n  useState,\n  useCallback,\n  useRef,\n  useEffect,\n  useMemo,\n  forwardRef,\n  useImperativeHandle,\n} from 'react';\nimport { noop, flatten } from 'lodash-es';\nimport {\n  select,\n  scaleLinear,\n  scaleLog,\n  axisBottom,\n  axisLeft,\n  extent,\n  line,\n  mouse,\n  zoom,\n  event,\n  area,\n} from 'd3';\n\nimport { FormControlLabel, Checkbox } from '@mui/material';\n\nimport { NICE_NAMES } from '../../utils/constants';\n\nimport addTextBackground from './add-text-background';\nimport addMasks from './add-masks';\n\nimport { getTextWidth, getTextSizeDOM } from '../../utils/document-measurer';\n\nimport { getMean, getMeanAndStdv } from '../../utils/statistics';\n\nimport style from './style.module.css';\n\nimport LineSample from './line-sample';\n\n// Number of data points to be represented at the same time FOR EACH dataset\n// WARNING: The component would support quite more points with good performace\n// WARNING: However, more points would make the visualization less 'comfortable'\n// This is the minimum number of data points to be shown at maximum zoom (i.e. maximum precision)\n// Thus it limits how much the graph can be zoomed\n// At the same time, it is the maximum number of points to be shown at minimum zoom\n// Thus it limits the precision at minimum zoom\n// DANI: Hay algunas escalas del d3 que no llegué a comprender bien\n// DANI: Puede que el número no se respete del todo\nconst NUMBER_OF_DATA_POINTS_ON_SCREEN = 100; // i.e. minimum number of points in screen\n\n// Set the separation between text labels which appear when we hover data points\nconst HOVER_TEXT_SEPARATION = 25;\n\n// Set a small offset to be added between normal labels and 90 degrees rotated labels\n// This offset is added between the y labels (normal) and the y title (rotated)\n// This offset is added between the x labels (rotated) and the x title (normal)\nconst roatatedTextOffset = 9; // In px\n\n// Set a small offset to keep away the axis labels and the axis values\n// They are very close to the axis values by default\nconst axisLabelsOffset = 9; // In px\n\n// Set the default dot radius and thus calculate the default dot area\nconst DEFAULT_DOT_RADIUS = 3;\nconst DEFAULT_DOT_AREA = Math.PI * DEFAULT_DOT_RADIUS ** 2;\n\nconst dPR = window.devicePixelRatio || 1;\n\n// According to d3 documentation\nconst defaultD3font = 'normal 10px sans-serif';\n// Experimentally verfied\nconst titlesD3font = 'normal 14px sans-serif';\n\nconst yDataPlaceholder = { placeholder: { data: [0] } };\nconst defaultMargins = { top: 10, right: 10, bottom: 10, left: 10 };\n\n// This function is a workaround to calculate maximum values from an array without spread syntax\n// Some browsers (e.g. Chrome) do not support large amount of arguments in a function\n// For this reason, Math.max(...values) will fail if the 'values' array is long enough\n// The returned error is “RangeError: Maximum call stack size exceeded”\nconst steppedMax = values => {\n  let max = Number.NEGATIVE_INFINITY;\n  values.forEach(value => {\n    max = Math.max(value, max);\n  });\n  return max;\n};\n\n// Create an object with all specified keys and all values as true\nconst trueEntries = keys => {\n  const object = {};\n  keys.forEach(key => (object[key] = true));\n  return object;\n};\n\nconst isCanvasPowered = type => type === 'dash' || type === 'dots';\n\n// The expected input data (y) is:\n// {\n//    dataset1:{\n//      data: [... the main data ...]\n//      average: float,\n//      color: 'red',\n//      dash: \"5, 5\",\n//    }\n//    dataset2:{...}\n// }\n\nconst Graph = forwardRef(({ // The main data\n  yData, xAxisValues, step = 1, title, xAxisLabel, yAxisLabel, xScaleFactor = 1, xColors, xWeights, xTooltip, type = 'line', onHover, onSelect, selfLegend = false, displayLegend = false, dataDisplay, setDataDisplay, mean = false, standardDeviation = false, margin = defaultMargins, flippedXAxisValues = false, fullPrecision = false, className, marks, densityStdDev = false }, ref) => { // Note that this is only compatible with dash/dots types, not line // Thea main data to be represented // Optional x tags // not sure // Graph title // The x axis label text // The y axis label text // The difference beyween x values // Color each different dot in the graph dependeing on its x index\n  // Define the weights for each x value. This is only compatible with type = 'dots' and makes dots bigger // The function to set what to show on the tooltip based in the x value where the mouse is hovering // Set the type of graph to render. Accepted values: line, dash // Object with each dataset name and a value of true/false to set which data is displayed // dataDisplay setter // Display the mean line in the graph // Display the standard deviation area in the graph // Set an extra margin around the graph // Set if values in x axis is horizontal (false) or vertical (true) // If true, draw all points in the graph no matter how many points are there // Force a classname for the overall component element // Mark x values by displaying a vertical line in their positions\n  // -  style: object with all the style names (keys) and their values according to d3\n  // -  attr: object with all the attribute names (keys) and their values according to d3\n  // -  x: the position of the mark according to the x axis\n  // Set a fake dataset to allow the graph to work when no data is passed\n  if (!yData || Object.keys(yData).length === 0) yData = yDataPlaceholder;\n\n  // Referenced document element where d3 is rendered\n  const containerRef = useRef(null);\n  // Referenced function which allows to update the cart without having to remake it\n  const drawRef = useRef(noop);\n  const onSelectRef = useRef(noop);\n  const marksRef = useRef(noop);\n  const hoveredRef = useRef(noop);\n\n  // Get each dataset\n  const { yEntries, yKeys } = useMemo(() => {\n    const yEntries = Object.entries(yData);\n    const yKeys = yEntries.map(([key]) => key);\n    return { yEntries, yKeys };\n  }, [yData]);\n\n  // ----------------------------------------------------------------------------------------\n\n  // OFFSETS: Estimate the space needed for all the labels and titles to not overlap\n  // DANI: Toda esta parte no se actualiza en el drawRef en caso de que los valores de las labels cambien\n  // DANI: Esto da problemas si queremos cargar un graph sin data para luego ir metiendo data\n  // DANI: El graph se creará sin margen para las labels y cuando introduzcamos data habrá un overlap\n  const {\n    offset,\n    labelsHeight,\n    requiredBottomOffset,\n    yAxisLabelHegiht,\n  } = useMemo(() => {\n    // Set the yAxisValues by adding all dataset 'data' values\n    let yAxisValues = yEntries\n      .map(([, dataset]) => dataset.data)\n      .reduce((cv, nv) => cv.concat(nv));\n    // Round values if they are numeric, since labels just reach x.00\n    yAxisValues = yAxisValues.map(v => Math.round(v * 100) / 100);\n\n    // Measure the height of normal and text and labels\n    const textHeight = getTextSizeDOM('|', defaultD3font).height;\n    const labelsHeight =\n      getTextSizeDOM('|', titlesD3font).height + axisLabelsOffset;\n\n    // Get the calculated widths of all y labels and select the maximum\n    // In addition, add a small offset between labels and the axis which is added further\n    // This offset is only in x axes, which are rotated 90 degrees and end too much close to the axis\n    const maxXAxisWidth = xAxisValues\n      ? steppedMax(\n          xAxisValues.map(label => getTextWidth(label, defaultD3font)),\n        ) + roatatedTextOffset\n      : 10;\n    // Get the calculated widths of all y labels and select the maximum\n    const maxYAxisWidth = steppedMax(\n      yAxisValues.map(label => getTextWidth(label, defaultD3font)),\n    );\n\n    // In addition, add a small offset between labels and the axis which is added further\n    // This offset is only in x axes, which are rotated 90 degrees and end too much close to the axis\n    const xAxisLabelHegiht = xAxisLabel ? labelsHeight : 0;\n    const yAxisLabelHegiht = yAxisLabel ? labelsHeight + roatatedTextOffset : 0;\n\n    // Finally, estimate the space needed by axes, titles, etc.\n    const requiredTopOffset = title ? labelsHeight + axisLabelsOffset : 0;\n    const requiredBottomOffset = flippedXAxisValues\n      ? maxXAxisWidth + xAxisLabelHegiht\n      : textHeight + xAxisLabelHegiht;\n    const requiredLeftOffset =\n      yAxisValues.length === 1 && yData !== yDataPlaceholder\n        ? Math.max(maxYAxisWidth, getTextWidth(yAxisLabel, titlesD3font))\n        : maxYAxisWidth + yAxisLabelHegiht;\n\n    // Set the dimensions and offsets of the graph\n    const offset = {\n      top: requiredTopOffset + margin.top,\n      right: margin.right,\n      bottom: requiredBottomOffset + margin.bottom,\n      left: requiredLeftOffset + margin.left,\n    };\n    return { offset, labelsHeight, requiredBottomOffset, yAxisLabelHegiht };\n  }, [\n    flippedXAxisValues,\n    margin,\n    title,\n    xAxisLabel,\n    xAxisValues,\n    yAxisLabel,\n    yData,\n    yEntries,\n  ]);\n\n  // ----------------------------------------------------------------------------------------\n\n  // Object with entries defining which data is displayed (true) or hidden (false)\n  // Each entry has the same key that its corresponding dataset\n  // First set a defualt internal state for cases where it is not passed with the arguments\n  const [internalDataDisplay, setInternalDataDisplay] = useState(\n    trueEntries(yKeys),\n  );\n  // Update the internal data display when data changes\n  useEffect(() => {\n    setInternalDataDisplay(trueEntries(yKeys));\n  }, [yKeys]);\n\n  // If the data display state was passed then use it\n  // Otherwise, use the internal state\n  const [lab, setLab] = dataDisplay\n    ? [dataDisplay, setDataDisplay]\n    : [internalDataDisplay, setInternalDataDisplay];\n\n  const previousValues = useRef({\n    data: yDataPlaceholder,\n    labels: lab,\n    currentZoom: { k: 1, x: 0, rescaleX: scale => scale },\n    xAxisLabel,\n    yAxisLabel,\n    xAxisValues,\n    onSelect,\n    step,\n    marks,\n  });\n\n  // This useEffect must be run only once\n  // The graph content is updated through the 'drawRef' referenced function\n  useEffect(() => {\n    // Set the d3 base\n    // Use canvas to display the dash blocks since d3 is not as efficient\n    let canvas;\n    let canvasContext;\n    if (isCanvasPowered(type)) {\n      canvas = select(containerRef.current).append('canvas');\n      canvasContext = canvas\n        .node()\n        .getContext('2d' /*, {desynchronized: true}*/);\n    }\n    const graph = select(containerRef.current).append('svg');\n    // 'defs' is an element used to store graphical data which is not rendered directly\n    // Graphics in defs are displayed later by refering them\n    const defs = graph.append('defs');\n    // text background\n    const textBackgroundURL = addTextBackground(defs);\n\n    // mask opacity\n    const [startMaskURL, endMaskURL] = addMasks(defs);\n\n    // Set the marks node now, so they are not placed over the graph\n    const marksNode = graph.append('g');\n\n    const main = graph.append('g');\n\n    // Set the dots in the graph\n    const allDotGroups = main.append('g');\n\n    // order is important, everything before that will be hidden by masks\n    // masks\n    graph\n      .append('rect')\n      .attr('x', 0)\n      .attr('y', 0)\n      .attr('width', offset.left)\n      .attr('height', '100%')\n      .style('fill', startMaskURL);\n    const maskEnd = graph\n      .append('rect')\n      .attr('y', 0)\n      .attr('height', '100%')\n      .style('fill', endMaskURL);\n\n    // axes\n    const axes = {\n      x: graph.append('g'),\n      y: graph.append('g'),\n    };\n\n    // Set an independent dot which is in the x axis and holds the x tooltip\n    const xDot = graph.append('g');\n\n    // This ref allows to update the graph without having to remake the whole graph\n    drawRef.current = ({\n      data = previousValues.current.data,\n      labels = previousValues.current.labels,\n      step = previousValues.current.step,\n      xAxisLabel = previousValues.current.xAxisLabel,\n      yAxisLabel = previousValues.current.yAxisLabel,\n      currentZoom = previousValues.current.currentZoom,\n      xAxisValues = previousValues.current.xAxisValues,\n      onSelect = previousValues.current.onSelect,\n      marks = previousValues.current.marks,\n      offset = previousValues.current.offset,\n      labelsHeight = previousValues.current.labelsHeight,\n      requiredBottomOffset = previousValues.current.requiredBottomOffset,\n      yAxisLabelHegiht = previousValues.current.yAxisLabelHegiht,\n      xColors = previousValues.current.xColors,\n      xNormalizedWeights = previousValues.current.xNormalizedWeights,\n      xTooltip = previousValues.current.xTooltip,\n    } = {}) => {\n      // Change the graph size according to the left offset\n      graph.attr('width', offset.left);\n\n      // Save a few values for further reference\n      // These values must be saved at frist since other noop references read them from the reference\n      previousValues.current.step = step;\n      previousValues.current.xAxisValues = xAxisValues;\n\n      // container size\n      const { clientWidth: width, clientHeight: height } = containerRef.current;\n\n      const dataEntries = Object.entries(data);\n      const dataKeys = dataEntries.map(([key]) => key);\n\n      // ----------------------------------------------------------------------------\n\n      // ZOOM\n\n      // The minimum and default zoom value is 1\n      const minZoomExtent = 1;\n\n      //   make zoom extent dynamic depending on number of data points\n      //   ↳ results in similar precision at maximum zoom regardless of data size\n      const maxZoomExtent =\n        dataEntries[0][1].data.length / NUMBER_OF_DATA_POINTS_ON_SCREEN;\n\n      // Set the number of points to be represented\n      // The maximum precision is always 1\n      // i.e. When zoom is at maximum value all points in the window range must be shown\n      const precisionScale = scaleLog().range(\n        fullPrecision ? [1, 1] : [Math.ceil(maxZoomExtent), minZoomExtent],\n      );\n\n      precisionScale.domain([minZoomExtent, maxZoomExtent]);\n\n      // Get the precision to be used according to the zoom value\n      // The zoom value is a numeric value which ranges from minZoomExtent (default) to maxZoomExtent\n      const getZoomPrecision = k =>\n        2 ** Math.floor(Math.log2(precisionScale(k)));\n\n      const graphZoom = zoom().scaleExtent([minZoomExtent, maxZoomExtent]);\n      // By default, the zoom in/out event of d3 prevents the verticall scroll on mouse wheel\n      // However, when zoom has reached the maximum or minimum limit, the scroll is re-established\n      // The 'on wheel' eventdown here prevents that furtive scroll\n      graph.call(graphZoom).on('wheel', () => event.preventDefault());\n      // Update precision and rescaleX on zoom (i.e. on mouse wheel)\n      graphZoom.on('zoom', () => {\n        drawRef.current({\n          currentZoom: event.transform,\n        });\n      });\n\n      // Get the the current zoom 'k' value\n      // If it is bigger thant the maximum extent then use the maximum extent instead\n      // This may happen when the dataset is changed while the zoom is in the maximum\n      const k = Math.min(currentZoom.k, maxZoomExtent);\n      const zoomPrecision = getZoomPrecision(k);\n      const precision = isCanvasPowered(type) ? 1 : zoomPrecision;\n      const rescaleX = currentZoom.rescaleX.bind(currentZoom);\n\n      // Save precision for further reference\n      previousValues.current.precision = precision;\n\n      // ----------------------------------------------------------------------------\n\n      // DANI: Esto es mio (experimental)\n      const bodyWidth = width - offset.left - offset.right;\n      const bodyHeight = height - offset.top - offset.bottom;\n\n      graph.attr('width', width).attr('height', height);\n      if (canvas) {\n        canvas.attr('width', width * dPR).attr('height', height * dPR);\n        canvas.style('width', `${width}px`).style('height', `${height}px`);\n      }\n\n      maskEnd.attr('x', width - offset.right).attr('width', offset.right);\n\n      // Draw the title over the graph\n      if (title) {\n        // Remove the previous title\n        graph.select('#title').remove();\n        axes.title = graph\n          .append('text')\n          .attr('id', 'title')\n          .attr('class', 'title')\n          .style('text-anchor', 'middle')\n          .attr('x', width / 2)\n          .attr('y', margin.top + labelsHeight)\n          .text(title);\n      }\n\n      // Set the x minimum and maximum limits\n      const xMin = 0;\n      const xMax = dataEntries[0][1].data.length * step;\n\n      // Save this values to further reference\n      previousValues.current.xMin = xMin;\n      previousValues.current.xMax = xMax;\n\n      // Set a function which calculates de x position in screen\n      // Note that values from this function change when you grab/scroll in the graph\n      const x = rescaleX(\n        scaleLinear()\n          .domain([xMin, xMax])\n          .range([offset.left, width - offset.right]),\n      );\n      previousValues.current.x = x;\n\n      const xAxis = g =>\n        g.attr('transform', `translate(0, ${height - offset.bottom})`).call(\n          // DANI: Estos ticks los he puesto a mano tras comprobar que quedaban bien\n          axisBottom(x)\n            .ticks(7, '.2f')\n            .tickFormat(d => (xAxisValues ? xAxisValues[d] : d)),\n        );\n      axes.x.call(xAxis);\n\n      // Set the x axis label\n      if (xAxisLabel) {\n        // Remove the previous label\n        graph.select('#xlab').remove();\n        axes.xAxisLabel = graph\n          .append('text')\n          .attr('id', 'xlab')\n          .attr('class', 'x label')\n          .attr('text-anchor', 'middle')\n          .attr('x', offset.left + bodyWidth / 2)\n          .attr('y', offset.top + bodyHeight + requiredBottomOffset)\n          .text(xAxisLabel);\n      }\n\n      // y axis/axes\n      const y = scaleLinear()\n        .domain(\n          extent(\n            flatten(\n              dataEntries\n                .filter(([key]) => labels[key])\n                .map(([, { data }]) => extent(data)),\n            ),\n          ),\n        )\n        .nice()\n        .range([height - offset.bottom, offset.top]);\n\n      const yAxis = g =>\n        g\n          .attr('transform', `translate(${offset.left}, 0)`)\n          .transition()\n          .call(axisLeft(y));\n      //.call(axisLeft(y).ticks(8, '.2f')); // Use this to force the number of decimals in labels\n      axes.y.call(yAxis);\n\n      // Set the y axis label\n      if (yAxisLabel) {\n        graph.select('#ylab').remove();\n        axes.yAxisLabel = graph\n          .append('text')\n          .attr('id', 'ylab')\n          .attr('class', 'y label')\n          .attr('text-anchor', 'middle')\n          .attr('x', -(offset.top + bodyHeight / 2))\n          .attr(\n            'y',\n            margin.left +\n              yAxisLabelHegiht -\n              roatatedTextOffset -\n              axisLabelsOffset,\n          )\n          .attr('transform', 'rotate(-90)')\n          .text(yAxisLabel);\n      }\n\n      // mean line\n      if (mean) {\n        // Represent a line with this average value along the whole graph\n        const meanLines = main.selectAll('line.mean').data(dataKeys);\n        meanLines\n          .enter()\n          .append('line')\n          .attr('class', 'mean')\n          .merge(meanLines)\n          .attr('stroke', d => (data[d] && data[d].color) || 'black')\n          .attr('x1', x(xMin))\n          .attr('x2', x(xMax))\n          .attr('y1', d => y(getMean(data[d].data)))\n          .attr('y2', d => y(getMean(data[d].data)))\n          .transition()\n          .attr('opacity', d => (labels[d] ? 0.5 : 0));\n        meanLines.exit().remove();\n      }\n      // mean ± 1σ area\n      if (standardDeviation) {\n        for (const [, dataset] of dataEntries) {\n          const data = dataset.data;\n          if (!data) continue;\n          const sum = data.reduce((pv, cv) => pv + cv, 0);\n          const n = data.length;\n          const mean = sum / n;\n          dataset.stddev = Math.sqrt(\n            data.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n,\n          );\n        }\n        const sdRects = main.selectAll('rect.sd').data(dataKeys);\n        sdRects\n          .enter()\n          .append('rect')\n          .attr('class', 'sd')\n          .merge(sdRects)\n          .attr('fill', d => (data[d] && data[d].color) || 'black')\n          .attr('x', x(xMin))\n          .attr('width', x(xMax) - x(xMin))\n          .attr('y', d => {\n            const { mean, stdv } = getMeanAndStdv(data[d].data);\n            return y(mean + stdv);\n          })\n          .attr('height', d => {\n            const { mean, stdv } = getMeanAndStdv(data[d].data);\n            return y(mean - stdv) - y(mean + stdv);\n          })\n          .transition()\n          .attr('opacity', d => (labels[d] ? 0.1 : 0));\n        sdRects.exit().remove();\n      }\n      if (densityStdDev) {\n        // Create area generator for the standard deviation bands\n        const areaGenerator = area()\n          .x(d => x(d.x))\n          .y0(d => y(d.value - d.stddev))\n          .y1(d => y(d.value + d.stddev));\n\n        const sdAreas = main.selectAll('path.density-sd').data(dataKeys);\n        sdAreas\n          .enter()\n          .append('path')\n          .attr('class', 'density-sd')\n          .merge(sdAreas)\n          .attr('fill', d => (data[d] && data[d].color) || 'black')\n          .attr('d', d => {\n            if (!data[d] || !data[d].data || !data[d].densityStdDev) return null;\n            \n            // Create array of points with their standard deviations\n            // Filter points based on precision just like the line drawing\n            const points = data[d].data\n              .filter((_, i) => i % precision === 0)\n              .map((value, i) => ({\n                x: i * step * precision,\n                value: value,\n                stddev: data[d].densityStdDev[i * precision]\n              }));\n            \n            return areaGenerator(points);\n          })\n          .transition()\n          .attr('opacity', d => (labels[d] ? 0.35 : 0.0));\n        sdAreas.exit().remove();\n      }\n      const minIndex = Math.floor(x.invert(0) / step / precision);\n      const maxIndex = Math.ceil(x.invert(width) / step / precision);\n      // In case it is a classical line graph\n      if (type === 'line') {\n        // Define the data line positions\n        const lineFn = line()\n          .defined((_, i) => i >= minIndex && i <= maxIndex)\n          .x((_, i) => x(i * step * precision))\n          .y(d => y(d));\n\n        // Draw the data lines\n        // First set the lines/data mapping\n        const linesData = main.selectAll('path.line').data(dataKeys);\n        // Add as many lines as required according to the mapped data\n        linesData\n          .enter()\n          .append('path')\n          .attr('class', 'line')\n          .attr('fill', 'none')\n          // Update existing lines with the mapped data\n          .merge(linesData)\n          .attr('stroke', d => data[d].color || 'black')\n          .style('stroke-dasharray', d =>\n            data[d].dash ? data[d].dash : undefined,\n          )\n          .attr('stroke-linejoin', 'round')\n          .attr('stroke-linecap', 'round')\n          .attr('d', d =>\n            lineFn(data[d].data.filter((_, i) => i % precision === 0)),\n          )\n          .transition()\n          .attr('opacity', d => (labels[d] ? 1 : 0))\n          .attr('stroke-width', 1.5);\n        // Remove lines which are not required anymore according to the mapped data\n        linesData.exit().remove();\n        // Save this node for further reference\n        previousValues.current.linesData = linesData;\n      }\n      // NEVER FORGET: We do not use d3 dots since they are way less efficient than canvas\n      // In case it is a dash graph\n      else if (isCanvasPowered(type) && canvasContext) {\n        // For the dash\n        const dashWidth = Math.max(1, x(1) - x(0));\n        const dashHeight = 5;\n        // For the dots\n        const startAngle = 0;\n        const endAngle = 2 * Math.PI;\n        canvasContext.clearRect(0, 0, width, height);\n        for (const [key, { data: values, color }] of Object.entries(data)) {\n          if (!labels[key]) continue;\n          canvasContext.fillStyle = color || '#000000';\n          const maxInView = Math.min(values.length - 1, maxIndex);\n          // each atom in view\n          for (\n            let index = Math.max(0, minIndex);\n            index <= maxInView;\n            index += 1\n          ) {\n            // Skip the follwoing dot if the zoom precision says so\n            if (index % zoomPrecision !== 0) continue;\n            // Color the rectangle according to the equivalent atom element\n            if (xColors) {\n              const atomColor = xColors[index];\n              // If the color is white (i.e. it is an hydrogen) then paint it slightly grey\n              // The background is white so a white rectangle would be not visible\n              canvasContext.fillStyle =\n                atomColor === 'white' ? '#eeeeee' : atomColor;\n            }\n            // Draw a rectangle\n            if (type === 'dash') {\n              canvasContext.fillRect(\n                (x(index * step * precision) - dashWidth / 2) * dPR,\n                (y(values[index]) - dashHeight / 2) * dPR,\n                dashWidth * dPR,\n                dashHeight * dPR,\n              );\n            }\n            // Draw a circle\n            if (type === 'dots') {\n              // Set the x y positions\n              const xPosition =\n                (x(index * step * precision) - dashWidth / 2) * dPR;\n              const yPosition = (y(values[index]) - dashHeight / 2) * dPR;\n              // Set the radius, which may be affected by the x weights, when passed\n              let radius = DEFAULT_DOT_RADIUS; // Its 3\n              if (xNormalizedWeights) {\n                const weight = xNormalizedWeights[index];\n                const area = DEFAULT_DOT_AREA * weight;\n                radius = Math.sqrt(area / Math.PI);\n              }\n              // Draw the circle\n              canvasContext.beginPath();\n              canvasContext.arc(\n                xPosition,\n                yPosition,\n                radius,\n                startAngle,\n                endAngle,\n              );\n              canvasContext.fill();\n            }\n          }\n        }\n      }\n\n      // Calculate the width of a vertical lines used to highlight specific x values\n      const xUnitWidth = Math.max(1, x(zoomPrecision * step) - x(0));\n      previousValues.current.xUnitWidth = xUnitWidth;\n      // Place vertical lines for specified marks\n      marksRef.current({ marks });\n\n      // dots over the selected vertical line\n      // Here we just delete previous dots and start again instead of updating them\n      allDotGroups.selectAll('g.dot-group').remove();\n      const dotGroups = allDotGroups\n        .selectAll('g.dot-group')\n        .data([...dataKeys])\n        .enter()\n        .append('g')\n        .attr('class', 'dot-group')\n        .attr('opacity', 0);\n      dotGroups\n        .append('circle')\n        .attr('cx', 0)\n        .attr('cy', 0)\n        .attr('r', 5)\n        .attr('fill', d => (data[d] && data[d].color) || 'black');\n      dotGroups\n        .append('text')\n        .style('text-anchor', 'middle')\n        .style('font-weight', 'bold')\n        .style('paint-order', 'stroke')\n        .attr('y', '-5px')\n        .attr('fill', d => (data[d] && data[d].color) || 'black')\n        .attr('stroke', 'rgba(255, 255, 255, 0.5)')\n        .attr('stroke-width', 5)\n        .attr('filter', textBackgroundURL);\n\n      // Set the dot over the x axis and the label highlighting the selected x value\n      xDot.selectAll('g').remove();\n      const actualXDot = xDot.append('g')\n        .attr('opacity', 0);\n      actualXDot\n        .append('circle')\n        .attr('cx', 0)\n        .attr('cy', 0)\n        .attr('r', 5)\n        .attr('fill', 'black');\n      actualXDot\n        .append('text')\n        .style('text-anchor', 'middle')\n        .style('font-weight', 'bold')\n        .style('paint-order', 'stroke')\n        .attr('y', '-5px')\n        .attr('fill', 'black')\n        .attr('stroke', 'rgba(255, 255, 255, 0.5)')\n        .attr('stroke-width', 5)\n        .attr('filter', textBackgroundURL);\n\n      // mouse move handler\n      graph.on('mousemove', (_, index, nodes) => {\n        // 'nodes' contain the mouse position data\n        // 'index' is apparently always 0\n        const [xValue] = mouse(nodes[index]);\n        // Get the closest x axis index to the current mouse position\n        const closestIndex =\n          Math.round(x.invert(xValue) / zoomPrecision / step) * zoomPrecision;\n        // If the closest index is out of range then there is no tooltip to show\n        if (closestIndex < xMin || closestIndex > xMax) return;\n        // Track the implicit position of all hovering dots\n        // This is useful to know if dot texts would overlap\n        const dotDownOffsets = {};\n        allDotGroups\n          // Set the x position of the dot\n          .attr('transform', `translate(${x(closestIndex * step)}, 0)`)\n          // Dots become invisible if the closest index is not between the minimum and the maximum\n          .attr(\n            'opacity',\n            closestIndex * step >= xMin && closestIndex * step < xMax ? 1 : 0,\n          );\n        allDotGroups\n          .selectAll('g.dot-group')\n          // Set the y position of the dot\n          .attr('transform', d => {\n            if (!labels[d]) return;\n            // Just over the correspondong line for other values\n            const offsetDown = (y(data[d].data[closestIndex]) || 0) + 2.5;\n            // Record the current offset down\n            dotDownOffsets[d] = offsetDown;\n            return `translate(0, ${offsetDown})`;\n          })\n          .attr('opacity', d => (d === 'x' || labels[d] ? 1 : 0))\n          .selectAll('text')\n          .attr('transform', d => {\n            if (!labels[d]) return;\n            // Find if an offset is too close to others and then move it to a better place (above)\n            let dotDownOffset = dotDownOffsets[d];\n            let extra = 0;\n            // Sort other offsets from more (below) to less (above)\n            const sortedOffsets = [];\n            for (const [key, value] of Object.entries(dotDownOffsets)) {\n              if (key !== d) sortedOffsets.push(value);\n            }\n            sortedOffsets.sort((a, b) => b - a);\n            // For each other offset, check if we are closer to it than the margin\n            // If so, we move our offset over the other as much as the margin needs\n            for (const offset of sortedOffsets) {\n              const difference = Math.abs(dotDownOffset + extra - offset);\n              if (difference > HOVER_TEXT_SEPARATION - 1) continue;\n              extra = offset - HOVER_TEXT_SEPARATION - dotDownOffset;\n            }\n            // In case the new offset is over the top limit we must relocate it below\n            if (dotDownOffset + extra < offset.top) {\n              extra = offset.top - dotDownOffset;\n              sortedOffsets.sort((a, b) => a - b);\n              // For each other offset, check if we are closer to it than the margin\n              // If so, we move our offset below the other as much as the margin needs\n              for (const offset of sortedOffsets) {\n                const difference = Math.abs(dotDownOffset + extra - offset);\n                if (difference > HOVER_TEXT_SEPARATION - 1) continue;\n                extra = offset + HOVER_TEXT_SEPARATION - dotDownOffset;\n              }\n            }\n            dotDownOffsets[d] = dotDownOffset + extra;\n            // Add the offset + a small margin\n            return `translate(0, ${extra - 3})`;\n          })\n          // Set the dot text in the x axis\n          .text(d => Math.round(data[d].data[closestIndex] * 100) / 100);\n        xDot\n          // Set the x position of the dot\n          .attr('transform', `translate(${x(closestIndex * step)}, 0)`)\n          // Dots become invisible if the closest index is not between the minimum and the maximum\n          .attr('opacity', closestIndex * step >= xMin && closestIndex * step < xMax ? 1 : 0);\n        actualXDot\n          // Set the y position of the dot\n          .attr('transform', `translate(0, ${height - offset.bottom})`)\n          .attr('opacity', 1)\n          .selectAll('text')\n          // Set the y position of the text under the dot\n          // This text size is similar to graph labels size so this is good enough\n          .attr('transform', `translate(0, ${labelsHeight})`)\n          // Set the dot text in the x axis\n          .text(() => {\n            const number = closestIndex * step * xScaleFactor;\n            if (number < 0) return;\n            return xTooltip && xTooltip(number, closestIndex);\n          });\n\n        if (onHover) {\n          onHover(\n            closestIndex * step >= xMin && closestIndex * step < xMax\n              ? closestIndex\n              : null,\n          );\n        }\n      });\n      // When click in the graph\n      onSelectRef.current({ onSelect });\n\n      graph.on('mouseout', () => {\n        allDotGroups.selectAll('g.dot-group').attr('opacity', 0);\n        actualXDot.attr('opacity', 0);\n        if (onHover) onHover(null);\n      });\n\n      // Save current values for further reference\n      previousValues.current.data = data;\n      previousValues.current.labels = labels;\n      previousValues.current.xAxisLabel = xAxisLabel;\n      previousValues.current.yAxisLabel = yAxisLabel;\n      previousValues.current.currentZoom = currentZoom;\n      previousValues.current.offset = offset;\n      previousValues.current.labelsHeight = labelsHeight;\n      previousValues.current.requiredBottomOffset = requiredBottomOffset;\n      previousValues.current.yAxisLabelHegiht = yAxisLabelHegiht;\n      previousValues.current.xColors = xColors;\n      previousValues.current.xNormalizedWeights = xNormalizedWeights;\n      previousValues.current.xTooltip = xTooltip;\n    };\n\n    onSelectRef.current = ({ onSelect } = {}) => {\n      // Get some reference values\n      const x = previousValues.current.x;\n      const precision = previousValues.current.precision;\n      const step = previousValues.current.step;\n      const xMin = previousValues.current.xMin;\n      const xMax = previousValues.current.xMax;\n      const xAxisValues = previousValues.current.xAxisValues;\n      // In case we dont have the previous values yet we stop here\n      if (x === undefined) return;\n      // If there is no 'onSelect' function then return here\n      if (!onSelect) return;\n      // When click in the graph\n      graph.on('click', (_, index, nodes) => {\n        const [xValue] = mouse(nodes[index]);\n        // Get the closest x axis index to the current mouse position\n        const closestIndex =\n          Math.round(x.invert(xValue) / precision / step) * precision;\n        if (closestIndex * step < xMin || closestIndex * step >= xMax) {\n          return;\n        }\n        onSelect(closestIndex, xAxisValues ? xAxisValues[closestIndex] : null);\n      });\n      // Update previous refs\n      previousValues.current.onSelect = onSelect;\n      previousValues.current.precision = precision;\n    };\n\n    // Place marks in the graph\n    marksRef.current = ({ marks } = {}) => {\n      // Get some reference values\n      const x = previousValues.current.x;\n      const xUnitWidth = previousValues.current.xUnitWidth;\n      const step = previousValues.current.step;\n      // In case we dont have all the arguments yet we stop here\n      if (x === undefined) return;\n      // Remove previous marks\n      if (previousValues.current.marks)\n        previousValues.current.marks.forEach(prevMark =>\n          marksNode.select('#mark' + prevMark.x).remove(),\n        );\n      // If there are no new marks then return here\n      if (!marks) return;\n      // Add a vertical band for each mark\n      marks.forEach(mark => {\n        const markRect = marksNode\n          .append('rect')\n          .attr('id', 'mark' + mark.x)\n          .attr('x', () =>\n            Number.isInteger(mark.x) ? x(mark.x * step) - xUnitWidth / 2 : 0,\n          )\n          .attr('y', 0)\n          .attr('height', '100%')\n          .attr('width', () => xUnitWidth);\n        if (mark.attr)\n          Object.entries(mark.attr).forEach(([key, value]) => {\n            markRect.attr(key, value);\n          });\n        if (mark.style)\n          Object.entries(mark.style).forEach(([key, value]) => {\n            markRect.style(key, value);\n          });\n      });\n      // Update previous refs\n      previousValues.current.marks = marks;\n    };\n\n    hoveredRef.current = ({ hovered } = {}) => {\n      // Get some reference values\n      const linesData = previousValues.current.linesData;\n      // Change the whole dataset line stroke width\n      linesData\n        .transition()\n        .attr('stroke-width', d => (hovered === d ? 3 : 1.5));\n      // Update previous refs\n      previousValues.current.hovered = hovered;\n    };\n\n    window.addEventListener('resize', drawRef.current);\n\n    return () => window.removeEventListener('resize', drawRef.current);\n  }, []); // DANI: eslint ahora se queja, peor antes aquí había esto: // eslint-disable-line react-hooks/exhaustive-deps\n  // Maybe might need to double-check that and remove the exception\n\n  // Handle when the 'onSelect' function changes\n  useEffect(() => {\n    onSelectRef.current({ onSelect });\n  }, [onSelect]);\n\n  // Handle when marks change\n  useEffect(() => {\n    marksRef.current({ marks });\n  }, [marks]);\n\n  // Handle when some parameter change requires a whole re-draw of the graph\n  useEffect(() => {\n    drawRef.current({\n      data: yData,\n      step,\n      xAxisLabel,\n      yAxisLabel,\n      xAxisValues,\n      labels: lab,\n      offset,\n      labelsHeight,\n      requiredBottomOffset,\n      yAxisLabelHegiht,\n      xColors,\n      xTooltip,\n    });\n  }, [\n    yData,\n    step,\n    xAxisLabel,\n    yAxisLabel,\n    xAxisValues,\n    lab,\n    offset,\n    labelsHeight,\n    requiredBottomOffset,\n    yAxisLabelHegiht,\n    xColors,\n    xTooltip,\n  ]);\n\n  // Handle when weights change apart, since they must be normalized\n  useEffect(() => {\n    // Normalize xWeigths, when passed, so that the minimum values are 1\n    if (!xWeights) return;\n    // Check weights and data to match in the number of values\n    const expectedCount = xWeights.length;\n    Object.values(yData).forEach(value => {\n      const currentCount = value.data.length;\n      if (currentCount !== expectedCount)\n        throw new Error(\n          `Graph data values count (${currentCount}) does not match the weigths values count (${expectedCount})`,\n        );\n    });\n    // Find the minimum and maximum values in the weights array\n    // NEVER FORGET: do not use Math.min and Math.max for long arrays\n    const minimum = xWeights.reduce((cv, nv) => {\n      return Math.min(cv, nv);\n    }, Infinity);\n    const maximum = xWeights.reduce((cv, nv) => {\n      return Math.max(cv, nv);\n    }, -Infinity);\n    // Set the normalized minimum and maximum radius values\n    // This in the graph is equivalent to 'times the default area'\n    const normalizedMinimum = 1;\n    const normalizedMaximum = 10;\n    // Set a function to interpolate values\n    const normalizer =\n      (normalizedMaximum - normalizedMinimum) / (maximum - minimum);\n    const interpolate = weight =>\n      normalizedMinimum + (weight - minimum) * normalizer;\n    // Recalculate weights using the minimum values (equal to 1) as reference\n    const xNormalizedWeights = xWeights.map(weight => interpolate(weight));\n    drawRef.current({ xNormalizedWeights });\n  }, [xWeights, yData]);\n\n  // Handle when user clicks on legend checkboxes\n  const handleChange = useCallback(\n    ({\n      target: {\n        dataset: { key },\n      },\n    }) => {\n      if (!key) return;\n      if (!setLab) return;\n      setLab(previous => {\n        const nextLabels = { ...previous, [key]: !previous[key] };\n        // Check if any value is true before returning the labels\n        // This way, the user can not uncheck the last active checkbox\n        if (Object.values(nextLabels).some(Boolean)) return nextLabels;\n        // If all of the values would be false, keep the previous\n        return previous;\n      });\n    },\n    [setLab],\n  );\n\n  const handleMouseOver = useCallback(\n    ({\n      target: {\n        dataset: { key },\n      },\n    }) => {\n      if (!key || !lab[key] || isCanvasPowered(type)) return;\n      hoveredRef.current({ hovered: key });\n    },\n    [lab, type],\n  );\n\n  const handleMouseOut = useCallback(\n    ({\n      target: {\n        dataset: { key },\n      },\n    }) => {\n      if (!key || !lab[key] || isCanvasPowered(type)) return;\n      hoveredRef.current({ hovered: null });\n    },\n    [lab, type],\n  );\n\n  // Expose public methods and getters/setters\n  useImperativeHandle(\n    ref,\n    () => ({\n      set marks(value) {\n        marksRef.current({ marks: value });\n      },\n    }),\n    [],\n  );\n\n  return (\n    <div className={className ? className : style.default}>\n      <div className={style.flexible}>\n        <div className={style['graph-container']} ref={containerRef} />\n        {selfLegend && (\n          <div className={style['graph-legend']}>\n            {yEntries.map(([key]) => (\n              <FormControlLabel\n                data-key={key}\n                key={key}\n                onChange={handleChange}\n                onMouseOver={handleMouseOver}\n                onMouseOut={handleMouseOut}\n                control={\n                  <Checkbox\n                    checked={lab[key]}\n                    style={{ color: yData[key].color || 'black' }}\n                    inputProps={{ 'data-key': key }}\n                  />\n                }\n                label={NICE_NAMES.get(key) || key}\n              />\n            ))}\n          </div>\n        )}\n        {displayLegend && (\n          <div className={style['graph-display-legend']}>\n            {yEntries.map(([key, dataset], i) => {\n              if (lab[key] === false) return null;\n              return (\n                <div key={key} className={style['line-sample']}>\n                  {key}\n                  <LineSample color={dataset.color} dash={dataset.dash} />\n                </div>\n              );\n            })}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n});\n\nexport default Graph;\n","// Function involved in getting text pixels width\n// WARNING: These functions do not work properly in Chrome (not an easy problem)\n\n// This function allows to calculate the width of a given string text\n// The font for the calculation in the d3 default font\nexport const getTextWidth = (text, font = 'bold 10px sans-serif') => {\n  const canvas =\n    getTextWidth.canvas ||\n    (getTextWidth.canvas = document.createElement('canvas'));\n  const context = canvas.getContext('2d');\n  context.font = font;\n  const metrics = context.measureText(text);\n  return metrics.width;\n};\n\n// Alternative way to obtain text width\n// Probably the only way to obtain text height\nexport const getTextSizeDOM = (text, font = 'bold 10px sans-serif') => {\n  const element = document.createElement('div');\n  const content = document.createTextNode(text);\n  element.appendChild(content);\n  Object.assign(element.style, {\n    font: font,\n    position: 'absolute',\n    visibility: 'hidden',\n    height: 'auto',\n    width: 'auto',\n    'white-space': 'nowrap',\n  });\n  document.body.appendChild(element);\n  return { width: element.clientWidth, height: element.clientHeight };\n};\n\n// Get the whole body width\nexport const getBodyWidth = () => {\n  return Math.max(\n    document.body.scrollWidth,\n    document.documentElement.scrollWidth,\n    document.body.offsetWidth,\n    document.documentElement.offsetWidth,\n    document.documentElement.clientWidth,\n  );\n};\n\n// Get the whole body height\nexport const getBodyHeight = () => {\n  return Math.max(\n    document.body.scrollHeight,\n    document.documentElement.scrollHeight,\n    document.body.offsetHeight,\n    document.documentElement.offsetHeight,\n    document.documentElement.clientHeight,\n  );\n};\n"],"names":["symbolProto","Symbol","prototype","undefined","symbolToString","toString","baseToString","value","isArray","arrayMap","isSymbol","call","result","spreadableSymbol","isConcatSpreadable","isArguments","baseFlatten","array","depth","predicate","isStrict","index","length","isFlattenable","arrayPush","iteratee","Array","getMean","data","reduce","pv","cv","getMeanAndStdv","sum","n","mean","stdv","Math","sqrt","map","x","pow","a","b","createSvgIcon","_jsx","d","getCheckboxUtilityClass","slot","generateUtilityClass","generateUtilityClasses","_excluded","CheckboxRoot","styled","SwitchBase","shouldForwardProp","prop","rootShouldForwardProp","name","overridesResolver","props","styles","ownerState","root","indeterminate","capitalize","size","color","_ref","theme","_extends","vars","palette","text","secondary","disableRipple","backgroundColor","action","activeChannel","mainChannel","hoverOpacity","alpha","active","main","checkboxClasses","checked","disabled","defaultCheckedIcon","CheckBoxIcon","defaultIcon","CheckBoxOutlineBlankIcon","defaultIndeterminateIcon","IndeterminateCheckBoxIcon","React","inProps","ref","_icon$props$fontSize","_indeterminateIcon$pr","useDefaultProps","checkedIcon","icon","iconProp","indeterminateIcon","indeterminateIconProp","inputProps","className","other","_objectWithoutPropertiesLoose","classes","slots","composedClasses","composeClasses","useUtilityClasses","type","fontSize","clsx","idCounter","prefix","id","defs","uniqueId","filter","append","attr","idStart","idEnd","startMaskGradient","style","endMaskGradient","dash","containerRef","useRef","useEffect","graph","select","current","DEFAULT_DOT_AREA","DEFAULT_DOT_RADIUS","PI","dPR","window","devicePixelRatio","defaultD3font","titlesD3font","yDataPlaceholder","placeholder","defaultMargins","top","right","bottom","left","steppedMax","values","max","Number","NEGATIVE_INFINITY","forEach","trueEntries","keys","object","key","isCanvasPowered","Graph","forwardRef","yData","xAxisValues","step","title","xAxisLabel","yAxisLabel","xScaleFactor","xColors","xWeights","xTooltip","onHover","onSelect","selfLegend","displayLegend","dataDisplay","setDataDisplay","standardDeviation","margin","flippedXAxisValues","fullPrecision","marks","densityStdDev","Object","drawRef","noop","onSelectRef","marksRef","hoveredRef","yEntries","yKeys","useMemo","entries","_ref2","offset","labelsHeight","requiredBottomOffset","yAxisLabelHegiht","yAxisValues","_ref3","dataset","nv","concat","v","round","textHeight","getTextSizeDOM","height","maxXAxisWidth","label","getTextWidth","maxYAxisWidth","xAxisLabelHegiht","requiredTopOffset","requiredLeftOffset","internalDataDisplay","setInternalDataDisplay","useState","lab","setLab","previousValues","labels","currentZoom","k","rescaleX","scale","canvas","canvasContext","node","getContext","textBackgroundURL","addTextBackground","startMaskURL","endMaskURL","addMasks","marksNode","allDotGroups","maskEnd","axes","y","xDot","xNormalizedWeights","arguments","clientWidth","width","clientHeight","dataEntries","dataKeys","_ref4","maxZoomExtent","precisionScale","scaleLog","range","ceil","domain","graphZoom","zoom","scaleExtent","on","event","preventDefault","transform","zoomPrecision","floor","log2","getZoomPrecision","min","precision","bind","bodyWidth","bodyHeight","remove","xMax","xMin","scaleLinear","g","axisBottom","ticks","tickFormat","extent","flatten","_ref5","_ref6","nice","transition","axisLeft","meanLines","selectAll","enter","merge","exit","stddev","sdRects","areaGenerator","area","y0","y1","sdAreas","points","_","i","minIndex","invert","maxIndex","lineFn","line","defined","linesData","dashWidth","dashHeight","startAngle","endAngle","clearRect","fillStyle","maxInView","atomColor","fillRect","xPosition","yPosition","radius","weight","beginPath","arc","fill","xUnitWidth","dotGroups","actualXDot","nodes","xValue","mouse","closestIndex","dotDownOffsets","offsetDown","dotDownOffset","extra","sortedOffsets","push","sort","abs","HOVER_TEXT_SEPARATION","number","prevMark","mark","markRect","isInteger","_ref7","_ref8","hovered","addEventListener","removeEventListener","expectedCount","currentCount","Error","minimum","Infinity","maximum","normalizer","interpolate","handleChange","useCallback","_ref9","target","previous","nextLabels","some","Boolean","handleMouseOver","_ref10","handleMouseOut","_ref11","useImperativeHandle","children","_jsxs","_ref12","FormControlLabel","onChange","onMouseOver","onMouseOut","control","Checkbox","NICE_NAMES","get","_ref13","LineSample","font","context","document","createElement","measureText","element","content","createTextNode","appendChild","assign","position","visibility","body"],"sourceRoot":""}