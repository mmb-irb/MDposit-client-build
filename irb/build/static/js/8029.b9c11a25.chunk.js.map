{"version":3,"file":"static/js/8029.b9c11a25.chunk.js","mappings":"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","sources":["utils/load-custom-element/index.js","pages/accession/trajectory/chains/chain-analysis/index.js","utils/hash-from-string/index.js","utils/color-from-string/index.js","utils/merge-intervals/index.js","pages/accession/trajectory/chains/chain-analysis/process-ipscan-results/index.js","webpack://mdposit/./src/pages/accession/trajectory/chains/chain-analysis/style.module.css?b840"],"sourcesContent":["const loadCustomElement = importer => ({\n  async as(namespace) {\n    let _namespace = namespace;\n    // load custom element script\n    let customElement = await importer();\n    if (customElement.default) customElement = customElement.default;\n    // if no name was specified, use default provided by the custom element\n    if (\n      !_namespace &&\n      customElement.is &&\n      typeof customElement.is === 'string'\n    ) {\n      _namespace = customElement.is;\n    }\n    // if we get to this point without any name, just give up\n    if (!_namespace) {\n      throw new Error('Please a specify a name for custom element');\n    }\n    // check if not already defined\n    const alreadyExisting = window.customElements.get(_namespace);\n    if (alreadyExisting) {\n      // if it was, with the same element, everything is fine\n      if (alreadyExisting === customElement) return _namespace;\n      throw new Error('This name is already used by another component');\n    }\n    window.customElements.define(_namespace, customElement);\n    return _namespace;\n  },\n});\n\nexport default loadCustomElement;\n","import React, { memo, useEffect, useRef } from 'react';\n\nimport loadCustomElement from '../../../../../utils/load-custom-element';\n\nimport processIPScanResults from './process-ipscan-results';\n\nimport style from './style.module.css';\n\n// Keep elements out of any component, since they must be imported just once\nlet customElements = [];\n// This promise is further resolven when all protvista elements have finished the import process\nlet protvistaLoadedResolve;\nconst protvistaLoaded = new Promise(resolve => { protvistaLoadedResolve = resolve });\n\n// Load all protvista components together in a 'custom' way for them to work\nconst importProtVista = async () => {\n  if (customElements.length > 0) return;\n  customElements = [\n        // WARNING: We must make sure the manager is imported before the others\n        // Otherwise we get many errors of 'this.manager.register is not a function'\n        // The rest of components may be imported in any order\n        await loadCustomElement(() => import(\n            /* webpackChunkName: \"protvista-manager\" */ 'protvista-manager'),\n        ).as('protvista-manager'),\n        loadCustomElement(() => import(\n            /* webpackChunkName: \"protvista-sequence\" */ 'protvista-sequence'\n        )).as('protvista-sequence'),\n        loadCustomElement(() => import(\n            /* webpackChunkName: \"protvista-navigation\" */ 'protvista-navigation'\n        )).as('protvista-navigation'),\n        loadCustomElement(() => import(\n            /* webpackChunkName: \"protvista-coloured-sequence\" */ 'protvista-coloured-sequence'\n        )).as('protvista-coloured-sequence'),\n        loadCustomElement(() => import(\n            /* webpackChunkName: \"protvista-coloured-sequence\" */ 'protvista-coloured-sequence'\n        )).as('protvista-coloured-sequence'),\n        loadCustomElement(() => import(\n            /* webpackChunkName: \"protvista-interpro-track\" */ 'protvista-interpro-track'\n        )).as('protvista-interpro-track')\n  ];\n  // Wait until all protvista elements are loaded and then resolve the promise\n  await Promise.all(customElements);\n  protvistaLoadedResolve();\n};\n\n// Set the protvista interpro track independently, since it needs to keep its own reference\nconst InterproTrack = memo(({ match, length, shape, classAttr }) => {\n    // Set a reference to the protvista element\n    const protvistaRef = useRef();\n    // Update protvista element data after render\n    useEffect(() => {\n        const fillComponentWithData = async () => {\n            // Make sure the element has been imported already or it wont work\n            await protvistaLoaded;\n            // Load data in the reference\n            protvistaRef.current.data = [match];\n            protvistaRef.current.contributors = match.signatures || [];\n        }\n        fillComponentWithData();\n    }, []);\n    // Render the element\n    return (\n        <protvista-interpro-track\n            ref={protvistaRef}\n            length={length}\n            shape={shape}\n            class={classAttr}\n        />\n    );\n});\n\n// The result of this function is memoized since it is a heavy work\nconst ChainAnalyses = memo(({ data, firstResidueNumber }) => {\n    // Get the chain letter\n    const chain = data.name;\n    // Import protvista elements in their 'custom' way\n    useEffect(() => {\n        importProtVista();\n    }, []);\n    // Mine data\n    const sequence = data.sequence;\n    const sequenceLength = sequence.length;\n    const interproscanData = data.interproscan;\n    // It may happen that interproscan data is missing when we have a small sequence\n    if (!interproscanData) return 'No InterProScan data';\n    const matches = interproscanData.results[0].matches;\n    const processedMatches = processIPScanResults(matches, firstResidueNumber);\n    // Set the end residue to be displayed\n    const displayEnd = firstResidueNumber + sequenceLength;\n    // Set an shifted sequence by adding null values at the begining\n    // This is the only way I figured out to offset the sequence\n    // Apparently protvista sequence components have no argument for this\n    const shiftedSequence = ' '.repeat(firstResidueNumber) + sequence;\n    return (\n        <protvista-manager\n            attributes=\"length displaystart displayend\"\n            length={sequenceLength}\n            chain={chain}\n        >\n        <protvista-navigation\n            rulerstart={firstResidueNumber}\n            displaystart={firstResidueNumber}\n            displayend={displayEnd}\n        />\n        <div className={style.entries}>\n            <protvista-sequence\n                sequence={shiftedSequence}\n                height=\"37\"\n            />\n            <protvista-coloured-sequence\n                sequence={shiftedSequence}\n                scale=\"hydrophobicity-scale\"\n                height=\"15\"\n            />\n            { processedMatches.length\n            ? processedMatches.map((match, index) => {\n                return (\n                <div key={index} >\n                    <span className={style.label}>{match.accession}</span>\n                    <InterproTrack\n                    match={match}\n                    shape=\"roundRectangle\"\n                    classAttr={match.signatures ? style['has-signatures'] : undefined}\n                    />\n                </div>\n                )})\n            : 'No entry was found for this sequence'\n            }\n        </div>\n        </protvista-manager>\n    );\n});\n\nexport default ChainAnalyses;\n","const hashFromString = string => {\n  let hash = 0;\n  for (let i = 0; i < string.length; i++) {\n    hash = (hash << 5) - hash + string.charCodeAt(i);\n    hash |= 0;\n  }\n  return hash;\n};\n\nexport default hashFromString;\n","import hashFromString from '../hash-from-string';\n\nconst colorFromString = string => {\n  const hash = hashFromString(string);\n  const hue = Math.abs(hash % 360);\n  const saturation = Math.abs(hash % 20) + 40; // 50% give or take 10%\n  const lightness = Math.abs(hash % 10) + 45; // 50% give or take 5%\n  return `hsla(${hue}, ${saturation}%, ${lightness}%, 1)`;\n};\n\nexport default colorFromString;\n","const startAccessorDefault = (interval, value) =>\n  Number.isFinite(value) ? (interval[0] = value) : interval[0];\nconst endAccessorDefault = (interval, value) =>\n  Number.isFinite(value) ? (interval[1] = value) : interval[1];\n\nconst mergeIntervals = (\n  intervals,\n  startAccessor = startAccessorDefault,\n  endAccessor = endAccessorDefault,\n) => {\n  const sortedIntervals = Array.from(intervals).sort(\n    (a, b) => startAccessor(a) - startAccessor(b),\n  );\n  let output = [];\n  let current;\n  for (const interval of sortedIntervals) {\n    if (!current) {\n      // first loop\n      current = interval;\n    } else if (endAccessor(current) < startAccessor(interval)) {\n      // current is not within interval\n      output.push(current);\n      current = interval;\n    } else {\n      // current is within, or contiguous to interval\n      endAccessor(\n        current,\n        Math.max(endAccessor(current), endAccessor(interval)),\n      );\n    }\n  }\n  if (current) output.push(current);\n  return output;\n};\n\nexport default mergeIntervals;\n","import colorFromString from '../../../../../../utils/color-from-string';\nimport mergeIntervals from '../../../../../../utils/merge-intervals';\n\n// Renumerate residue numbers to make them match the actual chain they come from\nconst shiftLocations = (fragments, shift) => {\n  fragments.forEach(fragment => {\n    fragment.start += shift -1;\n    fragment.end += shift -1;\n  })\n  return fragments;\n}\n\nconst processLocations = (locations, firstResidueNumber = 1) =>\n  locations.map(location => ({\n    fragments: shiftLocations(location['location-fragments'], firstResidueNumber),\n  }));\n\nconst processIPScanResults = (matches, firstResidueNumber) => {\n  const processed = [];\n  // for all the matches\n  for (const match of matches || []) {\n    // if the match has an entry, consider it as a signature of the entry\n    if (match.signature.entry) {\n      let existing = processed.find(\n        m => m.accession === match.signature.entry.accession,\n      );\n      // if the entry hadn't been stored yet, create it now\n      if (!existing) {\n        existing = {\n          accession: match.signature.entry.accession,\n          db: 'InterPro',\n          signatures: [],\n          locations: [],\n          color: colorFromString(match.signature.entry.accession),\n        };\n        processed.push(existing);\n      }\n      const locations = processLocations(match.locations, firstResidueNumber);\n      existing.locations = mergeIntervals(\n        [...existing.locations, ...locations],\n        (interval, value) =>\n          Number.isFinite(value)\n            ? (interval.fragments[0].start = value)\n            : interval.fragments[0].start,\n        (interval, value) =>\n          Number.isFinite(value)\n            ? (interval.fragments[0].end = value)\n            : interval.fragments[0].end,\n      );\n      // add the match as a signature of that entry\n      existing.signatures.push({\n        accession: match.signature.accession,\n        db: match.signature.signatureLibraryRelease.library,\n        locations,\n        color: existing.color.replace(', 1)', ', 0.25)'),\n      });\n    } else {\n      // the match doesn't have entry, it is not integrated\n      processed.push({\n        accession: match.signature.accession,\n        db: match.signature.signatureLibraryRelease.library,\n        locations: processLocations(match.locations, firstResidueNumber),\n        color: colorFromString(match['model-ac']),\n      });\n    }\n  }\n\n  // sort them\n  processed\n    // secondary sort by start position\n    .sort((a, b) => a.locations[0].fragments[0].start - b.locations[0].fragments[0].start)\n    // primary sort by number of signatures\n    .sort((a, b) => (b.signatures || []).length - (a.signatures || []).length);\n\n  return processed;\n};\n\nexport default processIPScanResults;\n","// extracted by mini-css-extract-plugin\nexport default {\"entries\":\"style_entries__T4f7r\",\"has-signatures\":\"style_has-signatures__4CW-U\",\"label\":\"style_label__UT0BE\"};"],"names":["importer","as","namespace","_namespace","customElement","default","is","Error","alreadyExisting","window","customElements","get","define","protvistaLoadedResolve","protvistaLoaded","Promise","resolve","InterproTrack","memo","_ref","match","length","shape","classAttr","protvistaRef","useRef","useEffect","async","current","data","contributors","signatures","fillComponentWithData","_jsx","ref","class","_ref2","firstResidueNumber","chain","name","loadCustomElement","all","importProtVista","sequence","sequenceLength","interproscanData","interproscan","matches","results","processedMatches","processIPScanResults","displayEnd","shiftedSequence","repeat","_jsxs","attributes","children","rulerstart","displaystart","displayend","className","style","entries","height","scale","map","index","label","accession","undefined","string","hash","i","charCodeAt","hashFromString","hue","Math","abs","saturation","lightness","concat","startAccessorDefault","interval","value","Number","isFinite","endAccessorDefault","intervals","startAccessor","arguments","endAccessor","sortedIntervals","Array","from","sort","a","b","output","push","max","processLocations","locations","location","fragments","shift","forEach","fragment","start","end","shiftLocations","processed","signature","entry","existing","find","m","db","color","colorFromString","mergeIntervals","signatureLibraryRelease","library","replace"],"sourceRoot":""}