{"version":3,"file":"static/js/graph-msm.614f3f6e.chunk.js","mappings":"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","sources":["webpack://mdposit/./src/components/graph-msm/style.module.css?d15e","components/graph-msm/index.js","../node_modules/lodash-es/noop.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"default\":\"style_default__5Q58A\",\"flexible\":\"style_flexible__YWXe-\",\"graph-container\":\"style_graph-container__X1--T\"};","import React, {\n  useRef,\n  useEffect,\n  forwardRef,\n} from 'react';\nimport { noop } from 'lodash-es';\nimport {\n  select,\n  forceSimulation,\n  forceLink,\n  forceManyBody,\n  forceCollide,\n  forceX,\n  forceY,\n} from 'd3';\n\nimport style from './style.module.css';\n\nimport imagePlaceholder from '../../images/random_molecule.png';\n\nconst dataPlaceholder = { nodes: [], links: [] };\n\n// Set display colors\nconst colors = {\n  default: \"black\",\n  hovered: \"blue\",\n  selected: \"green\"\n}\nconst strokeWidths = {\n  default: 2,\n  hovered: 3,\n  selected: 4\n}\n\n// This graph has been done by adapting the example from https://d3-graph-gallery.com/graph/network_basic.html\n\n// The expected input data is:\n// {\n//    nodes: [\n//      {\n//        // Index from 0 to n\n//        id: 0,\n//        // Circle radius to be drawn to represent this node\n//        radius: 17,\n//        // Value to be returned on select\n//        value: 123\n//      },\n//      ...\n//    ],\n//    links: [\n//      {\n//        // One of the nodes\n//        source: 0,\n//        // The other node\n//        target: 1,\n//        // Line width to be drawn to represent this link\n//        width: 3\n//      },\n//      ...\n//    ]\n// }\n\nconst MarkovGraph = forwardRef(({\n  // Data containing both nodes and links\n  data,\n  // Images to be drawn over nodes\n  images,\n  // Set a list of currently selected node\n  selectedNodeValue,\n  // Triggers for when the user selects a nodes\n  onSelectNode,\n  // Force a classname for the overall component element\n  className,\n}, ref) => {\n  // Set a fake dataset to allow the graph to work when no data is passed\n  if (!data) data = dataPlaceholder;\n\n  // Referenced document element where d3 is rendered\n  const containerRef = useRef(null);\n  // Referenced function which allows to update the cart without having to remake it\n  const updateDataRef = useRef(noop);\n  const updateImagesRef = useRef(noop);\n  const updateSelectedNodeValueRef = useRef(noop);\n  const updateOnSelectRef = useRef(noop);\n  const updateSizeRef = useRef(noop);\n\n  // ----------------------------------------------------------------------------------------\n\n  // This useEffect must be run only once\n  // The graph content is updated through the referenced functions\n  useEffect(() => {\n    // Set the graph main handlers\n    const graph = select(containerRef.current).append('svg');\n    const defs = graph.append('svg:defs');\n\n    // Set two 'g' elements for nodes and links to be attached to them instead of to the graph element itself\n    // Then declare links before nodes to ensure nodes will be drawn over links in the 'z' dimension and not the opposite\n    const linksParent = graph.append(\"g\")\n    const nodesParent = graph.append(\"g\")\n\n    // Initiate the forces handler\n    // This runs the logic which sets the nodes positions\n    const simulation = forceSimulation();\n\n    // --------------------------------------------------------------------------------------------------\n\n    // Set the updating functions\n    // These functions are called by specific useEffects declared below when an specific input changes\n\n    // Set a function to update data changes\n    updateDataRef.current = ({ data }) => {\n      // Get data nodes and links\n      let { nodes: dataNodes, links: dataLinks } = data;\n\n      // Set the links ------------------------------------------------------------------------------------\n\n      // Get the current link lines\n      let linkLines = linksParent.selectAll(\"line\");\n\n      // Copy input data instead to prevent further mutation\n      dataLinks = dataLinks.map(d => Object.assign({}, d));\n\n      // Load new data in the link lines\n      const newLinkLinesData = linkLines.data(dataLinks);\n\n      // Remove link lines which are no longer necessary according to new data\n      newLinkLinesData.exit().remove();\n\n      // Add new link lines which are now necessary according to new data\n      newLinkLinesData.enter().append(\"line\")\n        .style(\"stroke\", \"#aaa\");\n\n      // Get all definitive link lines now that we have removed/added some link lines\n      linkLines = linksParent.selectAll(\"line\");\n\n      // Update definitive link lines according to new data\n      linkLines\n        .attr(\"stroke-width\", d => d.width);\n\n      // Set the nodes ------------------------------------------------------------------------------------\n\n      // Get all the already existing node circles\n      let nodeCircles = nodesParent.selectAll(\"circle\");\n\n      // Copy current data to recicle old node/link positions and velocities, so we do not start from 0 every time\n      // This results in a softer transition by avoiding the jump of all nodes and links to their original positions\n      // This was get from here https://observablehq.com/@d3/modifying-a-force-directed-graph\n      const backup = new Map(nodeCircles.data().map(d => [d.id, d]));\n      dataNodes = dataNodes.map(d => Object.assign(backup.get(d.id) || {}, d));\n\n      // Load new nodes data in node circles\n      const newNodeCirclesData = nodeCircles.data(dataNodes);\n\n      // Remove node circles which are no longer necessary according to new data\n      newNodeCirclesData.exit().remove();\n\n      // Add new circles which are now necessary according to new data\n      newNodeCirclesData.enter().append(\"circle\")\n        .style(\"fill\", \"#fff\") // Default color, but they are re-painted with the image below\n\n      // Get all definitive node circles now that we have removed/added some node circles\n      nodeCircles = nodesParent.selectAll(\"circle\");\n\n      // Update definitive node circles according to new data\n      nodeCircles\n        .attr(\"r\", d => d.radius)\n        .style(\"stroke\", d => selectedNodeValue === d.value ? colors.selected : colors.default)\n        .style(\"stroke-width\", d => selectedNodeValue === d.value ? strokeWidths.selected : strokeWidths.default)\n        .style(\"cursor\", onSelectNode && \"pointer\")\n        // WARNING: Here you need to use 'function' instead of an arrow function or 'this' does not work\n        .on(\"mouseover\", function() {\n          select(this)\n          .style(\"stroke\", colors.hovered)\n          .style(\"stroke-width\", strokeWidths.hovered);\n        })\n        .on(\"mouseout\", function() {\n          select(this)\n          .style(\"stroke\", d => selectedNodeValue === d.value ? colors.selected : colors.default)\n          .style(\"stroke-width\", d => selectedNodeValue === d.value ? strokeWidths.selected : strokeWidths.default)\n        })\n        .on(\"click\", onSelectNode)\n        .append(\"svg:title\")\n          .text(d => d.text);\n\n      // Set node images ------------------------------------------------------------------------------------\n\n      // Get the current node image patterns\n      let nodeImagePatterns = defs.selectAll(\"pattern\");\n\n      // Load new data in the node image patterns\n      const newNodeImagePatternData = nodeImagePatterns.data(dataNodes);\n\n      // Remove node image patterns which are no longer necessary according to new data\n      newNodeImagePatternData.exit().remove();\n\n      // Add new node image patterns which are now necessary according to new data\n      newNodeImagePatternData.enter().append('pattern')\n        .attr(\"patternUnits\", \"userSpaceOnUse\");\n\n      // Get all definitive node image patterns now that we have removed/added some node image patterns\n      nodeImagePatterns = defs.selectAll(\"pattern\");\n\n      // Update definitive node image patterns according to new data\n      nodeImagePatterns\n        .attr('id', d => 'img' + d.id)\n        .attr('width',  d => d.radius * 2)\n        .attr('height', d => d.radius * 2)\n        // Cleanup previous possible images since they will be re-appended rigth away\n        .selectAll(\"image\").remove();\n\n      const nodeImages = nodeImagePatterns.append(\"image\")\n        .attr('xlink:href', (d,i) => (images && images[i]) || imagePlaceholder)\n        .attr('width',  d => d.radius * 2)\n        .attr('height', d => d.radius * 2);\n\n      // Set a function to update when input images change\n      // DANI: No se ha provado\n      updateImagesRef.current = ({ images }) => {\n        nodeImages.attr('xlink:href', (d,i) => (images && images[i]) || imagePlaceholder);\n      }\n\n      // Now fill nodes with their corresponding images\n      nodeCircles\n        .style(\"fill\", d => `url(#img${d.id})`)\n\n      // Set the forces ------------------------------------------------------------------------------------\n\n      // Note that there is an additional force which is not data-dependent, but size-dependent\n      // This force is not set here but in the updateSizeRef function\n\n      simulation\n        .nodes(dataNodes)\n        // This force provides links between nodes\n        .force(\"link\", forceLink()\n          .strength(d => d.width * 0.01)\n          .id(d => d.id)\n          .links(dataLinks)\n        )\n        // This adds repulsion (negative force) between nodes\n        .force(\"charge\", forceManyBody().strength(d => d.radius * -20))\n        // Make sure there is a minimum margin between nodes so links are not eclipsed\n        .force('collision', forceCollide().radius(d => d.radius * 1.5))\n        // Link the position updating function to the forces\n        // It is important to run this line only in the first render\n        .on(\"tick\", () => {\n          linkLines\n            .attr(\"x1\", d => d.source.x)\n            .attr(\"y1\", d => d.source.y)\n            .attr(\"x2\", d => d.target.x)\n            .attr(\"y2\", d => d.target.y);\n          nodeCircles\n            .attr(\"cx\", d => d.x)\n            .attr(\"cy\", d => d.y);\n          nodeImagePatterns\n            .attr(\"x\", d => d.x + d.radius)\n            .attr(\"y\", d => d.y + d.radius);\n        });\n\n      // Restart forces in case they were stopped already\n      simulation.alpha(1).restart();\n    }\n\n    // Set a function to update the graph when the selected node value changes\n    updateSelectedNodeValueRef.current = ({ selectedNodeValue }) => {\n      nodesParent.selectAll(\"circle\")\n        .style(\"stroke\", d => selectedNodeValue === d.value ? colors.selected : colors.default)\n        .style(\"stroke-width\", d => selectedNodeValue === d.value ? strokeWidths.selected : strokeWidths.default)\n        .on(\"mouseover\", function() {\n          select(this)\n          .style(\"stroke\", colors.hovered)\n          .style(\"stroke-width\", strokeWidths.hovered);\n        })\n        .on(\"mouseout\", function() {\n          select(this)\n          .style(\"stroke\", d => selectedNodeValue === d.value ? colors.selected : colors.default)\n          .style(\"stroke-width\", d => selectedNodeValue === d.value ? strokeWidths.selected : strokeWidths.default)\n        })\n    }\n\n    // Set a function to update when onSelectNode changes\n    // DANI: No se ha provado\n    updateOnSelectRef.current = ({ onSelectNode }) => {\n      nodesParent.selectAll(\"circle\")\n        .style(\"cursor\", onSelectNode && \"pointer\")\n        .on(\"click\", onSelectNode);\n    }\n\n    // This ref allows to update the graph without having to remake the whole graph\n    updateSizeRef.current = () => {\n      // Change the graph size according to the container size\n      const { clientWidth: width, clientHeight: height } = containerRef.current;\n      graph.attr('width', width).attr('height', height);\n      // Update forces which depend on the graph size\n      simulation\n        .force(\"x\", forceX(width / 2).strength(100 / width))\n        .force(\"y\", forceY(height / 2).strength(100 / height))\n        .alpha(1).restart();\n    };\n\n    // Run the redraw logic fro the first time\n    updateSizeRef.current();\n    // Set the redraw logic to be run every time the graph container is resized\n    window.addEventListener('resize', updateSizeRef.current);\n\n    // Cleanup function\n    return () => {\n      graph.remove();\n      simulation.stop();\n      window.removeEventListener('resize', updateSizeRef.current);\n    }\n  }, []);\n\n  // Handle when images change\n  useEffect(() => {\n    updateDataRef.current({data});\n  }, [data]);\n\n  // Handle when images change\n  useEffect(() => {\n    updateImagesRef.current({images});\n  }, [images]);\n\n  // Handle when the selected node value changes\n  useEffect(() => {\n    updateSelectedNodeValueRef.current({selectedNodeValue});\n  }, [selectedNodeValue]);\n\n  // Handle when the on selected node changes\n  useEffect(() => {\n    updateOnSelectRef.current({onSelectNode});\n  }, [onSelectNode]);\n\n  return (\n    <div className={className ? className : style.default}>\n      <div className={style.flexible}>\n        <div className={style['graph-container']} ref={containerRef} />\n      </div>\n    </div>\n  );\n});\n\nexport default MarkovGraph;\n","/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nexport default noop;\n"],"names":["dataPlaceholder","nodes","links","colors","strokeWidths","forwardRef","_ref","ref","data","images","selectedNodeValue","onSelectNode","className","containerRef","useRef","updateDataRef","noop","updateImagesRef","updateSelectedNodeValueRef","updateOnSelectRef","updateSizeRef","useEffect","graph","select","current","append","defs","linksParent","nodesParent","simulation","forceSimulation","_ref2","dataNodes","dataLinks","linkLines","selectAll","map","d","Object","assign","newLinkLinesData","exit","remove","enter","style","attr","width","nodeCircles","backup","Map","id","get","newNodeCirclesData","radius","value","on","this","text","nodeImagePatterns","newNodeImagePatternData","nodeImages","i","imagePlaceholder","_ref3","concat","force","forceLink","strength","forceManyBody","forceCollide","source","x","y","target","alpha","restart","_ref4","_ref5","clientWidth","clientHeight","height","forceX","forceY","window","addEventListener","stop","removeEventListener","_jsx","children"],"sourceRoot":""}