{"version":3,"file":"static/js/9632.79a16ed3.chunk.js","mappings":"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","sources":["utils/hash-from-string/index.js","utils/color-from-string/index.js","utils/merge-intervals/index.js","pages/accession/trajectory/chains/chain-analysis/process-ipscan-results/index.js"],"sourcesContent":["const hashFromString = string => {\n  let hash = 0;\n  for (let i = 0; i < string.length; i++) {\n    hash = (hash << 5) - hash + string.charCodeAt(i);\n    hash |= 0;\n  }\n  return hash;\n};\n\nexport default hashFromString;\n","import hashFromString from '../hash-from-string';\n\nconst colorFromString = string => {\n  const hash = hashFromString(string);\n  const hue = Math.abs(hash % 360);\n  const saturation = Math.abs(hash % 20) + 40; // 50% give or take 10%\n  const lightness = Math.abs(hash % 10) + 45; // 50% give or take 5%\n  return `hsla(${hue}, ${saturation}%, ${lightness}%, 1)`;\n};\n\nexport default colorFromString;\n","const startAccessorDefault = (interval, value) =>\n  Number.isFinite(value) ? (interval[0] = value) : interval[0];\nconst endAccessorDefault = (interval, value) =>\n  Number.isFinite(value) ? (interval[1] = value) : interval[1];\n\nconst mergeIntervals = (\n  intervals,\n  startAccessor = startAccessorDefault,\n  endAccessor = endAccessorDefault,\n) => {\n  const sortedIntervals = Array.from(intervals).sort(\n    (a, b) => startAccessor(a) - startAccessor(b),\n  );\n  let output = [];\n  let current;\n  for (const interval of sortedIntervals) {\n    if (!current) {\n      // first loop\n      current = interval;\n    } else if (endAccessor(current) < startAccessor(interval)) {\n      // current is not within interval\n      output.push(current);\n      current = interval;\n    } else {\n      // current is within, or contiguous to interval\n      endAccessor(\n        current,\n        Math.max(endAccessor(current), endAccessor(interval)),\n      );\n    }\n  }\n  if (current) output.push(current);\n  return output;\n};\n\nexport default mergeIntervals;\n","import colorFromString from '../../../../../../utils/color-from-string';\nimport mergeIntervals from '../../../../../../utils/merge-intervals';\n\n// Renumerate residue numbers to make them match the actual chain they come from\nconst shiftLocations = (fragments, shift) => {\n  fragments.forEach(fragment => {\n    fragment.start += shift;\n    fragment.end += shift;\n  })\n  return fragments;\n}\n\nconst processLocations = (locations, firstResidueNumber = 1) =>\n  locations.map(location => ({\n    fragments: shiftLocations(location['location-fragments'], firstResidueNumber),\n  }));\n\nconst processIPScanResults = (matches, firstResidueNumber) => {\n  const processed = [];\n  // for all the matches\n  for (const match of matches || []) {\n    // if the match has an entry, consider it as a signature of the entry\n    if (match.signature.entry) {\n      let existing = processed.find(\n        m => m.accession === match.signature.entry.accession,\n      );\n      // if the entry hadn't been stored yet, create it now\n      if (!existing) {\n        existing = {\n          accession: match.signature.entry.accession,\n          db: 'InterPro',\n          signatures: [],\n          locations: [],\n          color: colorFromString(match.signature.entry.accession),\n        };\n        processed.push(existing);\n      }\n      const locations = processLocations(match.locations, firstResidueNumber);\n      existing.locations = mergeIntervals(\n        [...existing.locations, ...locations],\n        (interval, value) =>\n          Number.isFinite(value)\n            ? (interval.fragments[0].start = value)\n            : interval.fragments[0].start,\n        (interval, value) =>\n          Number.isFinite(value)\n            ? (interval.fragments[0].end = value)\n            : interval.fragments[0].end,\n      );\n      // add the match as a signature of that entry\n      existing.signatures.push({\n        accession: match.signature.accession,\n        db: match.signature.signatureLibraryRelease.library,\n        locations,\n        color: existing.color.replace(', 1)', ', 0.25)'),\n      });\n    } else {\n      // the match doesn't have entry, it is not integrated\n      processed.push({\n        accession: match.signature.accession,\n        db: match.signature.signatureLibraryRelease.library,\n        locations: processLocations(match.locations, firstResidueNumber),\n        color: colorFromString(match['model-ac']),\n      });\n    }\n  }\n\n  // sort them\n  processed\n    // secondary sort by start position\n    .sort((a, b) => a.locations[0].fragments[0].start - b.locations[0].fragments[0].start)\n    // primary sort by number of signatures\n    .sort((a, b) => (b.signatures || []).length - (a.signatures || []).length);\n\n  return processed;\n};\n\nexport default processIPScanResults;\n"],"names":["string","hash","i","length","charCodeAt","hashFromString","Math","abs","startAccessorDefault","interval","value","Number","isFinite","endAccessorDefault","intervals","startAccessor","arguments","undefined","endAccessor","sortedIntervals","Array","from","sort","a","b","current","output","push","max","processLocations","locations","firstResidueNumber","map","location","fragments","shift","forEach","fragment","start","end","shiftLocations","processIPScanResults","matches","processed","match","signature","entry","existing","find","m","accession","db","signatures","color","colorFromString","mergeIntervals","signatureLibraryRelease","library","replace"],"sourceRoot":""}